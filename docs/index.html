<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGuard SNP Comparison Viewer</title>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #3c3c3c;
            --text-primary: #d4d4d4;
            --text-secondary: #808080;
            --text-muted: #555;
            --border-color: #3c3c3c;
            --accent: #569cd6;
            --accent-hover: #1177bb;
            --btn-bg: #3c3c3c;
            --btn-border: #555;
            --label-color: #9cdcfe;
            --ref-color: #6a9955;
            --snp-consensus: #4ec9b0;
            --snp-consensus-bg: rgba(78, 201, 176, 0.2);
            --snp-uncertain: #dcdcaa;
            --snp-uncertain-bg: rgba(220, 220, 170, 0.2);
            --snp-discord: #f44747;
            --snp-discord-bg: rgba(244, 71, 71, 0.2);
            --snp-pipeline: #ce9178;
            --snp-pipeline-bg: rgba(206, 145, 120, 0.2);
            --snp-vcf: #569cd6;
            --snp-vcf-bg: rgba(86, 156, 214, 0.2);
            --snp-bam: #b5cea8;
            --snp-bam-bg: rgba(181, 206, 168, 0.2);
            --gap-color: #f44747;
            --gap-bg: rgba(244, 71, 71, 0.1);
        }
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #cccccc;
            --accent: #0066cc;
            --accent-hover: #0055aa;
            --btn-bg: #e8e8e8;
            --btn-border: #cccccc;
            --label-color: #0066cc;
            --ref-color: #228b22;
            --snp-consensus: #008080;
            --snp-consensus-bg: rgba(0, 128, 128, 0.15);
            --snp-uncertain: #b8860b;
            --snp-uncertain-bg: rgba(184, 134, 11, 0.15);
            --snp-discord: #cc0000;
            --snp-discord-bg: rgba(204, 0, 0, 0.15);
            --snp-pipeline: #8b4513;
            --snp-pipeline-bg: rgba(139, 69, 19, 0.15);
            --snp-vcf: #0066cc;
            --snp-vcf-bg: rgba(0, 102, 204, 0.15);
            --snp-bam: #228b22;
            --snp-bam-bg: rgba(34, 139, 34, 0.15);
            --gap-color: #cc0000;
            --gap-bg: rgba(204, 0, 0, 0.1);
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s, color 0.3s;
        }
        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
        }
        .header .info {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .theme-toggle {
            position: relative;
            width: 44px;
            height: 22px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.3s ease;
            padding: 0;
        }
        .theme-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: transform 0.3s ease, background 0.3s ease;
        }
        .theme-toggle.light::after {
            transform: translateX(22px);
            background: #ffc107;
        }
        .theme-toggle:hover {
            border-color: var(--accent-color);
        }
        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            margin: 40px;
            padding: 40px;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(86, 156, 214, 0.1);
        }
        .drop-zone h2 {
            color: var(--text-secondary);
            font-weight: normal;
            margin: 0 0 10px 0;
        }
        .loader-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        [data-theme="light"] .loader-overlay {
            background: rgba(255,255,255,0.9);
        }
        .loader-overlay.active {
            display: flex;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loader-text {
            margin-top: 20px;
            color: var(--text-primary);
            font-size: 14px;
        }
        .loader-progress {
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        /* Skeleton loading styles */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: skeleton-pulse 1.5s ease-in-out infinite;
            border-radius: 4px;
        }
        @keyframes skeleton-pulse {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .skeleton-text {
            height: 12px;
            margin: 8px 0;
        }
        .skeleton-box {
            height: 80px;
            margin: 10px 0;
        }
        .section-loading {
            padding: 15px;
            text-align: center;
            color: var(--text-muted);
            font-size: 11px;
        }
        .section-loading .mini-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        .drop-zone p {
            color: var(--text-muted);
            margin: 5px 0;
        }
        .drop-zone .or {
            margin: 20px 0;
            color: var(--text-muted);
        }
        .drop-zone button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .drop-zone button:hover {
            background: var(--accent-hover);
        }
        .hidden {
            display: none !important;
        }
        .main-content {
            padding: 5px 0;
            max-width: 100%;
            width: 100%;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .kpis {
            margin-top: 8px;
        }
        .kpi {
            background: var(--bg-secondary);
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .kpi.kpi-highlight-green {
            background: #e8f5e9;
            border-color: #81c784;
        }
        [data-theme="dark"] .kpi.kpi-highlight-green {
            background: #1b3a1b;
            border-color: #66bb6a;
        }
        .kpi.kpi-highlight-orange {
            background: #fff3e0;
            border-color: #ffb74d;
        }
        .kpi-expand-btn {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            line-height: 18px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            margin-left: 4px;
            vertical-align: middle;
        }
        .kpi-expand-btn:hover {
            background: var(--bg-secondary);
        }
        .kpi-collapsible {
            display: none;
        }
        .kpi-collapsible.expanded {
            display: block;
        }
        .disc-breakdown {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }
        .disc-breakdown .disc-item {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            white-space: nowrap;
        }
        .disc-breakdown .disc-item .disc-val {
            font-weight: 600;
            color: var(--text-primary);
        }
        [data-theme="dark"] .kpi.kpi-highlight-orange {
            background: #3e2c1a;
            border-color: #e6862a;
        }
        .kpi-section {
            margin-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        .kpi-section:first-child {
            margin-top: 0;
            border-top: none;
        }
        .kpi-section > summary {
            width: 100%;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-secondary);
            text-transform: uppercase;
            padding: 8px 0 4px 0;
            letter-spacing: 0.5px;
            cursor: pointer;
            list-style: none;
        }
        .kpi-section > summary::-webkit-details-marker { display: none; }
        .kpi-section > summary::before {
            content: '▶';
            display: inline-block;
            margin-right: 6px;
            font-size: 8px;
            transition: transform 0.15s;
        }
        .kpi-section[open] > summary::before {
            transform: rotate(90deg);
        }
        .kpi-section-content {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 4px;
        }
        .kpi-section-content > table,
        .kpi-section-content > .kpi-sub-label,
        .kpi-section-content > div[style] {
            width: 100%;
        }
        .kpi-sub-label {
            width: 100%;
            font-size: 10px;
            color: var(--text-secondary);
            padding: 6px 0 2px 0;
            opacity: 0.7;
        }
        .kpi-row {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }
        .kpi-row > .kpi-section {
            flex: 1;
            margin-top: 0;
            border-top: none;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
        }
        .kpi-row > .kpi-section:first-child {
            border-top: 1px solid var(--border-color);
        }
        .kpi-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin: 8px 0;
        }
        .kpi-table th, .kpi-table td {
            padding: 6px 10px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }
        .kpi-table th {
            font-size: 10px;
            font-weight: normal;
            color: var(--text-secondary);
            text-transform: uppercase;
            background: var(--bg-secondary);
        }
        .kpi-table th:first-child, .kpi-table td:first-child {
            text-align: left;
        }
        .kpi-table td:first-child {
            font-weight: 500;
            color: var(--text-primary);
        }
        .kpi-table td {
            color: var(--snp-consensus);
        }
        .kpi-table tr:hover {
            background: var(--bg-secondary);
        }
        .kpi-table .pct {
            font-size: 10px;
            color: var(--text-secondary);
            margin-left: 4px;
        }
        .kpi-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .kpi-table .info-icon:hover {
            opacity: 1;
        }
        .kpi.kpi-gt {
            border-color: #7cb342;
        }
        .kpi .label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .kpi .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 12px;
            transition: opacity 0.2s;
        }
        .kpi .info-icon:hover {
            opacity: 1;
        }
        .kpi .value {
            font-size: 18px;
            color: var(--snp-consensus);
            font-weight: bold;
        }
        /* Info Modal */
        .info-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .info-modal.active {
            display: flex;
        }
        .info-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .info-modal-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .info-modal-content p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            font-size: 13px;
            line-height: 1.5;
        }
        .info-modal-content .formula {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        .info-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        .info-modal-close:hover {
            color: var(--text-primary);
        }
        /* Scroll to top button */
        .scroll-top-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 45px;
            height: 45px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: opacity 0.3s, transform 0.3s;
        }
        .scroll-top-btn:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }
        .scroll-top-btn.visible {
            display: flex;
        }
        /* Per-sample statistics table */
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 10px;
        }
        .stats-table th, .stats-table td {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            text-align: right;
        }
        .stats-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
        }
        .stats-table th:first-child, .stats-table td:first-child {
            text-align: left;
            font-weight: bold;
            color: var(--label-color);
        }
        .stats-table tr:hover {
            background: var(--bg-tertiary);
        }
        .stats-table .pipeline-header {
            background: var(--bg-secondary);
            color: var(--accent);
        }
        .stats-table .good { color: #81c784; }
        .stats-table .warning { color: #ffd54f; }
        .stats-table .bad { color: #e57373; }
        .stats-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .stats-table .info-icon:hover {
            opacity: 1;
        }
        .filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.02);
            border-color: var(--accent);
        }
        .filter-btn:active {
            transform: scale(0.98);
        }
        .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent-hover);
            color: white;
            box-shadow: 0 0 8px var(--accent), inset 0 0 4px rgba(255,255,255,0.3);
            font-weight: bold;
            transform: scale(1.05);
        }
        .filter-btn.active::before {
            content: "✓ ";
        }
        .filter-btn.gap-filter {
            color: var(--gap-color);
        }
        .filter-btn.gap-filter.active {
            background: #8b0000;
            border-color: var(--gap-color);
            color: white;
            box-shadow: 0 0 8px var(--gap-color);
            font-weight: bold;
            transform: scale(1.05);
        }
        .nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .nav-controls input {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 10px;
            border-radius: 4px;
            width: 100px;
            font-family: inherit;
        }
        .nav-controls button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .nav-controls button:hover {
            background: var(--bg-tertiary);
        }
        .alignment-view {
            font-size: 11px;
            line-height: 1.1;
            overflow-x: auto;
            white-space: pre;
            width: 100%;
        }
        .alignment-view .row {
            display: flex;
            width: 100%;
        }
        .alignment-view .row.hidden-row {
            display: none;
        }
        .alignment-view .hide-letters {
            color: transparent !important;
            font-size: 0 !important;
        }
        .alignment-view .lbl {
            display: inline-block;
            width: 70px;
            min-width: 70px;
            color: var(--label-color);
            flex-shrink: 0;
            text-align: right;
            padding-right: 3px;
            font-size: 9px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .alignment-view .ref,
        .alignment-view .sample {
            flex-grow: 1;
            letter-spacing: 0px;
        }
        .alignment-view .lbl.sub {
            color: var(--text-secondary);
            font-style: italic;
        }
        .alignment-view .ref {
            color: var(--ref-color);
        }
        .alignment-view .sample {
            color: var(--text-primary);
        }
        .alignment-view .gap {
            color: var(--gap-color);
            background: var(--gap-bg);
        }
        .alignment-view .dim {
            color: var(--text-muted);
        }
        .alignment-view .snp-consensus {
            color: var(--snp-consensus);
            background: var(--snp-consensus-bg);
            font-weight: bold;
        }
        .alignment-view .snp-uncertain {
            color: var(--snp-uncertain);
            background: var(--snp-uncertain-bg);
        }
        .alignment-view .snp-discord {
            color: var(--snp-discord);
            background: var(--snp-discord-bg);
            font-weight: bold;
        }
        .alignment-view .snp-pipeline {
            color: var(--snp-pipeline);
            background: var(--snp-pipeline-bg);
        }
        .alignment-view .snp-vcf {
            color: var(--snp-vcf);
            background: var(--snp-vcf-bg);
        }
        .alignment-view .snp-bam {
            color: var(--snp-bam);
            background: var(--snp-bam-bg);
        }
        .alignment-view .nuc {
            color: var(--text-primary);
        }
        .alignment-view .pos-num,
        .alignment-view .nuc,
        .alignment-view .gap,
        .alignment-view .dim,
        .alignment-view .snp-consensus,
        .alignment-view .snp-uncertain,
        .alignment-view .snp-discord,
        .alignment-view .snp-pipeline,
        .alignment-view .snp-vcf,
        .alignment-view .snp-bam {
            display: inline-block;
            width: 7px;
            text-align: center;
            font-size: 10px;
            position: relative;
        }
        .alignment-view [data-pos]:hover::after {
            content: attr(data-pos);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            border: 1px solid var(--border-color);
        }
        .alignment-view .pos-num {
            color: var(--text-secondary);
        }
        .block.compact .row {
            margin: 2px 0;
        }
        .collapsible-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            margin: 0 4px 10px 4px;
            font-size: 11px;
        }
        .collapsible-panel summary {
            cursor: pointer;
            color: var(--accent);
            user-select: none;
            font-weight: bold;
            padding: 4px 0;
        }
        .collapsible-panel summary:hover {
            color: var(--text-primary);
        }
        .collapsible-panel summary::marker {
            color: var(--text-secondary);
        }
        .collapsible-panel.nested {
            background: var(--bg-primary);
            margin: 0 0 10px 0;
            padding: 6px 10px;
        }
        .collapsible-panel.nested summary {
            font-size: 12px;
            color: var(--label-color);
        }
        #visibility-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }
        .vis-group {
            background: var(--bg-primary);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .vis-group-title {
            color: var(--label-color);
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 10px;
        }
        .vis-item {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 2px 0;
        }
        .vis-item input {
            cursor: pointer;
        }
        .vis-item label {
            cursor: pointer;
            color: var(--text-primary);
            font-size: 10px;
        }
        .filter-options {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-options select {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        .genome-overview-content {
            margin-top: 8px;
        }
        .genome-legend-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
            justify-content: flex-end;
        }
        .genome-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-primary);
            font-size: 10px;
        }
        .genome-legend-item span {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        #genome-canvas {
            width: 100%;
            display: block;
            cursor: crosshair;
        }
        .footer {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            color: var(--text-secondary);
        }
        .legend-content {
            display: flex;
            gap: 20px;
            padding: 8px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }
        .legend-item span.swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        .legend-item .swatch.consensus { background: var(--snp-consensus-bg); border: 1px solid var(--snp-consensus); }
        .legend-item .swatch.uncertain { background: var(--snp-uncertain-bg); border: 1px solid var(--snp-uncertain); }
        .legend-item .swatch.discord { background: var(--snp-discord-bg); border: 1px solid var(--snp-discord); }
        .legend-item .swatch.vcf { background: var(--snp-vcf-bg); border: 1px solid var(--snp-vcf); }
        .legend-item .swatch.bam { background: var(--snp-bam-bg); border: 1px solid var(--snp-bam); }
        .legend-item .swatch.gap { background: var(--gap-bg); border: 1px solid var(--gap-color); }
        .quality-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .quality-filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quality-filter-item label {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .quality-filter-item input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        .quality-filter-item input[type="number"] {
            width: 60px;
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 11px;
        }
        .quality-filter-item .value-display {
            min-width: 35px;
            color: var(--accent);
            font-size: 11px;
        }
        .warnings-container {
            margin-top: 10px;
        }
        .warning-item {
            background: rgba(220, 180, 50, 0.15);
            border: 1px solid #dcb432;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 6px;
            color: #dcb432;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .warning-item::before {
            content: "⚠";
            font-size: 14px;
        }
        .mnp-warning {
            cursor: pointer;
            margin-left: 4px;
            font-size: 12px;
        }
        .description-content {
            font-size: 12px;
            line-height: 1.6;
            color: var(--text-primary);
        }
        .description-content h1 { font-size: 18px; margin: 0 0 12px 0; color: var(--accent); }
        .description-content h2 { font-size: 15px; margin: 16px 0 8px 0; color: var(--accent); }
        .description-content h3 { font-size: 13px; margin: 12px 0 6px 0; color: var(--text-primary); }
        .description-content p { margin: 8px 0; }
        .description-content ul, .description-content ol { margin: 8px 0; padding-left: 24px; }
        .description-content li { margin: 4px 0; }
        .description-content code { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; font-size: 11px; }
        .description-content pre { background: var(--bg-tertiary); padding: 12px; border-radius: 4px; overflow-x: auto; }
        .description-content pre code { background: none; padding: 0; }
        .description-content strong { color: var(--text-primary); }
        .description-content em { font-style: italic; }
        .description-content a { color: var(--accent); }
        .pipeline-info-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 8px;
        }
        .pipeline-info-item .pipeline-name {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .pipeline-info-item .pipeline-command {
            font-family: monospace;
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .pipeline-info-item .pipeline-badge {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            background: var(--accent-color);
            color: white;
        }
        .repro-section {
            margin-bottom: 15px;
        }
        .repro-section h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 12px;
        }
        .repro-cmd {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 6px;
        }
        .repro-cmd code {
            flex: 1;
            font-family: monospace;
            font-size: 10px;
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre;
            color: var(--text-secondary);
        }
        .repro-cmd button {
            padding: 4px 8px;
            font-size: 10px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .repro-cmd button:hover {
            opacity: 0.8;
        }
        .repro-note {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            font-style: italic;
        }
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }
        .pagination button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
        }
        .pagination button:hover {
            background: var(--bg-tertiary);
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 10px 0;
        }
        #file-input {
            display: none;
        }
        .distance-matrix-table {
            margin-top: 10px;
            font-size: 10px;
            border-collapse: collapse;
            width: 100%;
        }
        .table-wrapper {
            overflow-x: auto;
            width: 100%;
        }
        .distance-matrix-table th,
        .distance-matrix-table td {
            padding: 4px 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            white-space: nowrap;
        }
        .distance-matrix-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
        }
        .distance-matrix-table td.diagonal {
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        .distance-matrix-table td.low-dist {
            background: rgba(78, 201, 176, 0.2);
            color: var(--snp-consensus);
        }
        .distance-matrix-table td.medium-dist {
            background: rgba(220, 220, 170, 0.2);
            color: var(--snp-uncertain);
        }
        .distance-matrix-table td.high-dist {
            background: rgba(244, 71, 71, 0.2);
            color: var(--snp-discord);
        }
        .distance-matrix-table td .comparable {
            font-size: 8px;
            color: var(--text-muted);
            display: block;
        }
    </style>
</head>
<body>
    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-text">Loading...</div>
        <div class="loader-progress" id="loader-progress"></div>
    </div>

    <!-- Scroll to top button -->
    <button class="scroll-top-btn" id="scroll-top-btn" onclick="scrollToTop()" title="Scroll to top">↑</button>

    <!-- Info Modal -->
    <div class="info-modal" id="info-modal" onclick="if(event.target===this)closeInfoModal()">
        <div class="info-modal-content">
            <button class="info-modal-close" onclick="closeInfoModal()">&times;</button>
            <h3 id="info-modal-title">KPI Info</h3>
            <div id="info-modal-body"></div>
        </div>
    </div>

    <div class="header">
        <h1>CoreGuard SNP Comparison Viewer</h1>
        <div class="header-right">
            <div class="info" id="header-info">Drop a report to begin (.json, .json.gz, .bin, .bin.gz)</div>
            <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark mode"></button>
        </div>
    </div>

    <div id="drop-zone" class="drop-zone">
        <div style="max-width: 700px; text-align: left;">
            <h2 style="text-align: center; margin-bottom: 1.5rem;">SNP Pipeline Comparison Viewer</h2>

            <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">1. Generate a report</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0; color: var(--text-secondary);">Create a YAML config with your VCF/BAM files, then run:</p>
                    <code style="display: block; background: var(--bg-primary); padding: 8px 12px; border-radius: 4px; font-size: 11px; overflow-x: auto;">coreguard compare --config project.yaml -o report.bin.gz --binary --gzip</code>
                </div>
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">2. Upload and visualize</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0; color: var(--text-secondary);">Drop your report file here or click to browse:</p>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button onclick="document.getElementById('file-input').click()" style="flex: 1;">Choose File</button>
                        <span style="font-size: 11px; color: var(--text-muted);">.json .json.gz .bin .bin.gz</span>
                    </div>
                </div>
            </div>

            <input type="file" id="file-input" accept=".json,.json.gz,.bin,.bin.gz,.gz" style="display: none;" />

            <div style="padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <div style="text-align: center; margin-bottom: 1rem;">
                    <p style="font-size: 12px; color: var(--text-secondary); margin: 0 0 0.75rem 0;">Or try the demo dataset:</p>
                    <button onclick="loadDemo()" style="background: #455a64; font-size: 13px; padding: 10px 20px;">Load Demo</button>
                    <p style="font-size: 11px; opacity: 0.7; margin-top: 8px;">4 <i>Listeria monocytogenes</i> samples &bull; Snippy vs CFSAN vs Ground Truth (minimap2)</p>
                </div>
                <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem;">
                    <p style="font-size: 10px; color: var(--accent); margin: 0 0 0.5rem 0; font-weight: bold;">Demo YAML config:</p>
                    <pre style="background: var(--bg-primary); padding: 8px; border-radius: 4px; font-size: 9px; overflow-x: auto; line-height: 1.3; white-space: pre; margin: 0;">description: testdata/demo_description.md

reference:
  path: reference/AL591824.1.fasta
  label: "Listeria monocytogenes EGD-e"

samples:
  TE15676: { label: "15676" }
  TE15677: { label: "15677" }
  TE15678: { label: "15678" }
  TE8064:  { label: "8064" }

pipelines:
  mm2:
    label: "Ground Truth"
    ground_truth: true
    samples:
      TE15676: { bam: mm2_bams/TE15676.bam }
      TE15677: { bam: mm2_bams/TE15677.bam }
      TE15678: { bam: mm2_bams/TE15678.bam }
      TE8064:  { bam: mm2_bams/TE8064.bam }

  snippy:
    label: "Snippy"
    command: "snippy --ref ref.fa --R1 r1.fq.gz --R2 r2.fq.gz"
    distance_matrix: snippy_distance_matrix.tsv
    core_snps: snippycore/snippycore.tab
    samples:
      TE15676: { vcf: TE15676_snippy.vcf, bam: TE15676_snippy.bam }
      TE15677: { vcf: TE15677_snippy.vcf, bam: TE15677_snippy.bam }
      TE15678: { vcf: TE15678_snippy.vcf, bam: TE15678_snippy.bam }
      TE8064:  { vcf: TE8064_snippy.vcf,  bam: TE8064_snippy.bam }

  cfsan:
    label: "CFSAN"
    command: "cfsan_snp_pipeline run -s samples/ -o out/ ref.fa"
    distance_matrix: cfsan_distance_matrix.tsv
    core_snps: cfsan/snplist.txt
    samples:
      TE15676: { vcf: cfsan/TE15676/var.flt.vcf, bam: cfsan/TE15676/reads.sorted.bam }
      TE15677: { vcf: cfsan/TE15677/var.flt.vcf, bam: cfsan/TE15677/reads.sorted.bam }
      TE15678: { vcf: cfsan/TE15678/var.flt.vcf, bam: cfsan/TE15678/reads.sorted.bam }
      TE8064:  { vcf: cfsan/TE8064/var.flt.vcf,  bam: cfsan/TE8064/reads.sorted.bam }</pre>
                </div>
            </div>
        </div>

        <div style="margin-top: 1.5rem; opacity: 0.6;">
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none;" title="View on GitHub">
                <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <div id="viewer" class="main-content hidden">
        <details class="collapsible-panel" id="description-panel" style="display:none;">
            <summary>Description</summary>
            <div id="description-view" class="description-content"></div>
        </details>

        <details class="collapsible-panel" id="pipelines-panel">
            <summary>Pipelines</summary>
            <div id="pipelines-info">
                <p style="color:var(--text-secondary);font-size:11px;">Pipeline information will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Statistics</summary>
            <div class="kpis" id="kpis"></div>
            <div class="warnings-container" id="warnings"></div>
        </details>

        <details class="collapsible-panel" id="distance-matrix-panel">
            <summary>SNP Distance Matrix <span id="matrix-info"></span></summary>
            <div class="distance-matrix-content" id="distance-matrix-content">
                <div style="display:flex;align-items:center;gap:15px;margin:10px 0;flex-wrap:wrap;">
                    <label style="color:var(--text-secondary);font-size:11px;">Pipeline:
                        <select id="matrix-pipeline" onchange="onMatrixPipelineChange()" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                        </select>
                    </label>
                </div>
                <div id="matrix-result"></div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Genome Overview <span id="genome-info"></span></summary>
            <div class="genome-overview-content">
                <div class="genome-legend-bar">
                    <span class="genome-legend-item"><span style="background:#4ec9b0;"></span> SNPs (top)</span>
                    <span class="genome-legend-item"><span style="background:rgba(244, 71, 71, 0.7);"></span> Gaps (bottom)</span>
                </div>
                <canvas id="genome-canvas" height="100"></canvas>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>View Settings</summary>

            <details class="collapsible-panel nested" open>
                <summary>Row Visibility</summary>
                <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;margin-top:8px;">
                    <input type="text" id="visibility-filter" placeholder="Filter rows..." style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;width:150px;" oninput="filterVisibilityCheckboxes(this.value)">
                    <button onclick="setAllRowVisibility(true)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Select All</button>
                    <button onclick="setAllRowVisibility(false)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Deselect All</button>
                </div>
                <div id="visibility-controls"></div>
            </details>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;margin-bottom:15px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Nucleotide Display</strong>
                <div style="display:flex;gap:15px;flex-wrap:wrap;">
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-nucleotide-letters" checked onchange="toggleNucleotideLetters(this.checked)">
                        Show base letters (A, C, G, T)
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-ref-row" checked onchange="toggleRowVisibility('REF', this.checked)">
                        Show reference row
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-pos-row" checked onchange="toggleRowVisibility('Pos', this.checked)">
                        Show position row
                    </label>
                </div>
            </div>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Legend</strong>
                <div class="legend-content">
                    <div class="legend-item"><span class="swatch consensus"></span> Consensus (all pipelines agree)</div>
                    <div class="legend-item"><span class="swatch uncertain"></span> Uncertain (only one pipeline)</div>
                    <div class="legend-item"><span class="swatch discord"></span> Discordant (pipelines disagree)</div>
                    <div class="legend-item"><span class="swatch vcf"></span> VCF call (from variant caller)</div>
                    <div class="legend-item"><span class="swatch bam"></span> BAM pileup (from reads)</div>
                    <div class="legend-item"><span class="swatch gap"></span> Gap (no coverage)</div>
                </div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Filters & Navigation</summary>
            <div class="controls">
                <div class="filters" id="filters">
                    <span style="color:#808080;margin-right:5px;">Filters:</span>
                </div>
                <div class="filter-options">
                    <label title="How to combine multiple filters">
                        <select id="filter-mode" onchange="onFilterConfigChange()">
                            <option value="and">AND (all filters)</option>
                            <option value="or">OR (any filter)</option>
                        </select>
                    </label>
                    <label title="How to match across samples">
                        <select id="sample-mode" onchange="onFilterConfigChange()">
                            <option value="any">Any sample</option>
                            <option value="all">All samples</option>
                        </select>
                    </label>
                </div>
                <div class="nav-controls">
                    <span style="color:#808080;">Go to:</span>
                    <input type="number" id="goto-pos" placeholder="Position" min="1" />
                    <button onclick="gotoPosition()">Go</button>
                </div>
            </div>
            <details class="collapsible-panel nested" style="margin-top:10px;">
                <summary>Filter Legend</summary>
                <div class="filter-legend" style="font-size:11px;color:var(--text-secondary);line-height:1.6;">
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">SNP Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline Name]</strong>: Show positions where this pipeline called a SNP (variant different from reference)
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Consensus</strong>: Show positions where <em>all selected VCF pipelines called a SNP</em> and they all agree<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: Select pipeline buttons first to compare only those (e.g., Snippy + CFSAN)</span>
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <strong>Discordant</strong>: Show positions where <em>selected pipelines called different SNPs</em> (they disagree)<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: If no pipelines selected, uses all VCF pipelines</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Gap Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline] Gaps</strong>: Show positions where this pipeline has no read coverage (gap)
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <span style="color:var(--text-muted);font-size:10px;">If a pipeline is marked as "ground truth", its gaps indicate positions where the baseline has no data</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Combination Logic</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>AND</strong>: Position must match <em>all</em> selected filters
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>OR</strong>: Position must match <em>any</em> selected filter
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Any sample</strong>: Filter matches if at least one sample meets the condition
                    </div>
                    <div style="margin-left:10px;">
                        <strong>All samples</strong>: Filter matches only if all samples meet the condition
                    </div>
                </div>
            </details>
        </details>

        <div class="status" id="status"></div>
        <div id="load-positions-prompt" style="display:none;text-align:center;padding:30px 20px;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:6px;margin:10px 0;">
            <p style="color:var(--text-secondary);font-size:13px;margin-bottom:12px;">Positions are not loaded yet. Click the button below to load and display the alignment view.</p>
            <button onclick="loadAllPositions()" style="padding:10px 24px;font-size:14px;background:var(--accent-color,#4ec9b0);color:#1e1e1e;border:none;border-radius:6px;cursor:pointer;font-weight:bold;">Load Positions</button>
        </div>
        <div class="alignment-view" id="alignment"></div>

        <div class="pagination" id="pagination">
            <button id="prev-btn" onclick="prevPage()" disabled>&larr; Previous</button>
            <span id="page-info">Page 1</span>
            <button id="next-btn" onclick="nextPage()">Next &rarr;</button>
        </div>

        <div class="footer" id="footer">
            <span onclick="goToLanding()" style="cursor: pointer;" title="Back to home">CoreGuard SNP Comparison Viewer</span>
            <span id="report-timestamp"></span>
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none; margin-left: 1rem;" title="View on GitHub">
                <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <!-- Pako for gzip decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <script>
        // Theme toggling (non-module, runs immediately)
        function initTheme() {
            const savedTheme = localStorage.getItem('coreguard-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : '');
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('coreguard-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('coreguard-theme', newTheme);
            document.documentElement.setAttribute('data-theme', newTheme === 'light' ? 'light' : '');
            updateThemeIcon(newTheme);
            // Redraw canvas with new theme colors
            if (typeof redrawGenomeOverview === 'function') {
                redrawGenomeOverview();
            }
        }

        function updateThemeIcon(theme) {
            const btn = document.getElementById('theme-toggle');
            if (btn) {
                btn.classList.toggle('light', theme === 'light');
                btn.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
            }
        }

        // Initialize theme on page load
        initTheme();

        // KPI Info Modal
        const kpiDescriptions = {
            'reference': {
                title: 'Reference Genome',
                body: `<p>The length of the reference genome in base pairs (bp).</p>
                       <p>All samples are aligned against this reference sequence for SNP calling.</p>`
            },
            'samples': {
                title: 'Number of Samples',
                body: `<p>Total number of samples (isolates) included in this comparison.</p>`
            },
            'pipelines': {
                title: 'Number of Pipelines',
                body: `<p>Number of different SNP calling pipelines being compared.</p>
                       <p>Each pipeline may use different algorithms, parameters, or reference-based variant calling approaches.</p>`
            },
            'snps': {
                title: 'SNP Count',
                body: `<p>Total number of Single Nucleotide Polymorphisms (SNPs) detected by this pipeline across all samples.</p>
                       <div class="formula">% = (SNPs / Reference Length / Samples) × 100</div>
                       <p>The percentage indicates the average SNP density per sample relative to the reference genome.</p>`
            },
            'gaps': {
                title: 'Gap Regions',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) across all samples.</p>
                       <div class="formula">% = (Gap bp / Reference Length / Samples) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants due to low read coverage.</p>
                       <p><strong>High gap percentage</strong> may indicate poor sequencing quality or divergent samples.</p>`
            },
            'snps_in_gt_gaps': {
                title: 'Any SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>at least 1 sample</strong> has a SNP.</p>
                       <div class="formula">% = (Any SNPs in GT Gaps / Any SNPs) × 100</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (&lt;1%)</span>: Good - few SNPs in unreliable regions</li>
                           <li><span style="color:#e57373;">Red (&gt;1%)</span>: Potential false positives in low-coverage regions</li>
                       </ul>`
            },
            'all_snps_in_gt_gaps': {
                title: 'All SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples</strong> have a SNP.</p>
                       <div class="formula">% = (All SNPs in GT Gaps / All SNPs) × 100</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based, any allele)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>These are consistently called SNPs in unreliable regions</li>
                           <li>May indicate systematic differences between pipelines</li>
                       </ul>`
            },
            'consensus_snps_in_gt_gaps': {
                title: 'Consensus SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples have the SAME allele</strong>.</p>
                       <div class="formula">% = (Consensus SNPs in GT Gaps / Consensus SNPs) × 100</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Most reliable variant calls in unreliable regions</li>
                           <li>Consensus SNPs in GT gaps warrant closer inspection</li>
                       </ul>`
            },
            'snps_in_pipeline_gaps': {
                title: 'SNPs in Pipeline Gaps',
                body: `<p>SNPs from one pipeline that fall within gap regions of another pipeline.</p>
                       <div class="formula">% = (SNPs in Gaps / Total SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows SNPs called by one pipeline in regions where another has low coverage</li>
                           <li>High values may indicate false positives or differences in coverage</li>
                           <li>Useful for comparing pipeline reliability across different regions</li>
                       </ul>`
            },
            // Per-Sample Statistics metrics
            'ps_snps': {
                title: 'Per-Sample SNPs',
                body: `<p>Number of SNPs called by this pipeline for this sample.</p>
                       <div class="formula">% = (SNPs / Reference Length) × 100</div>
                       <p>Percentage shows SNP density relative to the reference genome size.</p>`
            },
            'ps_gaps': {
                title: 'Per-Sample Gaps',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) for this sample.</p>
                       <div class="formula">% = (Gap bp / Reference Length) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants.</p>`
            },
            'ps_vs_gt': {
                title: 'vs GT (Agreement)',
                body: `<p>Pipeline SNPs that are at the same positions as GT SNPs for this sample.</p>
                       <div class="formula">% = (Pipeline ∩ GT SNP positions / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≥90%</span>: Good agreement with ground truth</li>
                           <li><span style="color:#ffc107;">70-90%</span>: Moderate agreement</li>
                           <li><span style="color:#e57373;">&lt;70%</span>: Poor agreement</li>
                       </ul>`
            },
            'ps_in_gt_gaps': {
                title: 'in GT Gaps',
                body: `<p>Pipeline SNPs that fall within GT gap regions (low coverage in GT).</p>
                       <div class="formula">% = (SNPs in GT Gaps / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≤1%</span>: Good - few SNPs in unreliable GT regions</li>
                           <li><span style="color:#ffc107;">1-5%</span>: Some SNPs in GT gaps</li>
                           <li><span style="color:#e57373;">&gt;5%</span>: Many SNPs in GT gaps - potential false positives</li>
                       </ul>`
            },
            'ps_intersection': {
                title: 'Pipeline ∩ GT Intersection',
                body: `<p>SNP positions where both the pipeline and GT have called a SNP for this sample.</p>
                       <div class="formula">Intersection = |Pipeline SNP positions ∩ GT SNP positions|</div>
                       <div class="formula">% = (Intersection / GT SNPs) × 100</div>
                       <p>Shows what percentage of GT SNPs are also called by the pipeline.</p>`
            },
            'ps_vcf_consensus': {
                title: 'VCF Consensus SNPs',
                body: `<p>SNP positions where ALL VCF pipelines (excluding GT) agree for this sample.</p>
                       <div class="formula">VCF Consensus = ∩ all VCF pipelines</div>
                       <div class="formula">% = (VCF Consensus / Reference Length) × 100</div>
                       <p>These are the most confident variant calls where all VCF-based pipelines agree.</p>`
            },
            'ps_consensus_in_gt': {
                title: 'VCF Consensus in GT',
                body: `<p>VCF consensus SNPs that are also present in GT for this sample.</p>
                       <div class="formula">% = (VCF Consensus ∩ GT / VCF Consensus) × 100</div>
                       <p>High percentage means VCF consensus aligns well with ground truth.</p>`
            },
            'ps_all_consensus': {
                title: 'All Consensus (GT ∩ VCF)',
                body: `<p>Positions where ALL pipelines (including GT) agree for this sample.</p>
                       <div class="formula">All Consensus = GT ∩ VCF Consensus</div>
                       <div class="formula">% = (All Consensus / Reference Length) × 100</div>
                       <p>These are the highest confidence calls - all pipelines agree.</p>`
            },
            'gt_snps_missing': {
                title: 'Any GT SNPs Filtered',
                body: `<p>GT SNP positions (≥1 sample) that this pipeline does <strong>NOT</strong> call.</p>
                       <div class="formula">Σ(GT<sub>sample</sub> - (GT<sub>sample</sub> ∩ Pipeline<sub>sample</sub>))</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows GT SNPs being "filtered out" by each pipeline</li>
                           <li>Higher values = more aggressive filtering</li>
                       </ul>`
            },
            'all_gt_missing': {
                title: 'All GT SNPs Filtered',
                body: `<p>GT SNP positions (ALL samples) not present in the pipeline.</p>
                       <div class="formula">|All GT| - |All GT ∩ All Pipeline|</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows consistent GT SNPs missing from pipeline</li>
                           <li>Lower = pipeline captures consistent GT signal</li>
                       </ul>`
            },
            'consensus_gt_missing': {
                title: 'Consensus GT SNPs Filtered',
                body: `<p>GT Consensus positions not present in the pipeline's consensus.</p>
                       <div class="formula">|Consensus GT| - |Consensus GT ∩ Consensus Pipeline|</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows highly reliable GT SNPs missing from pipeline's consensus</li>
                           <li>Lower = pipeline captures consistent variant calls</li>
                       </ul>`
            },
            'bam_pileup': {
                title: 'BAM Pileup — SNP Calling Logic',
                body: `<p>⚠️ <strong>These SNPs were derived from BAM pileup analysis</strong>, not from a variant calling pipeline.</p>
                       <p><strong>How a position is classified:</strong></p>
                       <ol style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Count all reads at the position (A, C, G, T)</li>
                           <li>If total depth &lt; <code>min_depth</code> → <strong>Gap</strong> (position ignored)</li>
                           <li>Take the most frequent base (majority vote)</li>
                           <li>If majority base &lt; <code>min_consensus</code> (default 80%) of reads → <strong>Ambiguous</strong> (position ignored)</li>
                           <li>If majority base ≠ reference → <strong>SNP</strong></li>
                       </ol>
                       <table style="width:100%;font-size:11px;border-collapse:collapse;margin:8px 0;">
                       <tr style="background:var(--bg-tertiary);"><th style="padding:4px 6px;text-align:left;">Example</th><th style="padding:4px 6px;text-align:left;">Reads</th><th style="padding:4px 6px;text-align:left;">Result</th></tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;">Ref=T, 100 reads</td>
                           <td style="padding:4px 6px;font-family:monospace;">85×A, 15×T</td>
                           <td style="padding:4px 6px;">A is 85% → <strong>SNP (A)</strong></td>
                       </tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;">Ref=T, 100 reads</td>
                           <td style="padding:4px 6px;font-family:monospace;">75×A, 25×T</td>
                           <td style="padding:4px 6px;">A is 75% &lt; 80% → <strong>Ambiguous</strong> (skipped)</td>
                       </tr>
                       <tr>
                           <td style="padding:4px 6px;">Ref=T, 3 reads</td>
                           <td style="padding:4px 6px;font-family:monospace;">3×A</td>
                           <td style="padding:4px 6px;">Depth 3 &lt; min_depth → <strong>Gap</strong></td>
                       </tr>
                       </table>
                       <p style="font-size:11px;"><strong>Parameters (configurable in YAML):</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><code>min_depth</code>: minimum read depth to consider a position (default from <code>options.min_depth</code>)</li>
                           <li><code>min_consensus</code>: minimum fraction of reads agreeing on a base (currently 80%)</li>
                       </ul>
                       <p><strong>Use case:</strong> Ground truth baseline for comparing pipeline filtering behavior.</p>`
            },
            'concordance': {
                title: 'Position Concordance',
                body: `<p><strong>Concordance</strong> = SNP positions called by BOTH pipelines (regardless of allele).</p>
                       <div class="formula">Concordance = positions where Pipeline A AND Pipeline B call a SNP</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has SNP in both pipelines at this position</li>
                           <li><strong>All:</strong> ALL samples have SNP in both pipelines (Core_A ∩ Core_B)</li>
                       </ul>
                       <p><strong>Note:</strong> Concordance only checks if a SNP exists - it does NOT compare the actual allele called.</p>`
            },
            'consensus': {
                title: 'Allele Consensus',
                body: `<p><strong>Consensus</strong> = SNP positions where BOTH pipelines call the SAME allele.</p>
                       <div class="formula">Consensus = positions where Pipeline A alt == Pipeline B alt</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has the same allele in both pipelines</li>
                           <li><strong>All:</strong> ALL samples have the same allele in both pipelines</li>
                       </ul>
                       <p><strong>Note:</strong> Consensus ≤ Concordance (consensus is a subset where alleles match).</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consensus ≈ Concordance: pipelines agree on alleles</li>
                           <li>Consensus &lt;&lt; Concordance: pipelines find same positions but call different alleles</li>
                       </ul>`
            },
            'mnp': {
                title: 'MNP Decomposition',
                body: `<p><strong>MNP (Multi-Nucleotide Polymorphism)</strong> = multiple adjacent SNPs reported as a single variant in VCF.</p>
                       <p><strong>Example:</strong></p>
                       <div class="formula">VCF: pos=100, REF=ACG, ALT=TGA</div>
                       <p>This MNP is decomposed into 3 individual SNPs:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>pos=100: A→T</li>
                           <li>pos=101: C→G</li>
                           <li>pos=102: G→A</li>
                       </ul>
                       <p><strong>Why decompose?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consistent position-level comparison between pipelines</li>
                           <li>Some pipelines report MNPs, others report individual SNPs</li>
                           <li>Enables accurate intersection and agreement calculations</li>
                       </ul>
                       <p><strong>Note:</strong> The total SNP count increases after decomposition, which is expected.</p>`
            },
            'mnps': {
                title: 'MNP Statistics',
                body: `<p><strong>MNPs Detected</strong> = Number of Multi-Nucleotide Polymorphisms found and decomposed into individual SNPs.</p>
                       <div class="formula">Format: X → Y SNPs</div>
                       <p>Where X = number of MNPs found, Y = total individual SNPs they produced.</p>
                       <p><strong>Example:</strong> "50 → 127 SNPs" means 50 MNPs were decomposed into 127 individual SNPs.</p>
                       <p><strong>Why track this?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows pipeline-specific MNP handling</li>
                           <li>Higher MNP count may indicate different variant calling approach</li>
                           <li>Helps understand differences between pipelines</li>
                       </ul>`
            },
            'filtered': {
                title: 'Filtered Positions',
                body: `<p>Number of positions matching the currently active filters.</p>
                       <p>Use the filter buttons to narrow down positions by:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Pipeline filters:</strong> Show only SNPs from specific pipelines</li>
                           <li><strong>Consensus:</strong> Show positions where selected pipelines agree</li>
                           <li><strong>Discordant:</strong> Show positions where pipelines disagree</li>
                           <li><strong>Gap filters:</strong> Show gap regions for specific pipelines</li>
                       </ul>`
            },
            'filter_pipeline': {
                title: 'Pipeline SNP Filter',
                body: `<p>Show only positions where this pipeline called a SNP.</p>
                       <p><strong>Multiple pipelines selected:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>OR mode:</strong> Position has SNP in ANY selected pipeline</li>
                           <li><strong>AND mode:</strong> Position has SNP in ALL selected pipelines</li>
                       </ul>
                       <p>Use the mode selector to switch between OR/AND logic.</p>`
            },
            'filter_consensus': {
                title: 'Consensus Filter',
                body: `<p>Show positions where <strong>ALL selected pipelines agree</strong> on having a SNP.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Example:</strong> With CFSAN and Snippy selected, shows positions where both call a SNP at the same position.</p>
                       <p><strong>Note:</strong> This is the intersection of selected pipelines' SNP positions.</p>`
            },
            'filter_discordant': {
                title: 'Discordant Filter',
                body: `<p>Show positions where <strong>pipelines disagree</strong> - at least one has a SNP and at least one doesn't.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Use case:</strong> Find positions where variant callers give different results, useful for:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Identifying pipeline-specific artifacts</li>
                           <li>Finding borderline/low-confidence variants</li>
                           <li>Quality control and validation</li>
                       </ul>`
            },
            'filter_gaps': {
                title: 'Gap Filter',
                body: `<p>Show positions where this pipeline has a <strong>coverage gap</strong> (depth below threshold).</p>
                       <p>Gaps indicate regions where:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Read coverage was insufficient for variant calling</li>
                           <li>The sample may be missing this genomic region</li>
                           <li>Sequencing quality was poor in this area</li>
                       </ul>
                       <p><strong>Note:</strong> SNPs called in gap regions of other pipelines may be less reliable.</p>`
            },
            'core_snps': {
                title: 'All SNPs (position-based)',
                body: `<p><strong>All</strong> = SNP positions present in <strong>ALL samples</strong> within this pipeline.</p>
                       <p>Position-based: counts where ALL samples have a SNP, regardless of which allele.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High % = consistent variant calling across samples</li>
                           <li>Low % = many sample-specific variants</li>
                       </ul>
                       <p><strong>Note:</strong> "All" ⊇ "Consensus" (All includes Consensus as a subset)</p>`
            },
            'consensus_snps': {
                title: 'Consensus SNPs',
                body: `<p><strong>Consensus SNPs</strong> = SNP positions where <strong>ALL samples within this pipeline</strong> have the <strong>SAME alt allele</strong>.</p>
                       <p>This is the intersection of SNP positions across all variant callers.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High consensus % = pipelines mostly agree</li>
                           <li>Low consensus % = pipelines find different variants (method-specific calls)</li>
                       </ul>
                       <p><strong>Note:</strong> The consensus count is the same for all pipelines since it's the intersection.</p>`
            },
            'pp_gi_usable': {
                title: 'Gap-Intersect — Usable Space',
                body: `<p>Reference positions remaining after removing only those where <strong>ALL samples</strong> have a gap in this pipeline.</p>
                       <div class="formula">Usable Space = Reference Length − intersection(pipeline gaps of all samples)</div>
                       <p>More permissive: a position is excluded only if every sample has a gap there.</p>`
            },
            'pp_gi_total': {
                title: 'Gap-Intersect — Total SNPs',
                body: `<p>Positions in usable space where <strong>at least 1 sample</strong> has an alt allele vs reference in this pipeline.</p>
                       <div class="formula">Total SNPs = Consensus + Discriminating</div>`
            },
            'pp_gi_consensus': {
                title: 'Gap-Intersect — Consensus SNPs',
                body: `<p>Positions where all samples <strong>with data</strong> (no gap) agree on the same alt allele.</p>
                       <p>Samples with a gap at the position are ignored. Among the remaining, all must have the same alt allele.</p>`
            },
            'pp_gi_disc': {
                title: 'Gap-Intersect — Discriminating SNPs',
                body: `<p>Positions where samples <strong>differ</strong>, considering only samples without a gap at each position.</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Fewer than 2 samples with data → <strong>not counted</strong></li>
                           <li>All agree → <strong>consensus</strong></li>
                           <li>At least 2 differ → <strong>discriminating</strong></li>
                       </ul>
                       <p><strong>Breakdown (VCF pipelines only):</strong></p>
                       <table style="width:100%;font-size:11px;border-collapse:collapse;margin:8px 0;">
                       <tr style="background:var(--bg-tertiary);"><th style="padding:4px 6px;text-align:left;">Heuristic</th><th style="padding:4px 6px;text-align:left;">Description</th><th style="padding:4px 6px;text-align:left;">Example (Ref=T, 4 samples)</th></tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;font-weight:600;">Gap-affected</td>
                           <td style="padding:4px 6px;">≥1 sample skipped due to gap, comparison is partial</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, <span style="color:#e6862a;">gap</span>, T → 2 samples differ (A vs T) but one was skipped. Without the gap the result might change.</td>
                       </tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;font-weight:600;">GT-consensus</td>
                           <td style="padding:4px 6px;">GT pileup shows all samples agree — variant calling artifact</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, A, <span style="color:#e6862a;">ref</span> → discriminating (3×A vs 1×ref).<br>GT pileup: A, A, A, A → all agree. The VCF missed the call in sample 4.</td>
                       </tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;font-weight:600;">Majority-rule</td>
                           <td style="padding:4px 6px;">All but one sample agree — likely single-sample VC miss</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, A, <span style="color:#e6862a;">ref</span> → 3 agree on A, 1 has ref. No GT data to confirm, but the majority suggests the 4th sample missed the call.</td>
                       </tr>
                       <tr>
                           <td style="padding:4px 6px;font-weight:600;">Confirmed</td>
                           <td style="padding:4px 6px;">Genuine disagreement — none of the above apply</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, G, G → 2×A vs 2×G. GT also shows disagreement. Real biological variation between samples.</td>
                       </tr>
                       </table>`
            },
            'pp_gu_usable': {
                title: 'Gap-Union — Usable Space',
                body: `<p>Reference positions remaining after removing those where <strong>at least 1 sample</strong> has a gap in this pipeline.</p>
                       <div class="formula">Usable Space = Reference Length − union(pipeline gaps of all samples)</div>
                       <p>Most restrictive: a position is excluded if any sample has a gap there.</p>`
            },
            'pp_gu_total': {
                title: 'Gap-Union — Total SNPs',
                body: `<p>Positions in usable space where <strong>at least 1 sample</strong> has an alt allele vs reference in this pipeline.</p>
                       <div class="formula">Total SNPs = Consensus + Discriminating</div>`
            },
            'pp_gu_consensus': {
                title: 'Gap-Union — Consensus SNPs',
                body: `<p>Positions where <strong>ALL samples</strong> have the same alt allele. No sample can have a gap here (they were all excluded by the union).</p>`
            },
            'pp_gu_disc': {
                title: 'Gap-Union — Discriminating SNPs',
                body: `<p>Positions where samples <strong>differ</strong> in alt allele or SNP presence. All samples have data (no gaps in usable space).</p>
                       <p><strong>Breakdown (VCF pipelines only):</strong></p>
                       <table style="width:100%;font-size:11px;border-collapse:collapse;margin:8px 0;">
                       <tr style="background:var(--bg-tertiary);"><th style="padding:4px 6px;text-align:left;">Heuristic</th><th style="padding:4px 6px;text-align:left;">Description</th><th style="padding:4px 6px;text-align:left;">Example (Ref=T, 4 samples)</th></tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;font-weight:600;">GT-consensus</td>
                           <td style="padding:4px 6px;">GT pileup shows all samples agree — variant calling artifact</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, A, <span style="color:#e6862a;">ref</span> → discriminating.<br>GT pileup: A, A, A, A → all agree. The variant caller missed the SNP in sample 4.</td>
                       </tr>
                       <tr style="border-bottom:1px solid var(--border-color);">
                           <td style="padding:4px 6px;font-weight:600;">Majority-rule</td>
                           <td style="padding:4px 6px;">All but one sample agree — likely single-sample VC miss</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, A, <span style="color:#e6862a;">ref</span> → 3×A vs 1×ref. No GT data to confirm, but the majority suggests the 4th missed the call.</td>
                       </tr>
                       <tr>
                           <td style="padding:4px 6px;font-weight:600;">Confirmed</td>
                           <td style="padding:4px 6px;">Genuine disagreement — none of the above apply</td>
                           <td style="padding:4px 6px;font-family:monospace;">VCF: A, A, G, G → 2×A vs 2×G. GT also shows disagreement. Real biological variation.</td>
                       </tr>
                       </table>
                       <p style="font-size:11px;color:var(--text-secondary);"><em>Note: Gap-affected is always 0 in Gap-Union because all positions with any gap are already excluded from usable space.</em></p>`
            },
            'pp_pw_usable': {
                title: 'Pairwise (Gap-Union) — Avg Usable Space',
                body: `<p>Average usable genome space across all sample pairs for this pipeline.</p>
                       <div class="formula">For each pair (A, B): Usable = RefLength − union(pipeline gaps A, pipeline gaps B)</div>`
            },
            'pp_pw_disc': {
                title: 'Pairwise (Gap-Union) — Discriminating SNPs',
                body: `<p>Pairwise discriminating SNP statistics for this pipeline.</p>
                       <div class="formula">For each pair (A, B): count positions where A ≠ B, not in pair's gap union</div>
                       <p>Shows average, minimum, median, and maximum across all pairs.</p>`
            },
            'pp_ps_table': {
                title: 'Per-Sample Pairwise Breakdown',
                body: `<p>For each sample S, averages are computed across all (N−1) pairs involving S.</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Avg Usable Space:</strong> average usable bp across pairs involving this sample</li>
                           <li><strong>Avg Discriminating SNPs:</strong> average discriminating SNPs across pairs involving this sample</li>
                       </ul>
                       <p>A sample with high avg discriminating SNPs is more distant from the others.</p>`
            },
            'gt_disc_vs_pl': {
                title: 'GT Discriminating SNPs vs Pipelines',
                body: `<p>For each gap strategy, compares <strong>GT discriminating SNPs</strong> against each VCF pipeline:</p>
                       <ul>
                           <li><strong>GT Disc:</strong> number of GT discriminating positions in the usable space</li>
                           <li><strong>Same Pos:</strong> how many GT disc positions the pipeline also calls as a SNP (% of GT Disc)</li>
                           <li><strong>Concordant:</strong> among same-position SNPs, how many have matching alleles across all samples (% of Same Pos)</li>
                           <li><strong>In GT Gaps:</strong> pipeline SNP positions that fall within GT gap regions</li>
                       </ul>`
            },
            'gt_disc_gi': {
                title: 'Gap-Intersect Strategy',
                body: `<p>GT discriminating positions computed using <strong>Gap-Intersect</strong>: only positions where ALL samples have a GT gap are excluded.</p>
                       <p>More permissive — positions where some (but not all) samples have gaps are still evaluated among the non-gap samples.</p>
                       <p><strong>In GT Gaps</strong> counts pipeline SNPs falling in the GT gap-intersection set.</p>`
            },
            'gt_disc_gu': {
                title: 'Gap-Union Strategy',
                body: `<p>GT discriminating positions computed using <strong>Gap-Union</strong>: positions where ANY sample has a GT gap are excluded.</p>
                       <p>More strict — all samples must have data at a position for it to be considered.</p>
                       <p><strong>In GT Gaps</strong> counts pipeline SNPs falling in the GT gap-union set.</p>`
            },
            'gt_disc_pw': {
                title: 'Pairwise Strategy',
                body: `<p>For each pair of samples, GT discriminating positions are computed using <strong>pairwise Gap-Union</strong> (excluding positions where either sample has a gap).</p>
                       <p>Values shown are <strong>averages</strong> across all sample pairs. No "In GT Gaps" column — it would be the same per pipeline regardless of pair.</p>`
            }
        };

        function showKpiInfo(kpiType) {
            const info = kpiDescriptions[kpiType];
            if (!info) return;

            document.getElementById('info-modal-title').textContent = info.title;
            document.getElementById('info-modal-body').innerHTML = info.body;
            document.getElementById('info-modal').classList.add('active');
        }

        function closeInfoModal() {
            document.getElementById('info-modal').classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeInfoModal();
        });

        // Scroll to top button
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const btn = document.getElementById('scroll-top-btn');
            if (window.scrollY > 300) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        });
    </script>

    <script>
        // Worker-based architecture for non-blocking UI
        // All heavy WASM operations run in a separate thread

        // Worker API - promise-based interface to the worker
        class WorkerAPI {
            constructor() {
                this.worker = new Worker('./worker.js', { type: 'module' });
                this.pending = new Map();
                this.nextId = 0;
                this.ready = false;
                this.cachedData = {}; // Cache for frequently accessed data

                this.worker.onmessage = (e) => {
                    const { id, success, result, error } = e.data;
                    const resolver = this.pending.get(id);
                    if (resolver) {
                        this.pending.delete(id);
                        if (success) {
                            resolver.resolve(result);
                        } else {
                            resolver.reject(new Error(error));
                        }
                    }
                };
            }

            send(action, payload = {}) {
                return new Promise((resolve, reject) => {
                    const id = this.nextId++;
                    this.pending.set(id, { resolve, reject });
                    this.worker.postMessage({ id, action, payload });
                });
            }

            async init() {
                const result = await this.send('init');
                this.ready = result.success;
                return this.ready;
            }

            async loadBinary(data) {
                const result = await this.send('loadBinary', { data });
                this.cachedData = result; // Cache all the basic info
                return result;
            }

            async loadJson(json) {
                const result = await this.send('loadJson', { json });
                this.cachedData = result;
                return result;
            }

            async getPipelineInfo(pipelineIds) {
                return await this.send('getPipelineInfo', { pipelineIds });
            }

            async getSampleLabel(sampleId) {
                return (await this.send('getSampleLabel', { sampleId })).label;
            }

            async getPipelineLabel(pipelineId) {
                return (await this.send('getPipelineLabel', { pipelineId })).label;
            }

            async getFilteredPositions(samples, filterStr, filterMode, sampleMode) {
                return (await this.send('getFilteredPositions', {
                    samples, filterStr, filterMode, sampleMode
                })).positions;
            }

            async renderFiltered(samples, positions, offset, limit) {
                return (await this.send('renderFiltered', {
                    samples, positions, offset, limit
                })).html;
            }

            async getKpis() {
                return (await this.send('getKpis')).kpis;
            }

            async getSnp(sample, pipeline, pos) {
                return (await this.send('getSnp', { sample, pipeline, pos })).snp;
            }

            async getGlobalStats() {
                return (await this.send('getGlobalStats')).stats;
            }

            async getPairwiseUsableStats() {
                return (await this.send('getPairwiseUsableStats')).stats;
            }

            async getGlobalStatsForPipeline(pipelineId) {
                return (await this.send('getGlobalStatsForPipeline', { pipelineId })).stats;
            }

            async getPairwiseUsableStatsForPipeline(pipelineId) {
                return (await this.send('getPairwiseUsableStatsForPipeline', { pipelineId })).stats;
            }

            async getGtDiscVsPipelines() {
                return (await this.send('getGtDiscVsPipelines', {})).stats;
            }

            // Cached accessors (no worker call needed after load)
            get refName() { return this.cachedData.refName; }
            get refLength() { return this.cachedData.refLength; }
            get sampleIds() { return this.cachedData.sampleIds; }
            get pipelineIds() { return this.cachedData.pipelineIds; }
            get generatedAt() { return this.cachedData.generatedAt; }
            get description() { return this.cachedData.description; }
            get warnings() { return this.cachedData.warnings; }
            get vcfPipelines() { return this.cachedData.vcfPipelines; }
            get groundTruthPipeline() { return this.cachedData.groundTruthPipeline; }
            get pipelineDistanceMatrices() { return this.cachedData.pipelineDistanceMatrices; }
            get pipelineInfo() { return this.cachedData.pipelineInfo; }
            get sampleLabels() { return this.cachedData.sampleLabels; }

            // Helper methods for cached data
            getPipelineLabel(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.label || pipelineId;
            }
            getPipelineCommand(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.command || '';
            }
            isGroundTruth(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.isGroundTruth || false;
            }
            isFromBamPileup(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.isFromBamPileup || false;
            }
            getSampleLabel(sampleId) {
                return this.cachedData.sampleLabels?.[sampleId] || sampleId;
            }
        }

        let workerApi = null;
        let samples = [];
        let positions = [];
        let currentPage = 0;
        let activeFilters = [];
        const CHAR_WIDTH = 7;
        const LABEL_WIDTH = 70;

        function getPageSize() {
            // Calculate how many nucleotides fit in the available width
            const availableWidth = window.innerWidth - LABEL_WIDTH - 20; // 20px padding
            return Math.max(50, Math.floor(availableWidth / CHAR_WIDTH));
        }

        window.gotoPosition = gotoPosition;
        window.nextPage = nextPage;
        window.prevPage = prevPage;
        window.toggleFilter = toggleFilter;
        window.onFilterConfigChange = onFilterConfigChange;
        window.setAllRowVisibility = setAllRowVisibility;
        window.filterVisibilityCheckboxes = filterVisibilityCheckboxes;
        window.toggleRowVisibility = toggleRowVisibility;
        window.redrawGenomeOverview = async () => {
            if (workerApi && workerApi.ready && samples.length > 0) {
                await drawGenomeOverview();
            }
        };

        let pipelines = [];
        let qualityFilters = { minQual: 0, minDepth: 0, minConsensus: 50 };

        function showLoader(text, progress = '') {
            document.getElementById('loader').classList.add('active');
            document.getElementById('loader-text').textContent = text;
            document.getElementById('loader-progress').textContent = progress;
        }

        function hideLoader() {
            document.getElementById('loader').classList.remove('active');
        }

        function goToLanding() {
            document.getElementById('viewer').classList.add('hidden');
            document.getElementById('drop-zone').classList.remove('hidden');
        }

        // Progressive loading helpers
        function setSectionLoading(containerId, isLoading, message = 'Loading...') {
            const container = document.getElementById(containerId);
            if (!container) return;
            if (isLoading) {
                container.innerHTML = `<div class="section-loading"><span class="mini-spinner"></span>${message}</div>`;
            }
        }

        function scheduleIdleTask(callback, timeout = 2000) {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(callback, { timeout });
            } else {
                setTimeout(callback, 10);
            }
        }

        // Progressive UI builder - shows UI immediately, then populates sections
        async function buildUIProgressively() {
            const t0 = performance.now();

            // Phase 1: Show viewer immediately with loading states
            document.getElementById('drop-zone').classList.add('hidden');
            document.getElementById('viewer').classList.remove('hidden');

            // Set loading placeholders for all sections
            setSectionLoading('pipelines-info', true, 'Loading pipelines...');
            setSectionLoading('kpis', true, 'Calculating statistics...');
            setSectionLoading('matrix-result', true, 'Ready to display');
            setSectionLoading('alignment', true, 'Positions will load after statistics...');

            // Phase 2: Quick stuff first (instant)
            await nextFrame();
            populateDescription();
            displayWarnings();
            console.log(`Phase 2 (description): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 3: Pipeline info (fast)
            await nextFrame();
            populatePipelineInfo();
            populateMatrixPipelineSelector();
            console.log(`Phase 3 (pipelines): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 4: KPIs (medium)
            await nextFrame();
            await updateKPIs();
            createFilterButtons(pipelines);
            createVisibilityControls(pipelines);
            console.log(`Phase 4 (KPIs): ${(performance.now() - t0).toFixed(0)}ms`);

            // Hide loader - core UI is now visible
            hideLoader();

            // Phase 5: Genome overview (heavy, but visible)
            await nextFrame();
            await drawGenomeOverview();
            console.log(`Phase 7 (genome): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 8: Show load positions button (user-triggered)
            document.getElementById('load-positions-prompt').style.display = 'block';
            console.log(`Phase 8 (positions button shown): ${(performance.now() - t0).toFixed(0)}ms`);

            // Clear matrix placeholder
            document.getElementById('matrix-result').innerHTML =
                '<p style="color:var(--text-secondary);font-size:11px;">Select a pipeline to view its pre-computed distance matrix.</p>';

            console.log(`UI build complete: ${(performance.now() - t0).toFixed(0)}ms`);
        }

        function nextFrame() {
            return new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        }

        async function main() {
            workerApi = new WorkerAPI();
            showLoader('Initializing...', 'Loading WASM module');
            const success = await workerApi.init();
            if (!success) {
                alert('Failed to initialize WASM module');
                return;
            }
            hideLoader();
            console.log('Worker + WASM initialized');
            setupDropZone();
            setupFileInput();
        }

        function setupDropZone() {
            const dropZone = document.getElementById('drop-zone');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('dragover');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('dragover');
                });
            });

            dropZone.addEventListener('drop', (e) => {
                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.json') || file.name.endsWith('.json.gz') || file.name.endsWith('.bin') || file.name.endsWith('.bin.gz') || file.name.endsWith('.gz'))) {
                    loadFile(file);
                }
            });
        }

        function setupFileInput() {
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadFile(file);
                }
            });
        }

        // Streaming decompression with progress updates (returns text)
        async function decompressGzipWithProgress(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                // Native streaming decompression
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const decoder = new TextDecoder();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(decoder.decode(value, { stream: true }));
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    // Yield to UI every few MB
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }
                chunks.push(decoder.decode()); // Flush
                return chunks.join('');
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed, { to: 'string' });
        }

        // Streaming decompression for binary data (returns Uint8Array)
        async function decompressGzipBinary(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }

                // Combine all chunks into single Uint8Array
                const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    result.set(chunk, offset);
                    offset += chunk.length;
                }
                return result;
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed);
        }

        // Detect if file is binary format based on filename
        function isBinaryFormat(filename) {
            return filename.endsWith('.bin') || filename.endsWith('.bin.gz');
        }

        async function loadDemo() {
            showLoader('Loading demo...', 'Fetching demo data');
            await new Promise(r => requestAnimationFrame(r));

            try {
                // Load JSON gzip format
                const response = await fetch('demo.json.gz');
                if (!response.ok) throw new Error('Failed to fetch demo file');

                const compressedSize = parseInt(response.headers.get('content-length') || '0');
                showLoader('Downloading...', `${(compressedSize / 1024 / 1024).toFixed(1)} MB compressed`);
                await new Promise(r => requestAnimationFrame(r));
                const arrayBuffer = await response.arrayBuffer();

                showLoader('Decompressing...', '0 MB');
                const jsonText = await decompressGzipWithProgress(arrayBuffer, (bytes) => {
                    showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                });

                showLoader('Loading data...', `${(jsonText.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                await new Promise(r => requestAnimationFrame(r));

                // Load in worker - UI stays responsive!
                await workerApi.loadJson(jsonText);

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                // Use cached data from worker
                samples = workerApi.sampleIds;
                pipelines = workerApi.pipelineIds;

                document.getElementById('header-info').textContent =
                    `${workerApi.refName} (${workerApi.refLength.toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer
                const timestamp = workerApi.generatedAt;
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                // Build UI progressively (loader hidden inside after core UI ready)
                await buildUIProgressively();

            } catch (error) {
                hideLoader();
                alert('Error loading demo: ' + error.message);
                console.error(error);
            }
        }
        // Load all positions on demand
        async function loadAllPositions() {
            const prompt = document.getElementById('load-positions-prompt');
            if (prompt) prompt.style.display = 'none';
            showLoader('Loading positions...', 'This may take a moment');
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            await loadPositions();
            hideLoader();
        }
        window.loadAllPositions = loadAllPositions;

        // Expose to global scope for onclick
        window.loadDemo = loadDemo;

        async function loadFile(file) {
            showLoader('Loading file...', `${(file.size / 1024 / 1024).toFixed(1)} MB`);
            await new Promise(r => requestAnimationFrame(r)); // Force repaint

            try {
                const isGzip = file.name.endsWith('.gz');
                const isBinary = isBinaryFormat(file.name);

                if (isBinary) {
                    // Binary (bincode) format - much faster to parse
                    showLoader('Decompressing...', '0 MB');
                    await new Promise(r => requestAnimationFrame(r));
                    const arrayBuffer = await file.arrayBuffer();

                    let binaryData;
                    if (isGzip) {
                        binaryData = await decompressGzipBinary(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                    } else {
                        binaryData = new Uint8Array(arrayBuffer);
                    }

                    showLoader('Loading data...', `${(binaryData.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                    await new Promise(r => requestAnimationFrame(r));

                    // Load in worker - UI stays responsive!
                    await workerApi.loadBinary(binaryData.buffer);
                } else {
                    // JSON format
                    let text;
                    if (isGzip) {
                        showLoader('Decompressing...', '0 MB');
                        await new Promise(r => requestAnimationFrame(r));
                        const arrayBuffer = await file.arrayBuffer();

                        text = await decompressGzipWithProgress(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                    } else {
                        showLoader('Reading file...', '');
                        text = await file.text();
                    }

                    showLoader('Loading data...', `${(text.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                    await new Promise(r => requestAnimationFrame(r));

                    // Load in worker - UI stays responsive!
                    await workerApi.loadJson(text);
                }

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                // Use cached data from worker
                samples = workerApi.sampleIds;
                pipelines = workerApi.pipelineIds;

                document.getElementById('header-info').textContent =
                    `${workerApi.refName} (${workerApi.refLength.toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer (format: dd/mm/yyyy hh:mi:ss)
                const timestamp = workerApi.generatedAt;
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                // Build UI progressively (loader hidden inside after core UI ready)
                await buildUIProgressively();

            } catch (err) {
                hideLoader();
                console.error('Failed to load report:', err);
                alert('Failed to load report: ' + err);
            }
        }

        function displayWarnings() {
            const warnings = workerApi.warnings || [];
            const container = document.getElementById('warnings');

            if (warnings.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            for (const warning of warnings) {
                // Skip MNP warnings - they're shown in the table with warning icon
                if (warning.includes('MNP')) {
                    continue;
                }
                html += `<div class="warning-item">${warning}</div>`;
            }
            container.innerHTML = html;
        }

        // Simple markdown renderer
        function renderMarkdown(text) {
            if (!text) return '';

            // Process line by line for better list handling
            const lines = text.split('\n');
            let html = '';
            let inList = false;
            let inParagraph = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                // Escape HTML
                line = line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // Check line type
                const isHeader = /^#{1,3} /.test(line);
                const isListItem = /^[-*] /.test(line) || /^\d+\. /.test(line);
                const isEmpty = line.trim() === '';

                // Close paragraph if needed
                if (inParagraph && (isHeader || isListItem || isEmpty)) {
                    html += '</p>';
                    inParagraph = false;
                }

                // Close list if needed
                if (inList && !isListItem) {
                    html += '</ul>';
                    inList = false;
                }

                if (isEmpty) {
                    continue;
                }

                // Headers
                if (/^### (.+)$/.test(line)) {
                    html += line.replace(/^### (.+)$/, '<h3>$1</h3>');
                } else if (/^## (.+)$/.test(line)) {
                    html += line.replace(/^## (.+)$/, '<h2>$1</h2>');
                } else if (/^# (.+)$/.test(line)) {
                    html += line.replace(/^# (.+)$/, '<h1>$1</h1>');
                }
                // List items
                else if (isListItem) {
                    if (!inList) {
                        html += '<ul>';
                        inList = true;
                    }
                    let content = line.replace(/^[-*] /, '').replace(/^\d+\. /, '');
                    // Apply inline formatting
                    content = content
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.+?)\*/g, '<em>$1</em>')
                        .replace(/_(.+?)_/g, '<em>$1</em>')
                        .replace(/`([^`]+)`/g, '<code>$1</code>');
                    html += '<li>' + content + '</li>';
                }
                // Regular text
                else {
                    if (!inParagraph) {
                        html += '<p>';
                        inParagraph = true;
                    } else {
                        html += ' ';
                    }
                    // Apply inline formatting
                    line = line
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.+?)\*/g, '<em>$1</em>')
                        .replace(/_(.+?)_/g, '<em>$1</em>')
                        .replace(/`([^`]+)`/g, '<code>$1</code>');
                    html += line;
                }
            }

            // Close any open tags
            if (inParagraph) html += '</p>';
            if (inList) html += '</ul>';

            return html;
        }

        function populateDescription() {
            const panel = document.getElementById('description-panel');
            const view = document.getElementById('description-view');

            const description = workerApi.description;

            if (description && description.trim()) {
                panel.style.display = 'block';
                view.innerHTML = renderMarkdown(description);
            } else {
                // Hide panel if no description
                panel.style.display = 'none';
            }
        }

        function populatePipelineInfo() {
            const pipelineIds = workerApi.pipelineIds;
            const container = document.getElementById('pipelines-info');

            let html = '';
            for (const pipelineId of pipelineIds) {
                const label = workerApi.getPipelineLabel(pipelineId);
                const command = workerApi.getPipelineCommand(pipelineId);
                const isGroundTruth = workerApi.isGroundTruth(pipelineId);
                const isFromBamPileup = workerApi.isFromBamPileup(pipelineId);

                html += `<div class="pipeline-info-item">`;
                html += `<div class="pipeline-name">${label}`;
                if (isGroundTruth) {
                    html += `<span class="pipeline-badge">Ground Truth</span>`;
                    if (isFromBamPileup) {
                        html += `<span class="pipeline-badge" style="background:#ff9800;" title="SNPs derived from BAM pileup, no variant calling filters applied">BAM pileup</span>`;
                    }
                }
                html += `</div>`;
                if (command) {
                    html += `<div class="pipeline-command">${command}</div>`;
                }
                if (isGroundTruth && isFromBamPileup) {
                    html += `<div style="color:#ff9800;font-size:10px;margin-top:4px;">⚠️ SNPs from BAM pileup - no variant calling performed</div>`;
                }
                html += `</div>`;
            }

            if (html === '') {
                html = '<p style="color:var(--text-secondary);font-size:11px;">No pipeline information available.</p>';
            }

            container.innerHTML = html;
        }

        function copyToClipboard(button, text) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = originalText, 1500);
            });
        }

        async function updateKPIs(filteredCount = null) {
            const kpis = await workerApi.getKpis();
            const refLength = workerApi.refLength;
            const gtPipelineId = workerApi.groundTruthPipeline;

            // Helper to sort pipeline entries with GT always first, then alphabetically
            const sortedPipelineEntries = (obj) => {
                return Object.entries(obj).sort(([a], [b]) => {
                    if (a === gtPipelineId) return -1;
                    if (b === gtPipelineId) return 1;
                    return a.localeCompare(b);
                });
            };

            // Helper to create info icon
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')">ⓘ</span>`;

            // Helper to create collapsible section
            const sectionStart = (title, open = false) => `<details class="kpi-section"${open ? ' open' : ''}><summary>${title}</summary><div class="kpi-section-content">`;
            const sectionEnd = () => `</div></details>`;

            let html = '';

            // === Overview (standalone) ===
            html += sectionStart('Overview', true);
            html += `
                <div class="kpi"><div class="label">Reference ${infoIcon('reference')}</div><div class="value">${refLength.toLocaleString()} bp</div></div>
                <div class="kpi"><div class="label">Samples ${infoIcon('samples')}</div><div class="value">${kpis.samples}</div></div>
                <div class="kpi"><div class="label">Pipelines ${infoIcon('pipelines')}</div><div class="value">${kpis.pipelines}</div></div>
            `;
            if (filteredCount !== null) {
                html += `<div class="kpi"><div class="label">Filtered Positions ${infoIcon('filtered')}</div><div class="value">${filteredCount.toLocaleString()}</div></div>`;
            }
            html += sectionEnd();

            // === GT Pipeline KPIs (Gap-Intersect, Gap-Union, Pairwise) ===
            const pipelineInfo = workerApi.cachedData.pipelineInfo || {};
            if (gtPipelineId) {
                const gtLabel = (pipelineInfo[gtPipelineId] && pipelineInfo[gtPipelineId].label) || gtPipelineId;
                html += sectionStart(`${gtLabel} <span style="color:#e6862a;font-weight:bold;">(GT)</span>`, true);
                html += `<div class="kpi-row">`;

                // Global stats
                const gs = await workerApi.getGlobalStatsForPipeline(gtPipelineId);
                if (gs) {
                    html += sectionStart('Gap-Intersect', true);
                    html += `<div class="kpi"><div class="label">Usable Space ${infoIcon('pp_gi_usable')}</div><div class="value">${gs.relaxed.usable_space.toLocaleString()} bp <span class="pct">(${gs.relaxed.usable_space_pct.toFixed(2)}%)</span></div></div>`;
                    html += `<button class="kpi-expand-btn" onclick="this.nextElementSibling.classList.toggle('expanded');this.textContent=this.textContent==='+'?'−':'+'">+</button>`;
                    html += `<div class="kpi-collapsible">`;
                    html += `<div class="kpi"><div class="label">Total SNPs ${infoIcon('pp_gi_total')}</div><div class="value">${gs.relaxed.total_snps.toLocaleString()}</div></div>`;
                    html += `<div class="kpi"><div class="label">Consensus SNPs ${infoIcon('pp_gi_consensus')}</div><div class="value">${gs.relaxed.consensus_snps.toLocaleString()}</div></div>`;
                    html += `</div>`;
                    html += `<div class="kpi"><div class="label">Discriminating SNPs ${infoIcon('pp_gi_disc')}</div><div class="value">${gs.relaxed.discriminating_snps.toLocaleString()}</div></div>`;
                    html += sectionEnd();

                    html += sectionStart('Gap-Union', true);
                    html += `<div class="kpi"><div class="label">Usable Space ${infoIcon('pp_gu_usable')}</div><div class="value">${gs.strict.usable_space.toLocaleString()} bp <span class="pct">(${gs.strict.usable_space_pct.toFixed(2)}%)</span></div></div>`;
                    html += `<button class="kpi-expand-btn" onclick="this.nextElementSibling.classList.toggle('expanded');this.textContent=this.textContent==='+'?'−':'+'">+</button>`;
                    html += `<div class="kpi-collapsible">`;
                    html += `<div class="kpi"><div class="label">Total SNPs ${infoIcon('pp_gu_total')}</div><div class="value">${gs.strict.total_snps.toLocaleString()}</div></div>`;
                    html += `<div class="kpi"><div class="label">Consensus SNPs ${infoIcon('pp_gu_consensus')}</div><div class="value">${gs.strict.consensus_snps.toLocaleString()}</div></div>`;
                    html += `</div>`;
                    html += `<div class="kpi"><div class="label">Discriminating SNPs ${infoIcon('pp_gu_disc')}</div><div class="value">${gs.strict.discriminating_snps.toLocaleString()}</div></div>`;
                    html += sectionEnd();
                }

                // Pairwise stats
                if (kpis.samples >= 2) {
                    const pw = await workerApi.getPairwiseUsableStatsForPipeline(gtPipelineId);
                    if (pw && pw.num_pairs > 0) {
                        html += sectionStart(`Pairwise (Gap-Union) <span style="font-weight:normal;font-size:10px;color:var(--text-muted);">(${pw.num_pairs} pairs)</span>`, true);
                        html += `<div class="kpi"><div class="label">Avg Usable Space ${infoIcon('pp_pw_usable')}</div><div class="value">${Math.round(pw.avg_usable_space).toLocaleString()} bp <span class="pct">(${pw.avg_usable_space_pct.toFixed(2)}%)</span></div></div>`;
                        html += `<div class="kpi"><div class="label">Discriminating SNPs ${infoIcon('pp_pw_disc')}</div><div class="value">avg ${pw.avg_usable_snps.toFixed(1)} &nbsp;|&nbsp; min ${pw.min_usable_snps.toLocaleString()} &nbsp;|&nbsp; med ${pw.median_usable_snps.toFixed(1)} &nbsp;|&nbsp; max ${pw.max_usable_snps.toLocaleString()}</div></div>`;
                        html += sectionEnd();
                    }
                }

                // Per-sample pairwise table
                if (kpis.samples >= 2) {
                    const pw2 = await workerApi.getPairwiseUsableStatsForPipeline(gtPipelineId);
                    if (pw2 && pw2.per_sample && pw2.per_sample.length > 0) {
                        html += sectionStart(`Per-Sample Pairwise ${infoIcon('pp_ps_table')}`, true);
                        html += `<table class="kpi-table"><thead><tr>
                            <th>Sample</th>
                            <th>Avg Usable Space (bp)</th>
                            <th>Avg Usable Space (%)</th>
                            <th>Avg Disc. SNPs</th>
                        </tr></thead><tbody>`;
                        for (const s of pw2.per_sample) {
                            html += `<tr>
                                <td>${s.sample_label}</td>
                                <td>${Math.round(s.avg_usable_space).toLocaleString()}</td>
                                <td>${s.avg_usable_space_pct.toFixed(2)}%</td>
                                <td>${s.avg_disc_snps.toFixed(2)}</td>
                            </tr>`;
                        }
                        html += `</tbody></table>`;
                        html += sectionEnd();
                    }
                }

                html += `</div>`; // close kpi-row
                html += sectionEnd(); // close GT pipeline section
            }

            // === GT Discriminating SNPs Lost by VCF Pipelines ===
            if (gtPipelineId && kpis.samples >= 2) {
                const gtDiscVsPl = await workerApi.getGtDiscVsPipelines();
                if (gtDiscVsPl && Object.keys(gtDiscVsPl).length > 0) {
                    html += sectionStart(`GT Discriminating SNPs vs Pipelines ${infoIcon('gt_disc_vs_pl')}`);
                    html += `<table class="kpi-table"><thead><tr>
                        <th rowspan="2">Pipeline</th>
                        <th rowspan="2">Core SNPs</th>
                        <th rowspan="2">Disc. SNPs</th>
                        <th colspan="3" style="text-align:center;">Gap-Intersect ${infoIcon('gt_disc_gi')}</th>
                        <th colspan="3" style="text-align:center;">Gap-Union ${infoIcon('gt_disc_gu')}</th>
                        <th colspan="2" style="text-align:center;">Pairwise ${infoIcon('gt_disc_pw')}</th>
                    </tr><tr>
                        <th>Same Pos</th><th>Concordant</th><th>In GT Gaps</th>
                        <th>Same Pos</th><th>Concordant</th><th>In GT Gaps</th>
                        <th>Same Pos (avg)</th><th>Concordant (avg)</th>
                    </tr></thead><tbody>`;
                    for (const [plId, stats] of Object.entries(gtDiscVsPl)) {
                        const plLabel = (pipelineInfo[plId] && pipelineInfo[plId].label) || plId;
                        const giHasConc = stats.gap_intersect_concordant != null;
                        const giConcPct = giHasConc && stats.gap_intersect_same_pos > 0 ? ((stats.gap_intersect_concordant / stats.gap_intersect_same_pos) * 100).toFixed(1) : '0.0';
                        const guHasConc = stats.gap_union_concordant != null;
                        const guConcPct = guHasConc && stats.gap_union_same_pos > 0 ? ((stats.gap_union_concordant / stats.gap_union_same_pos) * 100).toFixed(1) : '0.0';
                        const pwHasConc = stats.pairwise_concordant_avg != null;
                        const pwConcPct = pwHasConc && stats.pairwise_same_pos_avg > 0 ? ((stats.pairwise_concordant_avg / stats.pairwise_same_pos_avg) * 100).toFixed(1) : '0.0';
                        const fmtConc = (val, pct, hasConc) => hasConc ? `${val.toLocaleString()} <span class="pct">(${pct}%)</span>` : 'N/A';
                        const plCoreSnps = stats.pl_total_core_snps || 0;
                        const plDiscSnps = stats.pl_discriminating_core_snps;
                        html += `<tr>
                            <td>${plLabel}</td>
                            <td>${plCoreSnps > 0 ? plCoreSnps.toLocaleString() : 'N/A'}</td>
                            <td>${plDiscSnps != null ? plDiscSnps.toLocaleString() : 'N/A'}</td>
                            <td>${stats.gap_intersect_same_pos.toLocaleString()}</td>
                            <td>${fmtConc(stats.gap_intersect_concordant, giConcPct, giHasConc)}</td>
                            <td>${stats.gap_intersect_pl_snps_in_gt_gaps.toLocaleString()}</td>
                            <td>${stats.gap_union_same_pos.toLocaleString()}</td>
                            <td>${fmtConc(stats.gap_union_concordant, guConcPct, guHasConc)}</td>
                            <td>${stats.gap_union_pl_snps_in_gt_gaps.toLocaleString()}</td>
                            <td>${stats.pairwise_same_pos_avg.toFixed(1)}</td>
                            <td>${pwHasConc ? `${stats.pairwise_concordant_avg.toFixed(1)} <span class="pct">(${pwConcPct}%)</span>` : 'N/A'}</td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                    html += sectionEnd();
                }
            }

            document.getElementById('kpis').innerHTML = html;
        }

        function createFilterButtons(pipelines) {
            const container = document.getElementById('filters');
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')" style="margin-left:3px;">ⓘ</span>`;

            container.innerHTML = '<span style="color:#808080;margin-right:5px;">SNP Filters:</span>';

            // Get pipelines with VCF data (only these can have SNP filters)
            const vcfPipelines = workerApi.vcfPipelines;

            // Pipeline SNP filters - only for pipelines with VCF (with info icon inside)
            for (const p of pipelines) {
                if (!vcfPipelines.includes(p)) continue;
                const label = workerApi.getPipelineLabel(p);
                container.innerHTML += `<button class="filter-btn" data-filter="${p}" onclick="toggleFilter('${p}')">${label} ${infoIcon('filter_pipeline')}</button>`;
            }

            // Special SNP filters with info icons inside
            container.innerHTML += `
                <button class="filter-btn" data-filter="consensus" onclick="toggleFilter('consensus')">Consensus ${infoIcon('filter_consensus')}</button>
                <button class="filter-btn" data-filter="discordant" onclick="toggleFilter('discordant')">Discordant ${infoIcon('filter_discordant')}</button>
            `;

            // Gap filters - show all pipelines (with info icon inside)
            container.innerHTML += '<span style="color:#808080;margin-left:15px;margin-right:5px;">Gap Filters:</span>';
            for (const p of pipelines) {
                const label = workerApi.getPipelineLabel(p);
                container.innerHTML += `<button class="filter-btn gap-filter" data-filter="gaps:${p}" onclick="toggleFilter('gaps:${p}')">${label} Gaps ${infoIcon('filter_gaps')}</button>`;
            }
        }

        // Track hidden rows
        let hiddenRows = new Set();

        function createVisibilityControls(pipelines) {
            const container = document.getElementById('visibility-controls');
            let html = '';

            // Get ground truth pipeline (if any) - it's hidden from individual rows
            const groundTruthPipeline = workerApi.groundTruthPipeline;

            // Per-sample controls
            for (const sample of samples) {
                const sampleLabel = workerApi.getSampleLabel(sample);
                html += `<div class="vis-group">
                    <div class="vis-group-title">${sampleLabel}</div>
                    <div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-main" checked onchange="toggleRowVisibility('${sampleLabel}', this.checked)">
                        <label for="vis-${sample}-main">Sample</label>
                    </div>`;

                for (const p of pipelines) {
                    // Skip ground truth pipeline - it's not shown as a separate row
                    if (groundTruthPipeline && p === groundTruthPipeline) {
                        continue;
                    }
                    const pipelineLabel = workerApi.getPipelineLabel(p);
                    const rowId = `${sampleLabel}|${pipelineLabel}`;
                    html += `<div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-${p}" checked onchange="toggleRowVisibility('${rowId}', this.checked)">
                        <label for="vis-${sample}-${p}">${pipelineLabel}</label>
                    </div>`;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function toggleRowVisibility(rowLabel, visible) {
            if (visible) {
                hiddenRows.delete(rowLabel);
            } else {
                hiddenRows.add(rowLabel);
            }
            applyRowVisibility();
        }

        function setAllRowVisibility(visible) {
            // Get all visibility checkboxes
            const checkboxes = document.querySelectorAll('#visibility-controls input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const isVisible = document.getElementById('visibility-filter').value.toLowerCase();
                const label = cb.nextElementSibling?.textContent?.toLowerCase() || '';
                // Only affect visible (not filtered out) checkboxes
                if (!isVisible || label.includes(isVisible)) {
                    cb.checked = visible;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        }

        function filterVisibilityCheckboxes(filter) {
            const lowerFilter = filter.toLowerCase();
            document.querySelectorAll('#visibility-controls .vis-item').forEach(item => {
                const label = item.querySelector('label')?.textContent?.toLowerCase() || '';
                item.style.display = !filter || label.includes(lowerFilter) ? '' : 'none';
            });
            // Also filter group titles visibility (hide group if all items hidden)
            document.querySelectorAll('#visibility-controls .vis-group').forEach(group => {
                const visibleItems = group.querySelectorAll('.vis-item:not([style*="display: none"])');
                group.style.display = visibleItems.length > 0 ? '' : 'none';
            });
        }

        function applyRowVisibility() {
            document.querySelectorAll('.alignment-view .row').forEach(row => {
                const lbl = row.querySelector('.lbl');
                if (lbl) {
                    const labelText = lbl.textContent.trim();
                    // Check if this row should be hidden
                    let shouldHide = hiddenRows.has(labelText);

                    // Also check for pipeline rows (sub labels)
                    if (lbl.classList.contains('sub')) {
                        // Find parent sample by looking at previous non-sub row
                        let prevRow = row.previousElementSibling;
                        while (prevRow && prevRow.querySelector('.lbl.sub')) {
                            prevRow = prevRow.previousElementSibling;
                        }
                        if (prevRow) {
                            const parentLabel = prevRow.querySelector('.lbl')?.textContent.trim();
                            const combinedLabel = `${parentLabel}|${labelText}`;
                            shouldHide = hiddenRows.has(combinedLabel) || hiddenRows.has(labelText);
                        }
                    }

                    row.classList.toggle('hidden-row', shouldHide);
                }
            });
        }

        window.toggleRowVisibility = toggleRowVisibility;

        let showNucleotideLetters = true;

        function toggleNucleotideLetters(show) {
            showNucleotideLetters = show;
            document.querySelectorAll('.alignment-view .row .cell').forEach(cell => {
                if (show) {
                    cell.classList.remove('hide-letters');
                } else {
                    cell.classList.add('hide-letters');
                }
            });
        }
        window.toggleNucleotideLetters = toggleNucleotideLetters;

        function filterByQuality(allPositions) {
            // If no quality filters, return all positions
            if (qualityFilters.minQual === 0 && qualityFilters.minDepth === 0) {
                return allPositions;
            }

            // Quality filtering is disabled with worker architecture
            // Would require O(positions * samples * pipelines) worker calls
            console.warn('Quality filtering temporarily disabled with worker architecture');
            const statsEl = document.getElementById('quality-stats');
            if (statsEl) {
                statsEl.textContent = 'Quality filtering not available (worker mode)';
            }
            return allPositions;
        }

        async function toggleFilter(filter) {
            console.log('toggleFilter called with:', filter);
            const idx = activeFilters.indexOf(filter);
            if (idx >= 0) {
                activeFilters.splice(idx, 1);
                console.log('Filter removed:', filter);
            } else {
                activeFilters.push(filter);
                console.log('Filter added:', filter);
            }
            console.log('Active filters:', activeFilters);

            // Update button states with INLINE styles (no cache issues)
            document.querySelectorAll('.filter-btn').forEach(btn => {
                const f = btn.dataset.filter;
                const isActive = activeFilters.includes(f);
                btn.classList.toggle('active', isActive);

                // Force inline styles
                if (isActive) {
                    btn.style.background = '#0066ff';
                    btn.style.color = 'white';
                    btn.style.fontWeight = 'bold';
                    btn.style.boxShadow = '0 0 10px #0066ff';
                    if (!btn.textContent.startsWith('✓')) {
                        btn.textContent = '✓ ' + btn.textContent;
                    }
                    console.log('Button activated:', f);
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.fontWeight = '';
                    btn.style.boxShadow = '';
                    btn.textContent = btn.textContent.replace(/^✓ /, '');
                }
            });

            currentPage = 0;
            showLoader('Applying filters...', '');
            // Allow UI to update before heavy computation
            await new Promise(r => setTimeout(r, 10));
            await loadPositions();
            hideLoader();
        }

        async function loadPositions() {
            const filterStr = activeFilters.join(',');
            const filterMode = document.getElementById('filter-mode').value;
            const sampleMode = document.getElementById('sample-mode').value;

            // Log filter info
            const pipelineFilters = activeFilters.filter(f =>
                !f.startsWith('gaps:') && f !== 'consensus' && f !== 'discordant'
            );
            const vcfPipelines = workerApi.vcfPipelines;
            const hasConsensus = activeFilters.includes('consensus');
            const hasDiscordant = activeFilters.includes('discordant');

            if (hasConsensus || hasDiscordant) {
                const scopeInfo = pipelineFilters.length > 0
                    ? `Selected: [${pipelineFilters.join(', ')}]`
                    : `All VCF pipelines: [${vcfPipelines.join(', ')}]`;
                console.log(`🔍 ${hasConsensus ? 'Consensus' : 'Discordant'} scope: ${scopeInfo}`);
            }

            let allPositions = await workerApi.getFilteredPositions(
                samples,
                filterStr,
                filterMode,
                sampleMode
            );
            console.log(`📊 Filters: [${filterStr}] → ${allPositions.length} positions`);

            // Apply quality filters
            const beforeQualityFilter = allPositions.length;
            positions = filterByQuality(allPositions);

            const modeInfo = activeFilters.length > 1 ? ` [${filterMode.toUpperCase()}, ${sampleMode}]` : '';
            let qualInfo = '';
            if (qualityFilters.minQual > 0 || qualityFilters.minDepth > 0) {
                qualInfo = ` (${beforeQualityFilter - positions.length} filtered by quality)`;
            }
            document.getElementById('status').textContent = `${positions.length.toLocaleString()} positions match filters${modeInfo}${qualInfo}`;

            // Update KPIs with filtered count when filters are active
            const hasFilters = activeFilters.length > 0 || qualityFilters.minQual > 0 || qualityFilters.minDepth > 0;
            await updateKPIs(hasFilters ? positions.length : null);

            await renderPage();
        }

        async function onFilterConfigChange() {
            if (activeFilters.length > 0) {
                showLoader('Applying filters...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage = 0;
                await loadPositions();
                hideLoader();
            }
        }

        async function renderPage() {
            const offset = currentPage * getPageSize();
            const html = await workerApi.renderFiltered(
                samples,
                positions,
                offset,
                getPageSize()
            );

            document.getElementById('alignment').innerHTML = html;

            // Apply row visibility settings
            applyRowVisibility();

            // Update pagination
            const totalPages = Math.ceil(positions.length / getPageSize());
            document.getElementById('page-info').textContent =
                `Page ${currentPage + 1} of ${totalPages} (${positions.length.toLocaleString()} positions)`;

            document.getElementById('prev-btn').disabled = currentPage === 0;
            document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
        }

        async function nextPage() {
            const totalPages = Math.ceil(positions.length / getPageSize());
            if (currentPage < totalPages - 1) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage++;
                await renderPage();
                hideLoader();
            }
        }

        async function prevPage() {
            if (currentPage > 0) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage--;
                await renderPage();
                hideLoader();
            }
        }

        async function gotoPosition() {
            const pos = parseInt(document.getElementById('goto-pos').value);
            if (!pos || pos < 1) return;

            showLoader('Finding position...', `Position ${pos}`);
            await new Promise(r => setTimeout(r, 10));

            // Find the page containing this position
            const idx = positions.findIndex(p => p >= pos);
            if (idx >= 0) {
                currentPage = Math.floor(idx / getPageSize());
                await renderPage();
                hideLoader();
            } else {
                hideLoader();
                alert('Position not found in current filter');
            }
        }

        // Store pipeline distance matrices
        let pipelineDistanceMatrices = {};

        function populateMatrixPipelineSelector() {
            const select = document.getElementById('matrix-pipeline');
            if (!select) return;

            // Load pipeline distance matrices
            try {
                pipelineDistanceMatrices = workerApi.pipelineDistanceMatrices;
                console.log('Pipeline distance matrices:', pipelineDistanceMatrices);
            } catch (e) {
                pipelineDistanceMatrices = {};
            }

            select.innerHTML = '';
            for (const p of pipelines) {
                const label = workerApi.getPipelineLabel(p);
                select.innerHTML += `<option value="${p}">${label}</option>`;
            }

            // Initialize source selector for first pipeline
            onMatrixPipelineChange();
        }

        window.onMatrixPipelineChange = function() {
            showPipelineMatrix();
        }

        function showPipelineMatrix() {
            const pipelineSelect = document.getElementById('matrix-pipeline');
            const matrixResult = document.getElementById('matrix-result');
            if (!pipelineSelect || !matrixResult) return;

            const pipelineId = pipelineSelect.value;
            const pipelineLabel = workerApi.getPipelineLabel(pipelineId);
            const matrixData = pipelineDistanceMatrices[pipelineId];

            if (!matrixData) {
                matrixResult.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No pipeline distance matrix available.</p>';
                return;
            }

            const { samples: matrixSamples, matrix } = matrixData;

            // Get sample labels
            const labels = matrixSamples.map(s => workerApi.getSampleLabel(s));

            // Build table HTML
            let html = `<p style="color:var(--accent);font-size:11px;margin-bottom:8px;">
                <strong>Source:</strong> Pre-computed by ${pipelineLabel} pipeline
            </p>`;
            html += '<div class="table-wrapper"><table class="distance-matrix-table"><thead><tr><th></th>';
            for (const label of labels) {
                html += `<th>${label}</th>`;
            }
            html += '</tr></thead><tbody>';

            for (let i = 0; i < matrixSamples.length; i++) {
                html += `<tr><th>${labels[i]}</th>`;
                for (let j = 0; j < matrixSamples.length; j++) {
                    const dist = matrix[i][j];
                    let cellClass = 'diagonal';
                    if (i !== j) {
                        if (dist <= 5) cellClass = 'low-dist';
                        else if (dist <= 20) cellClass = 'medium-dist';
                        else cellClass = 'high-dist';
                    }
                    html += `<td class="${cellClass}">${dist}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table></div>';

            matrixResult.innerHTML = html;
        }

        async function drawGenomeOverview() {
            const canvas = document.getElementById('genome-canvas');
            const ctx = canvas.getContext('2d');
            const refLen = workerApi.refLength;

            // Get theme colors from CSS variables
            const styles = getComputedStyle(document.documentElement);
            const bgPrimary = styles.getPropertyValue('--bg-primary').trim() || '#1e1e1e';
            const bgSecondary = styles.getPropertyValue('--bg-secondary').trim() || '#252526';
            const bgTertiary = styles.getPropertyValue('--bg-tertiary').trim() || '#3c3c3c';
            const textSecondary = styles.getPropertyValue('--text-secondary').trim() || '#808080';

            // Calculate dimensions
            const trackHeight = 28;
            const trackSpacing = 10;
            const height = (pipelines.length + 1) * (trackHeight + trackSpacing);
            const width = canvas.parentElement.clientWidth - 8; // Full container width minus padding

            // Set canvas size properly (set dimensions before scaling)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Clear canvas
            ctx.fillStyle = bgPrimary;
            ctx.fillRect(0, 0, width, height);

            // Draw reference bar
            ctx.fillStyle = bgTertiary;
            ctx.fillRect(0, 0, width, trackHeight);

            // Draw pipeline tracks
            const kpis = await workerApi.getKpis();

            // SNP and Gap colors matching legend
            const snpColor = '#4ec9b0';  // Teal for SNPs
            const gapColor = 'rgba(244, 71, 71, 0.7)';  // Red for gaps

            for (let idx = 0; idx < pipelines.length; idx++) {
                const pipeline = pipelines[idx];
                const y = (idx + 1) * (trackHeight + trackSpacing);

                // Draw track background
                ctx.fillStyle = bgSecondary;
                ctx.fillRect(0, y, width, trackHeight);

                // Draw pipeline label
                ctx.fillStyle = textSecondary;
                ctx.font = '9px monospace';
                const label = workerApi.getPipelineLabel(pipeline);
                ctx.fillText(label.substring(0, 15), 5, y + trackHeight / 2 + 3);

                // Draw SNP density (simplified - using bins)
                const binCount = Math.min(width, 500);
                const binSize = refLen / binCount;
                const snpBins = new Uint32Array(binCount);
                const gapBins = new Uint32Array(binCount);

                // Collect data from all samples for this pipeline
                for (const sample of samples) {
                    // Get SNP positions for this sample/pipeline
                    const allPositions = await workerApi.getFilteredPositions(
                        [sample],
                        pipeline,
                        'and',
                        'any'
                    );
                    for (const pos of allPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            snpBins[bin]++;
                        }
                    }

                    // Get gap positions
                    const gapPositions = await workerApi.getFilteredPositions(
                        [sample],
                        `gaps:${pipeline}`,
                        'and',
                        'any'
                    );
                    for (const pos of gapPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            gapBins[bin]++;
                        }
                    }
                }

                // Find max for normalization
                const maxSnp = Math.max(...snpBins, 1);
                const maxGap = Math.max(...gapBins, 1);

                // Draw gaps (red, bottom half)
                ctx.fillStyle = gapColor;
                for (let i = 0; i < binCount; i++) {
                    if (gapBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (gapBins[i] / maxGap) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + trackHeight - h, width / binCount + 1, h);
                    }
                }

                // Draw SNPs (teal, top half)
                ctx.fillStyle = snpColor;
                for (let i = 0; i < binCount; i++) {
                    if (snpBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (snpBins[i] / maxSnp) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + 1, width / binCount + 1, h);
                    }
                }
            }

            // Draw genome ruler
            ctx.fillStyle = textSecondary;
            ctx.font = '9px monospace';
            const tickInterval = Math.pow(10, Math.floor(Math.log10(refLen)) - 1) * 5;
            for (let pos = 0; pos <= refLen; pos += tickInterval) {
                const x = (pos / refLen) * width;
                ctx.fillRect(x, 0, 1, 5);
                if (pos > 0 && pos < refLen) {
                    const label = (pos / 1000000).toFixed(1) + 'M';
                    ctx.fillText(label, x - 10, 12);
                }
            }

            // Update genome info
            document.getElementById('genome-info').textContent = `(${(refLen / 1000000).toFixed(2)} Mbp)`;

            // Click handler to navigate
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const pos = Math.floor((x / rect.width) * refLen) + 1;
                document.getElementById('goto-pos').value = pos;
                gotoPosition();
            };
        }

        main();
    </script>
</body>
</html>
