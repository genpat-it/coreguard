<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGuard SNP Comparison Viewer</title>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #3c3c3c;
            --text-primary: #d4d4d4;
            --text-secondary: #808080;
            --text-muted: #555;
            --border-color: #3c3c3c;
            --accent: #569cd6;
            --accent-hover: #1177bb;
            --btn-bg: #3c3c3c;
            --btn-border: #555;
            --label-color: #9cdcfe;
            --ref-color: #6a9955;
            --snp-consensus: #4ec9b0;
            --snp-consensus-bg: rgba(78, 201, 176, 0.2);
            --snp-uncertain: #dcdcaa;
            --snp-uncertain-bg: rgba(220, 220, 170, 0.2);
            --snp-discord: #f44747;
            --snp-discord-bg: rgba(244, 71, 71, 0.2);
            --snp-pipeline: #ce9178;
            --snp-pipeline-bg: rgba(206, 145, 120, 0.2);
            --snp-vcf: #569cd6;
            --snp-vcf-bg: rgba(86, 156, 214, 0.2);
            --snp-bam: #b5cea8;
            --snp-bam-bg: rgba(181, 206, 168, 0.2);
            --gap-color: #f44747;
            --gap-bg: rgba(244, 71, 71, 0.1);
        }
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #cccccc;
            --accent: #0066cc;
            --accent-hover: #0055aa;
            --btn-bg: #e8e8e8;
            --btn-border: #cccccc;
            --label-color: #0066cc;
            --ref-color: #228b22;
            --snp-consensus: #008080;
            --snp-consensus-bg: rgba(0, 128, 128, 0.15);
            --snp-uncertain: #b8860b;
            --snp-uncertain-bg: rgba(184, 134, 11, 0.15);
            --snp-discord: #cc0000;
            --snp-discord-bg: rgba(204, 0, 0, 0.15);
            --snp-pipeline: #8b4513;
            --snp-pipeline-bg: rgba(139, 69, 19, 0.15);
            --snp-vcf: #0066cc;
            --snp-vcf-bg: rgba(0, 102, 204, 0.15);
            --snp-bam: #228b22;
            --snp-bam-bg: rgba(34, 139, 34, 0.15);
            --gap-color: #cc0000;
            --gap-bg: rgba(204, 0, 0, 0.1);
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s, color 0.3s;
        }
        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
        }
        .header .info {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .theme-toggle {
            position: relative;
            width: 44px;
            height: 22px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.3s ease;
            padding: 0;
        }
        .theme-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: transform 0.3s ease, background 0.3s ease;
        }
        .theme-toggle.light::after {
            transform: translateX(22px);
            background: #ffc107;
        }
        .theme-toggle:hover {
            border-color: var(--accent-color);
        }
        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            margin: 40px;
            padding: 40px;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(86, 156, 214, 0.1);
        }
        .drop-zone h2 {
            color: var(--text-secondary);
            font-weight: normal;
            margin: 0 0 10px 0;
        }
        .loader-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        [data-theme="light"] .loader-overlay {
            background: rgba(255,255,255,0.9);
        }
        .loader-overlay.active {
            display: flex;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loader-text {
            margin-top: 20px;
            color: var(--text-primary);
            font-size: 14px;
        }
        .loader-progress {
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .drop-zone p {
            color: var(--text-muted);
            margin: 5px 0;
        }
        .drop-zone .or {
            margin: 20px 0;
            color: var(--text-muted);
        }
        .drop-zone button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .drop-zone button:hover {
            background: var(--accent-hover);
        }
        .hidden {
            display: none !important;
        }
        .main-content {
            padding: 5px 0;
            max-width: 100%;
            width: 100%;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .kpis {
            display: flex;
            gap: 15px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .kpi {
            background: var(--bg-secondary);
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .kpi-section-header {
            width: 100%;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-secondary);
            text-transform: uppercase;
            padding: 8px 0 4px 0;
            margin-top: 8px;
            border-top: 1px solid var(--border-color);
            letter-spacing: 0.5px;
        }
        .kpi-section-header:first-child {
            margin-top: 0;
            border-top: none;
        }
        .kpi-sub-label {
            width: 100%;
            font-size: 10px;
            color: var(--text-secondary);
            padding: 6px 0 2px 0;
            opacity: 0.7;
        }
        .kpi-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin: 8px 0;
        }
        .kpi-table th, .kpi-table td {
            padding: 6px 10px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }
        .kpi-table th {
            font-size: 10px;
            font-weight: normal;
            color: var(--text-secondary);
            text-transform: uppercase;
            background: var(--bg-secondary);
        }
        .kpi-table th:first-child, .kpi-table td:first-child {
            text-align: left;
        }
        .kpi-table td:first-child {
            font-weight: 500;
            color: var(--text-primary);
        }
        .kpi-table td {
            color: var(--snp-consensus);
        }
        .kpi-table tr:hover {
            background: var(--bg-secondary);
        }
        .kpi-table .pct {
            font-size: 10px;
            color: var(--text-secondary);
            margin-left: 4px;
        }
        .kpi-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .kpi-table .info-icon:hover {
            opacity: 1;
        }
        .kpi.kpi-gt {
            border-color: #7cb342;
        }
        .kpi .label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .kpi .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 12px;
            transition: opacity 0.2s;
        }
        .kpi .info-icon:hover {
            opacity: 1;
        }
        .kpi .value {
            font-size: 18px;
            color: var(--snp-consensus);
            font-weight: bold;
        }
        /* Info Modal */
        .info-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .info-modal.active {
            display: flex;
        }
        .info-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .info-modal-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .info-modal-content p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            font-size: 13px;
            line-height: 1.5;
        }
        .info-modal-content .formula {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        .info-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        .info-modal-close:hover {
            color: var(--text-primary);
        }
        /* Scroll to top button */
        .scroll-top-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 45px;
            height: 45px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: opacity 0.3s, transform 0.3s;
        }
        .scroll-top-btn:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }
        .scroll-top-btn.visible {
            display: flex;
        }
        /* Per-sample statistics table */
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 10px;
        }
        .stats-table th, .stats-table td {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            text-align: right;
        }
        .stats-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
        }
        .stats-table th:first-child, .stats-table td:first-child {
            text-align: left;
            font-weight: bold;
            color: var(--label-color);
        }
        .stats-table tr:hover {
            background: var(--bg-tertiary);
        }
        .stats-table .pipeline-header {
            background: var(--bg-secondary);
            color: var(--accent);
        }
        .stats-table .good { color: #81c784; }
        .stats-table .warning { color: #ffd54f; }
        .stats-table .bad { color: #e57373; }
        .stats-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .stats-table .info-icon:hover {
            opacity: 1;
        }
        .filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.02);
            border-color: var(--accent);
        }
        .filter-btn:active {
            transform: scale(0.98);
        }
        .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent-hover);
            color: white;
            box-shadow: 0 0 8px var(--accent), inset 0 0 4px rgba(255,255,255,0.3);
            font-weight: bold;
            transform: scale(1.05);
        }
        .filter-btn.active::before {
            content: "✓ ";
        }
        .filter-btn.gap-filter {
            color: var(--gap-color);
        }
        .filter-btn.gap-filter.active {
            background: #8b0000;
            border-color: var(--gap-color);
            color: white;
            box-shadow: 0 0 8px var(--gap-color);
            font-weight: bold;
            transform: scale(1.05);
        }
        .nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .nav-controls input {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 10px;
            border-radius: 4px;
            width: 100px;
            font-family: inherit;
        }
        .nav-controls button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .nav-controls button:hover {
            background: var(--bg-tertiary);
        }
        .alignment-view {
            font-size: 11px;
            line-height: 1.1;
            overflow-x: auto;
            white-space: pre;
            width: 100%;
        }
        .alignment-view .row {
            display: flex;
            width: 100%;
        }
        .alignment-view .row.hidden-row {
            display: none;
        }
        .alignment-view .hide-letters {
            color: transparent !important;
            font-size: 0 !important;
        }
        .alignment-view .lbl {
            display: inline-block;
            width: 70px;
            min-width: 70px;
            color: var(--label-color);
            flex-shrink: 0;
            text-align: right;
            padding-right: 3px;
            font-size: 9px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .alignment-view .ref,
        .alignment-view .sample {
            flex-grow: 1;
            letter-spacing: 0px;
        }
        .alignment-view .lbl.sub {
            color: var(--text-secondary);
            font-style: italic;
        }
        .alignment-view .ref {
            color: var(--ref-color);
        }
        .alignment-view .sample {
            color: var(--text-primary);
        }
        .alignment-view .gap {
            color: var(--gap-color);
            background: var(--gap-bg);
        }
        .alignment-view .dim {
            color: var(--text-muted);
        }
        .alignment-view .snp-consensus {
            color: var(--snp-consensus);
            background: var(--snp-consensus-bg);
            font-weight: bold;
        }
        .alignment-view .snp-uncertain {
            color: var(--snp-uncertain);
            background: var(--snp-uncertain-bg);
        }
        .alignment-view .snp-discord {
            color: var(--snp-discord);
            background: var(--snp-discord-bg);
            font-weight: bold;
        }
        .alignment-view .snp-pipeline {
            color: var(--snp-pipeline);
            background: var(--snp-pipeline-bg);
        }
        .alignment-view .snp-vcf {
            color: var(--snp-vcf);
            background: var(--snp-vcf-bg);
        }
        .alignment-view .snp-bam {
            color: var(--snp-bam);
            background: var(--snp-bam-bg);
        }
        .alignment-view .nuc {
            color: var(--text-primary);
        }
        .alignment-view .pos-num,
        .alignment-view .nuc,
        .alignment-view .gap,
        .alignment-view .dim,
        .alignment-view .snp-consensus,
        .alignment-view .snp-uncertain,
        .alignment-view .snp-discord,
        .alignment-view .snp-pipeline,
        .alignment-view .snp-vcf,
        .alignment-view .snp-bam {
            display: inline-block;
            width: 7px;
            text-align: center;
            font-size: 10px;
            position: relative;
        }
        .alignment-view [data-pos]:hover::after {
            content: attr(data-pos);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            border: 1px solid var(--border-color);
        }
        .alignment-view .pos-num {
            color: var(--text-secondary);
        }
        .block.compact .row {
            margin: 2px 0;
        }
        .collapsible-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            margin: 0 4px 10px 4px;
            font-size: 11px;
        }
        .collapsible-panel summary {
            cursor: pointer;
            color: var(--accent);
            user-select: none;
            font-weight: bold;
            padding: 4px 0;
        }
        .collapsible-panel summary:hover {
            color: var(--text-primary);
        }
        .collapsible-panel summary::marker {
            color: var(--text-secondary);
        }
        .collapsible-panel.nested {
            background: var(--bg-primary);
            margin: 0 0 10px 0;
            padding: 6px 10px;
        }
        .collapsible-panel.nested summary {
            font-size: 12px;
            color: var(--label-color);
        }
        #visibility-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }
        .vis-group {
            background: var(--bg-primary);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .vis-group-title {
            color: var(--label-color);
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 10px;
        }
        .vis-item {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 2px 0;
        }
        .vis-item input {
            cursor: pointer;
        }
        .vis-item label {
            cursor: pointer;
            color: var(--text-primary);
            font-size: 10px;
        }
        .filter-options {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-options select {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        .genome-overview-content {
            margin-top: 8px;
        }
        .genome-legend-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
            justify-content: flex-end;
        }
        .genome-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-primary);
            font-size: 10px;
        }
        .genome-legend-item span {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        #genome-canvas {
            width: 100%;
            display: block;
            cursor: crosshair;
        }
        .footer {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            color: var(--text-secondary);
        }
        .legend-content {
            display: flex;
            gap: 20px;
            padding: 8px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }
        .legend-item span.swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        .legend-item .swatch.consensus { background: var(--snp-consensus-bg); border: 1px solid var(--snp-consensus); }
        .legend-item .swatch.uncertain { background: var(--snp-uncertain-bg); border: 1px solid var(--snp-uncertain); }
        .legend-item .swatch.discord { background: var(--snp-discord-bg); border: 1px solid var(--snp-discord); }
        .legend-item .swatch.vcf { background: var(--snp-vcf-bg); border: 1px solid var(--snp-vcf); }
        .legend-item .swatch.bam { background: var(--snp-bam-bg); border: 1px solid var(--snp-bam); }
        .legend-item .swatch.gap { background: var(--gap-bg); border: 1px solid var(--gap-color); }
        .quality-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .quality-filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quality-filter-item label {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .quality-filter-item input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        .quality-filter-item input[type="number"] {
            width: 60px;
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 11px;
        }
        .quality-filter-item .value-display {
            min-width: 35px;
            color: var(--accent);
            font-size: 11px;
        }
        .warnings-container {
            margin-top: 10px;
        }
        .warning-item {
            background: rgba(220, 180, 50, 0.15);
            border: 1px solid #dcb432;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 6px;
            color: #dcb432;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .warning-item::before {
            content: "⚠";
            font-size: 14px;
        }
        .mnp-warning {
            cursor: pointer;
            margin-left: 4px;
            font-size: 12px;
        }
        .pipeline-info-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 8px;
        }
        .pipeline-info-item .pipeline-name {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .pipeline-info-item .pipeline-command {
            font-family: monospace;
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .pipeline-info-item .pipeline-badge {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            background: var(--accent-color);
            color: white;
        }
        .repro-section {
            margin-bottom: 15px;
        }
        .repro-section h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 12px;
        }
        .repro-cmd {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 6px;
        }
        .repro-cmd code {
            flex: 1;
            font-family: monospace;
            font-size: 10px;
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre;
            color: var(--text-secondary);
        }
        .repro-cmd button {
            padding: 4px 8px;
            font-size: 10px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .repro-cmd button:hover {
            opacity: 0.8;
        }
        .repro-note {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            font-style: italic;
        }
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }
        .pagination button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
        }
        .pagination button:hover {
            background: var(--bg-tertiary);
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 10px 0;
        }
        #file-input {
            display: none;
        }
        .distance-matrix-table {
            margin-top: 10px;
            font-size: 10px;
            border-collapse: collapse;
            max-width: 100%;
            overflow-x: auto;
            display: block;
        }
        .distance-matrix-table th,
        .distance-matrix-table td {
            padding: 4px 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            white-space: nowrap;
        }
        .distance-matrix-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
        }
        .distance-matrix-table td.diagonal {
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        .distance-matrix-table td.low-dist {
            background: rgba(78, 201, 176, 0.2);
            color: var(--snp-consensus);
        }
        .distance-matrix-table td.medium-dist {
            background: rgba(220, 220, 170, 0.2);
            color: var(--snp-uncertain);
        }
        .distance-matrix-table td.high-dist {
            background: rgba(244, 71, 71, 0.2);
            color: var(--snp-discord);
        }
        .distance-matrix-table td .comparable {
            font-size: 8px;
            color: var(--text-muted);
            display: block;
        }
    </style>
</head>
<body>
    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-text">Loading...</div>
        <div class="loader-progress" id="loader-progress"></div>
    </div>

    <!-- Scroll to top button -->
    <button class="scroll-top-btn" id="scroll-top-btn" onclick="scrollToTop()" title="Scroll to top">↑</button>

    <!-- Info Modal -->
    <div class="info-modal" id="info-modal" onclick="if(event.target===this)closeInfoModal()">
        <div class="info-modal-content">
            <button class="info-modal-close" onclick="closeInfoModal()">&times;</button>
            <h3 id="info-modal-title">KPI Info</h3>
            <div id="info-modal-body"></div>
        </div>
    </div>

    <div class="header">
        <h1>CoreGuard SNP Comparison Viewer</h1>
        <div class="header-right">
            <div class="info" id="header-info">Drop a report to begin (.json, .json.gz, .bin, .bin.gz)</div>
            <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark mode"></button>
        </div>
    </div>

    <div id="drop-zone" class="drop-zone">
        <div style="max-width: 700px; text-align: left;">
            <h2 style="text-align: center; margin-bottom: 1.5rem;">SNP Pipeline Comparison Viewer</h2>

            <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">1. Generate a report</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0;">Create a YAML config with your VCF/BAM files, then run:</p>
                    <code style="display: block; background: var(--bg-primary); padding: 8px 12px; border-radius: 4px; font-size: 11px; overflow-x: auto;">coreguard compare --config project.yaml -o report.bin.gz --binary --gzip</code>
                </div>
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">2. Upload and visualize</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0;">Drop your report file here or click to browse:</p>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button onclick="document.getElementById('file-input').click()" style="flex: 1;">Choose File</button>
                        <span style="font-size: 11px; color: var(--text-muted);">.json .json.gz .bin .bin.gz</span>
                    </div>
                </div>
            </div>

            <input type="file" id="file-input" accept=".json,.json.gz,.bin,.bin.gz,.gz" style="display: none;" />

            <div style="text-align: center; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <p style="font-size: 12px; color: var(--text-secondary); margin: 0 0 0.75rem 0;">Or try the demo dataset:</p>
                <button onclick="loadDemo()" style="background: #455a64; font-size: 13px; padding: 10px 20px;">Load Demo</button>
                <p style="font-size: 11px; opacity: 0.7; margin-top: 8px;">4 <i>Listeria monocytogenes</i> samples &bull; Snippy vs CFSAN vs Ground Truth (minimap2)</p>
            </div>
        </div>

        <div style="margin-top: 1.5rem; opacity: 0.6;">
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none;" title="View on GitHub">
                <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <div id="viewer" class="main-content hidden">
        <details class="collapsible-panel" id="pipelines-panel" open>
            <summary>Pipelines</summary>
            <div id="pipelines-info">
                <p style="color:var(--text-secondary);font-size:11px;">Pipeline information will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Statistics</summary>
            <div class="kpis" id="kpis"></div>
            <div class="warnings-container" id="warnings"></div>
        </details>

        <details class="collapsible-panel" id="per-sample-panel" open>
            <summary>Per-Sample Statistics</summary>
            <div id="per-sample-stats" style="overflow-x:auto;">
                <p style="color:var(--text-secondary);font-size:11px;">Per-sample statistics will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" id="coverage-panel">
            <summary>Coverage Statistics</summary>
            <div id="coverage-stats-content">
                <p style="color:var(--text-secondary);font-size:11px;">Coverage statistics will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" id="reproducibility-panel">
            <summary>Reproducibility Commands</summary>
            <div id="reproducibility-content">
                <p style="color:var(--text-secondary);font-size:11px;">Verification commands will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel">
            <summary>Quality Filters</summary>
            <div class="quality-filters">
                <div class="quality-filter-item">
                    <label for="min-qual">Min QUAL:</label>
                    <input type="number" id="min-qual" min="0" max="10000" value="0" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <label for="min-depth">Min Depth:</label>
                    <input type="number" id="min-depth" min="0" max="1000" value="0" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <label for="min-consensus">Min Consensus %:</label>
                    <input type="number" id="min-consensus" min="50" max="100" value="50" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <button onclick="resetQualityFilters()">Reset</button>
                </div>
            </div>
            <p style="margin:8px 0 0 0;color:var(--text-secondary);font-size:10px;">
                <strong>Distance Matrix:</strong> Filters apply per-position. Min Depth filters all sources with depth data. Min QUAL filters VCF sources only. Min Consensus filters BAM sources only.<br>
                <strong>Note:</strong> QUAL works for Snippy (CFSAN uses "."). Depth/consensus available for BAM sources.
            </p>
            <div class="quality-stats" id="quality-stats" style="margin-top:8px;color:var(--text-secondary);font-size:10px;"></div>
        </details>

        <details class="collapsible-panel" id="distance-matrix-panel">
            <summary>SNP Distance Matrix <span id="matrix-info"></span></summary>
            <div class="distance-matrix-content" id="distance-matrix-content">
                <div style="display:flex;align-items:center;gap:15px;margin:10px 0;">
                    <label style="color:var(--text-secondary);font-size:11px;">Pipeline:
                        <select id="matrix-pipeline" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                        </select>
                    </label>
                    <label style="color:var(--text-secondary);font-size:11px;">Mode:
                        <select id="matrix-mode" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                            <option value="vcf_ref">VCF + Reference</option>
                            <option value="vcf_bam">VCF + BAM pileup</option>
                            <option value="bam_only">BAM only</option>
                        </select>
                    </label>
                </div>
                <div style="display:flex;align-items:center;gap:15px;margin:10px 0;flex-wrap:wrap;">
                    <button onclick="calculateDistanceMatrix()" style="padding:8px 16px;background:var(--accent);color:white;border:none;border-radius:4px;cursor:pointer;">Calculate</button>
                    <span style="color:var(--text-secondary);font-size:11px;">(Uses global quality filters above)</span>
                </div>
                <p style="color:var(--text-secondary);font-size:11px;margin:5px 0;">
                    <strong>VCF + Reference:</strong> Uses VCF calls where available, reference allele otherwise (matches Snippy-core).<br>
                    <strong>VCF + BAM:</strong> Uses VCF calls where available, BAM pileup otherwise.<br>
                    <strong>BAM only:</strong> Uses only BAM pileup bases, ignoring VCF calls (most accurate for real differences).
                </p>
                <div id="matrix-result"></div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Genome Overview <span id="genome-info"></span></summary>
            <div class="genome-overview-content">
                <div class="genome-legend-bar">
                    <span class="genome-legend-item"><span style="background:#4ec9b0;"></span> SNPs (top)</span>
                    <span class="genome-legend-item"><span style="background:rgba(244, 71, 71, 0.7);"></span> Gaps (bottom)</span>
                </div>
                <canvas id="genome-canvas" height="100"></canvas>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>View Settings</summary>

            <details class="collapsible-panel nested" open>
                <summary>Row Visibility</summary>
                <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;margin-top:8px;">
                    <input type="text" id="visibility-filter" placeholder="Filter rows..." style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;width:150px;" oninput="filterVisibilityCheckboxes(this.value)">
                    <button onclick="setAllRowVisibility(true)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Select All</button>
                    <button onclick="setAllRowVisibility(false)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Deselect All</button>
                </div>
                <div id="visibility-controls"></div>
            </details>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;margin-bottom:15px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Nucleotide Display</strong>
                <div style="display:flex;gap:15px;flex-wrap:wrap;">
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-nucleotide-letters" checked onchange="toggleNucleotideLetters(this.checked)">
                        Show base letters (A, C, G, T)
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-ref-row" checked onchange="toggleRowVisibility('REF', this.checked)">
                        Show reference row
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-pos-row" checked onchange="toggleRowVisibility('Pos', this.checked)">
                        Show position row
                    </label>
                </div>
            </div>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Legend</strong>
                <div class="legend-content">
                    <div class="legend-item"><span class="swatch consensus"></span> Consensus (all pipelines agree)</div>
                    <div class="legend-item"><span class="swatch uncertain"></span> Uncertain (only one pipeline)</div>
                    <div class="legend-item"><span class="swatch discord"></span> Discordant (pipelines disagree)</div>
                    <div class="legend-item"><span class="swatch vcf"></span> VCF call (from variant caller)</div>
                    <div class="legend-item"><span class="swatch bam"></span> BAM pileup (from reads)</div>
                    <div class="legend-item"><span class="swatch gap"></span> Gap (no coverage)</div>
                </div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Filters & Navigation</summary>
            <div class="controls">
                <div class="filters" id="filters">
                    <span style="color:#808080;margin-right:5px;">Filters:</span>
                </div>
                <div class="filter-options">
                    <label title="How to combine multiple filters">
                        <select id="filter-mode" onchange="onFilterConfigChange()">
                            <option value="and">AND (all filters)</option>
                            <option value="or">OR (any filter)</option>
                        </select>
                    </label>
                    <label title="How to match across samples">
                        <select id="sample-mode" onchange="onFilterConfigChange()">
                            <option value="any">Any sample</option>
                            <option value="all">All samples</option>
                        </select>
                    </label>
                </div>
                <div class="nav-controls">
                    <span style="color:#808080;">Go to:</span>
                    <input type="number" id="goto-pos" placeholder="Position" min="1" />
                    <button onclick="gotoPosition()">Go</button>
                </div>
            </div>
            <details class="collapsible-panel nested" style="margin-top:10px;">
                <summary>Filter Legend</summary>
                <div class="filter-legend" style="font-size:11px;color:var(--text-secondary);line-height:1.6;">
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">SNP Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline Name]</strong>: Show positions where this pipeline called a SNP (variant different from reference)
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Consensus</strong>: Show positions where <em>all selected VCF pipelines called a SNP</em> and they all agree<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: Select pipeline buttons first to compare only those (e.g., Snippy + CFSAN)</span>
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <strong>Discordant</strong>: Show positions where <em>selected pipelines called different SNPs</em> (they disagree)<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: If no pipelines selected, uses all VCF pipelines</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Gap Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline] Gaps</strong>: Show positions where this pipeline has no read coverage (gap)
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <span style="color:var(--text-muted);font-size:10px;">If a pipeline is marked as "ground truth", its gaps indicate positions where the baseline has no data</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Combination Logic</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>AND</strong>: Position must match <em>all</em> selected filters
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>OR</strong>: Position must match <em>any</em> selected filter
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Any sample</strong>: Filter matches if at least one sample meets the condition
                    </div>
                    <div style="margin-left:10px;">
                        <strong>All samples</strong>: Filter matches only if all samples meet the condition
                    </div>
                </div>
            </details>
        </details>

        <div class="status" id="status"></div>
        <div class="alignment-view" id="alignment"></div>

        <div class="pagination" id="pagination">
            <button id="prev-btn" onclick="prevPage()" disabled>&larr; Previous</button>
            <span id="page-info">Page 1</span>
            <button id="next-btn" onclick="nextPage()">Next &rarr;</button>
        </div>

        <div class="footer" id="footer">
            <span>CoreGuard SNP Comparison Viewer</span>
            <span id="report-timestamp"></span>
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none; margin-left: 1rem;" title="View on GitHub">
                <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <!-- Pako for gzip decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <script>
        // Theme toggling (non-module, runs immediately)
        function initTheme() {
            const savedTheme = localStorage.getItem('coreguard-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : '');
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('coreguard-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('coreguard-theme', newTheme);
            document.documentElement.setAttribute('data-theme', newTheme === 'light' ? 'light' : '');
            updateThemeIcon(newTheme);
            // Redraw canvas with new theme colors
            if (typeof redrawGenomeOverview === 'function') {
                redrawGenomeOverview();
            }
        }

        function updateThemeIcon(theme) {
            const btn = document.getElementById('theme-toggle');
            if (btn) {
                btn.classList.toggle('light', theme === 'light');
                btn.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
            }
        }

        // Initialize theme on page load
        initTheme();

        // KPI Info Modal
        const kpiDescriptions = {
            'reference': {
                title: 'Reference Genome',
                body: `<p>The length of the reference genome in base pairs (bp).</p>
                       <p>All samples are aligned against this reference sequence for SNP calling.</p>`
            },
            'samples': {
                title: 'Number of Samples',
                body: `<p>Total number of samples (isolates) included in this comparison.</p>`
            },
            'pipelines': {
                title: 'Number of Pipelines',
                body: `<p>Number of different SNP calling pipelines being compared.</p>
                       <p>Each pipeline may use different algorithms, parameters, or reference-based variant calling approaches.</p>`
            },
            'snps': {
                title: 'SNP Count',
                body: `<p>Total number of Single Nucleotide Polymorphisms (SNPs) detected by this pipeline across all samples.</p>
                       <div class="formula">% = (SNPs / Reference Length / Samples) × 100</div>
                       <p>The percentage indicates the average SNP density per sample relative to the reference genome.</p>`
            },
            'gaps': {
                title: 'Gap Regions',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) across all samples.</p>
                       <div class="formula">% = (Gap bp / Reference Length / Samples) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants due to low read coverage.</p>
                       <p><strong>High gap percentage</strong> may indicate poor sequencing quality or divergent samples.</p>`
            },
            'snps_in_gt_gaps': {
                title: 'Any SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>at least 1 sample</strong> has a SNP.</p>
                       <div class="formula">% = (Any SNPs in GT Gaps / Any SNPs) × 100</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (&lt;1%)</span>: Good - few SNPs in unreliable regions</li>
                           <li><span style="color:#e57373;">Red (&gt;1%)</span>: Potential false positives in low-coverage regions</li>
                       </ul>`
            },
            'all_snps_in_gt_gaps': {
                title: 'All SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples</strong> have a SNP.</p>
                       <div class="formula">% = (All SNPs in GT Gaps / All SNPs) × 100</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based, any allele)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>These are consistently called SNPs in unreliable regions</li>
                           <li>May indicate systematic differences between pipelines</li>
                       </ul>`
            },
            'consensus_snps_in_gt_gaps': {
                title: 'Consensus SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples have the SAME allele</strong>.</p>
                       <div class="formula">% = (Consensus SNPs in GT Gaps / Consensus SNPs) × 100</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Most reliable variant calls in unreliable regions</li>
                           <li>Consensus SNPs in GT gaps warrant closer inspection</li>
                       </ul>`
            },
            'snps_in_pipeline_gaps': {
                title: 'SNPs in Pipeline Gaps',
                body: `<p>SNPs from one pipeline that fall within gap regions of another pipeline.</p>
                       <div class="formula">% = (SNPs in Gaps / Total SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows SNPs called by one pipeline in regions where another has low coverage</li>
                           <li>High values may indicate false positives or differences in coverage</li>
                           <li>Useful for comparing pipeline reliability across different regions</li>
                       </ul>`
            },
            // Per-Sample Statistics metrics
            'ps_snps': {
                title: 'Per-Sample SNPs',
                body: `<p>Number of SNPs called by this pipeline for this sample.</p>
                       <div class="formula">% = (SNPs / Reference Length) × 100</div>
                       <p>Percentage shows SNP density relative to the reference genome size.</p>`
            },
            'ps_gaps': {
                title: 'Per-Sample Gaps',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) for this sample.</p>
                       <div class="formula">% = (Gap bp / Reference Length) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants.</p>`
            },
            'ps_vs_gt': {
                title: 'vs GT (Agreement)',
                body: `<p>Pipeline SNPs that are at the same positions as GT SNPs for this sample.</p>
                       <div class="formula">% = (Pipeline ∩ GT SNP positions / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≥90%</span>: Good agreement with ground truth</li>
                           <li><span style="color:#ffc107;">70-90%</span>: Moderate agreement</li>
                           <li><span style="color:#e57373;">&lt;70%</span>: Poor agreement</li>
                       </ul>`
            },
            'ps_in_gt_gaps': {
                title: 'in GT Gaps',
                body: `<p>Pipeline SNPs that fall within GT gap regions (low coverage in GT).</p>
                       <div class="formula">% = (SNPs in GT Gaps / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≤1%</span>: Good - few SNPs in unreliable GT regions</li>
                           <li><span style="color:#ffc107;">1-5%</span>: Some SNPs in GT gaps</li>
                           <li><span style="color:#e57373;">&gt;5%</span>: Many SNPs in GT gaps - potential false positives</li>
                       </ul>`
            },
            'ps_intersection': {
                title: 'Pipeline ∩ GT Intersection',
                body: `<p>SNP positions where both the pipeline and GT have called a SNP for this sample.</p>
                       <div class="formula">Intersection = |Pipeline SNP positions ∩ GT SNP positions|</div>
                       <div class="formula">% = (Intersection / GT SNPs) × 100</div>
                       <p>Shows what percentage of GT SNPs are also called by the pipeline.</p>`
            },
            'ps_vcf_consensus': {
                title: 'VCF Consensus SNPs',
                body: `<p>SNP positions where ALL VCF pipelines (excluding GT) agree for this sample.</p>
                       <div class="formula">VCF Consensus = ∩ all VCF pipelines</div>
                       <div class="formula">% = (VCF Consensus / Reference Length) × 100</div>
                       <p>These are the most confident variant calls where all VCF-based pipelines agree.</p>`
            },
            'ps_consensus_in_gt': {
                title: 'VCF Consensus in GT',
                body: `<p>VCF consensus SNPs that are also present in GT for this sample.</p>
                       <div class="formula">% = (VCF Consensus ∩ GT / VCF Consensus) × 100</div>
                       <p>High percentage means VCF consensus aligns well with ground truth.</p>`
            },
            'ps_all_consensus': {
                title: 'All Consensus (GT ∩ VCF)',
                body: `<p>Positions where ALL pipelines (including GT) agree for this sample.</p>
                       <div class="formula">All Consensus = GT ∩ VCF Consensus</div>
                       <div class="formula">% = (All Consensus / Reference Length) × 100</div>
                       <p>These are the highest confidence calls - all pipelines agree.</p>`
            },
            'gt_snps_missing': {
                title: 'Any GT SNPs Filtered',
                body: `<p>GT SNP positions (≥1 sample) that this pipeline does <strong>NOT</strong> call.</p>
                       <div class="formula">Σ(GT<sub>sample</sub> - (GT<sub>sample</sub> ∩ Pipeline<sub>sample</sub>))</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows GT SNPs being "filtered out" by each pipeline</li>
                           <li>Higher values = more aggressive filtering</li>
                       </ul>`
            },
            'all_gt_missing': {
                title: 'All GT SNPs Filtered',
                body: `<p>GT SNP positions (ALL samples) not present in the pipeline.</p>
                       <div class="formula">|All GT| - |All GT ∩ All Pipeline|</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows consistent GT SNPs missing from pipeline</li>
                           <li>Lower = pipeline captures consistent GT signal</li>
                       </ul>`
            },
            'consensus_gt_missing': {
                title: 'Consensus GT SNPs Filtered',
                body: `<p>GT Consensus positions not present in the pipeline's consensus.</p>
                       <div class="formula">|Consensus GT| - |Consensus GT ∩ Consensus Pipeline|</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows highly reliable GT SNPs missing from pipeline's consensus</li>
                           <li>Lower = pipeline captures consistent variant calls</li>
                       </ul>`
            },
            'gt_pileup': {
                title: 'Ground Truth Pileup SNPs',
                body: `<p>Total SNPs detected directly from BAM pileup analysis <strong>without variant calling filters</strong>.</p>
                       <div class="formula">% = (Pileup SNPs / Reference Length / Samples) × 100</div>
                       <p>This is a raw count of positions where the consensus base from read alignments differs from the reference.</p>
                       <p><strong>Purpose:</strong> Provides a baseline for comparing how many potential variants each pipeline reports vs. the raw signal in the data.</p>`
            },
            'bam_pileup': {
                title: 'BAM Pileup Warning',
                body: `<p>⚠️ <strong>These SNPs were derived from BAM pileup analysis</strong>, not from a variant calling pipeline.</p>
                       <p><strong>What this means:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>No variant calling filters were applied (QUAL, depth, etc.)</li>
                           <li>SNPs are raw differences between reads and reference</li>
                           <li>May include sequencing errors and low-confidence calls</li>
                           <li>Counts are typically higher than filtered VCF pipelines</li>
                       </ul>
                       <p><strong>Use case:</strong> Ground truth baseline for comparing pipeline filtering behavior.</p>`
            },
            'vs_gt': {
                title: 'Pipeline vs Ground Truth',
                body: `<p>Comparison of this pipeline's SNP count against the Ground Truth pileup count.</p>
                       <div class="formula">Difference = Pipeline SNPs - GT Pileup SNPs</div>
                       <div class="formula">% = (Difference / GT Pileup SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (±5%)</span>: Close to raw signal</li>
                           <li><span style="color:#ffd54f;">Yellow (5-10%)</span>: Moderate filtering/differences</li>
                           <li><span style="color:#e57373;">Red (&gt;10%)</span>: Significant deviation - heavy filtering or artifacts</li>
                       </ul>
                       <p><strong>Negative values:</strong> Pipeline reports fewer SNPs than raw pileup (filtering)</p>
                       <p><strong>Positive values:</strong> Pipeline reports more SNPs (possible artifacts or MNP decomposition)</p>`
            },
            'filtered': {
                title: 'Filtered Positions',
                body: `<p>Number of genomic positions matching the currently active filter criteria.</p>
                       <p>Use filters to focus on specific types of variants (consensus, discordant, pipeline-specific, etc.)</p>`
            },
            'intersection': {
                title: 'SNP Intersection with Ground Truth',
                body: `<p>Number of SNP positions that are <strong>shared</strong> between this pipeline and the Ground Truth.</p>
                       <div class="formula">Intersection = positions where BOTH pipelines call a SNP</div>
                       <p>The two percentages show:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>% GT:</strong> What fraction of GT SNPs are also found by this pipeline (sensitivity/recall)</li>
                           <li><strong>% Pipeline:</strong> What fraction of this pipeline's SNPs are confirmed by GT (precision)</li>
                       </ul>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (≥90%)</span>: High agreement with ground truth</li>
                           <li><span style="color:#ffd54f;">Yellow (70-90%)</span>: Moderate agreement</li>
                           <li><span style="color:#e57373;">Red (&lt;70%)</span>: Low agreement - investigate differences</li>
                       </ul>`
            },
            'concordance': {
                title: 'Position Concordance',
                body: `<p><strong>Concordance</strong> = SNP positions called by BOTH pipelines (regardless of allele).</p>
                       <div class="formula">Concordance = positions where Pipeline A AND Pipeline B call a SNP</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has SNP in both pipelines at this position</li>
                           <li><strong>All:</strong> ALL samples have SNP in both pipelines (Core_A ∩ Core_B)</li>
                       </ul>
                       <p><strong>Note:</strong> Concordance only checks if a SNP exists - it does NOT compare the actual allele called.</p>`
            },
            'consensus': {
                title: 'Allele Consensus',
                body: `<p><strong>Consensus</strong> = SNP positions where BOTH pipelines call the SAME allele.</p>
                       <div class="formula">Consensus = positions where Pipeline A alt == Pipeline B alt</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has the same allele in both pipelines</li>
                           <li><strong>All:</strong> ALL samples have the same allele in both pipelines</li>
                       </ul>
                       <p><strong>Note:</strong> Consensus ≤ Concordance (consensus is a subset where alleles match).</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consensus ≈ Concordance: pipelines agree on alleles</li>
                           <li>Consensus &lt;&lt; Concordance: pipelines find same positions but call different alleles</li>
                       </ul>`
            },
            'consensus_vs_gt': {
                title: 'VCF Consensus vs Ground Truth',
                body: `<p><strong>VCF Consensus</strong> = SNP positions where <strong>ALL VCF pipelines agree</strong> (e.g., CFSAN ∩ Snippy).</p>
                       <p>This metric compares VCF consensus positions with Ground Truth:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Consensus in GT:</strong> How many VCF consensus SNPs are also in GT (precision)</li>
                           <li><strong>GT in Consensus:</strong> How many GT SNPs are in the VCF consensus (sensitivity)</li>
                       </ul>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">High % (≥90%)</span>: VCF consensus is well-supported by GT</li>
                           <li><span style="color:#ffd54f;">Moderate % (70-90%)</span>: Some disagreement</li>
                           <li><span style="color:#e57373;">Low % (&lt;70%)</span>: Significant discrepancy</li>
                       </ul>
                       <p><strong>Note:</strong> This does NOT include GT in the consensus calculation - it's VCF pipelines only, then compared to GT.</p>`
            },
            'all_consensus': {
                title: 'All Pipelines Consensus',
                body: `<p><strong>All Consensus</strong> = SNP positions where <strong>ALL pipelines INCLUDING Ground Truth</strong> agree.</p>
                       <div class="formula">All Consensus = GT ∩ Pipeline1 ∩ Pipeline2 ∩ ...</div>
                       <p>These are the "high confidence" SNPs - positions where every pipeline, including the ground truth, calls a variant.</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Higher count = more agreement across all methods</li>
                           <li>These SNPs are the most reliable for downstream analysis</li>
                           <li>Can be used as a "gold standard" SNP set</li>
                       </ul>
                       <p><strong>% of Reference:</strong> Indicates the SNP density for the consensus set.</p>`
            },
            'mnp': {
                title: 'MNP Decomposition',
                body: `<p><strong>MNP (Multi-Nucleotide Polymorphism)</strong> = multiple adjacent SNPs reported as a single variant in VCF.</p>
                       <p><strong>Example:</strong></p>
                       <div class="formula">VCF: pos=100, REF=ACG, ALT=TGA</div>
                       <p>This MNP is decomposed into 3 individual SNPs:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>pos=100: A→T</li>
                           <li>pos=101: C→G</li>
                           <li>pos=102: G→A</li>
                       </ul>
                       <p><strong>Why decompose?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consistent position-level comparison between pipelines</li>
                           <li>Some pipelines report MNPs, others report individual SNPs</li>
                           <li>Enables accurate intersection and agreement calculations</li>
                       </ul>
                       <p><strong>Note:</strong> The total SNP count increases after decomposition, which is expected.</p>`
            },
            'mnps': {
                title: 'MNP Statistics',
                body: `<p><strong>MNPs Detected</strong> = Number of Multi-Nucleotide Polymorphisms found and decomposed into individual SNPs.</p>
                       <div class="formula">Format: X → Y SNPs</div>
                       <p>Where X = number of MNPs found, Y = total individual SNPs they produced.</p>
                       <p><strong>Example:</strong> "50 → 127 SNPs" means 50 MNPs were decomposed into 127 individual SNPs.</p>
                       <p><strong>Why track this?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows pipeline-specific MNP handling</li>
                           <li>Higher MNP count may indicate different variant calling approach</li>
                           <li>Helps understand differences between pipelines</li>
                       </ul>`
            },
            'vcf_consensus': {
                title: 'VCF Pipelines Consensus',
                body: `<p><strong>VCF Consensus</strong> = SNP positions where <strong>ALL VCF pipelines</strong> (excluding Ground Truth) agree.</p>
                       <div class="formula">VCF Consensus = Pipeline1 ∩ Pipeline2 ∩ ...</div>
                       <p>This represents the intersection of all VCF-based pipelines, not including the ground truth BAM-based SNPs.</p>
                       <p><strong>Use:</strong> Identifies positions where different variant callers independently found the same SNP.</p>`
            },
            'filtered': {
                title: 'Filtered Positions',
                body: `<p>Number of positions matching the currently active filters.</p>
                       <p>Use the filter buttons to narrow down positions by:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Pipeline filters:</strong> Show only SNPs from specific pipelines</li>
                           <li><strong>Consensus:</strong> Show positions where selected pipelines agree</li>
                           <li><strong>Discordant:</strong> Show positions where pipelines disagree</li>
                           <li><strong>Gap filters:</strong> Show gap regions for specific pipelines</li>
                       </ul>`
            },
            'filter_pipeline': {
                title: 'Pipeline SNP Filter',
                body: `<p>Show only positions where this pipeline called a SNP.</p>
                       <p><strong>Multiple pipelines selected:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>OR mode:</strong> Position has SNP in ANY selected pipeline</li>
                           <li><strong>AND mode:</strong> Position has SNP in ALL selected pipelines</li>
                       </ul>
                       <p>Use the mode selector to switch between OR/AND logic.</p>`
            },
            'filter_consensus': {
                title: 'Consensus Filter',
                body: `<p>Show positions where <strong>ALL selected pipelines agree</strong> on having a SNP.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Example:</strong> With CFSAN and Snippy selected, shows positions where both call a SNP at the same position.</p>
                       <p><strong>Note:</strong> This is the intersection of selected pipelines' SNP positions.</p>`
            },
            'filter_discordant': {
                title: 'Discordant Filter',
                body: `<p>Show positions where <strong>pipelines disagree</strong> - at least one has a SNP and at least one doesn't.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Use case:</strong> Find positions where variant callers give different results, useful for:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Identifying pipeline-specific artifacts</li>
                           <li>Finding borderline/low-confidence variants</li>
                           <li>Quality control and validation</li>
                       </ul>`
            },
            'filter_gaps': {
                title: 'Gap Filter',
                body: `<p>Show positions where this pipeline has a <strong>coverage gap</strong> (depth below threshold).</p>
                       <p>Gaps indicate regions where:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Read coverage was insufficient for variant calling</li>
                           <li>The sample may be missing this genomic region</li>
                           <li>Sequencing quality was poor in this area</li>
                       </ul>
                       <p><strong>Note:</strong> SNPs called in gap regions of other pipelines may be less reliable.</p>`
            },
            'core_snps': {
                title: 'All SNPs (position-based)',
                body: `<p><strong>All</strong> = SNP positions present in <strong>ALL samples</strong> within this pipeline.</p>
                       <p>Position-based: counts where ALL samples have a SNP, regardless of which allele.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High % = consistent variant calling across samples</li>
                           <li>Low % = many sample-specific variants</li>
                       </ul>
                       <p><strong>Note:</strong> "All" ⊇ "Consensus" (All includes Consensus as a subset)</p>`
            },
            'consensus_snps': {
                title: 'Consensus SNPs',
                body: `<p><strong>Consensus SNPs</strong> = SNP positions where <strong>ALL samples within this pipeline</strong> have the <strong>SAME alt allele</strong>.</p>
                       <p>This is the intersection of SNP positions across all variant callers.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High consensus % = pipelines mostly agree</li>
                           <li>Low consensus % = pipelines find different variants (method-specific calls)</li>
                       </ul>
                       <p><strong>Note:</strong> The consensus count is the same for all pipelines since it's the intersection.</p>`
            }
        };

        function showKpiInfo(kpiType) {
            const info = kpiDescriptions[kpiType];
            if (!info) return;

            document.getElementById('info-modal-title').textContent = info.title;
            document.getElementById('info-modal-body').innerHTML = info.body;
            document.getElementById('info-modal').classList.add('active');
        }

        function closeInfoModal() {
            document.getElementById('info-modal').classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeInfoModal();
        });

        // Scroll to top button
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const btn = document.getElementById('scroll-top-btn');
            if (window.scrollY > 300) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        });
    </script>

    <script type="module">
        // When served locally, the WASM module is at wasm/pkg/
        // Adjust path if needed for your deployment
        import init, { GenomeData } from './wasm/coreguard_wasm.js';

        let genomeData = null;
        let samples = [];
        let positions = [];
        let currentPage = 0;
        let activeFilters = [];
        const CHAR_WIDTH = 7;
        const LABEL_WIDTH = 70;

        function getPageSize() {
            // Calculate how many nucleotides fit in the available width
            const availableWidth = window.innerWidth - LABEL_WIDTH - 20; // 20px padding
            return Math.max(50, Math.floor(availableWidth / CHAR_WIDTH));
        }

        window.gotoPosition = gotoPosition;
        window.nextPage = nextPage;
        window.prevPage = prevPage;
        window.toggleFilter = toggleFilter;
        window.onFilterConfigChange = onFilterConfigChange;
        window.updateQualityFilter = updateQualityFilter;
        window.resetQualityFilters = resetQualityFilters;
        window.calculateDistanceMatrix = calculateDistanceMatrix;
        window.setAllRowVisibility = setAllRowVisibility;
        window.filterVisibilityCheckboxes = filterVisibilityCheckboxes;
        window.toggleRowVisibility = toggleRowVisibility;
        window.redrawGenomeOverview = () => {
            if (genomeData && samples.length > 0) {
                drawGenomeOverview();
            }
        };

        let pipelines = [];
        let qualityFilters = { minQual: 0, minDepth: 0, minConsensus: 50 };

        function showLoader(text, progress = '') {
            document.getElementById('loader').classList.add('active');
            document.getElementById('loader-text').textContent = text;
            document.getElementById('loader-progress').textContent = progress;
        }

        function hideLoader() {
            document.getElementById('loader').classList.remove('active');
        }

        async function main() {
            await init();
            genomeData = new GenomeData();
            console.log('WASM initialized');
            setupDropZone();
            setupFileInput();
        }

        function setupDropZone() {
            const dropZone = document.getElementById('drop-zone');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('dragover');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('dragover');
                });
            });

            dropZone.addEventListener('drop', (e) => {
                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.json') || file.name.endsWith('.json.gz') || file.name.endsWith('.bin') || file.name.endsWith('.bin.gz') || file.name.endsWith('.gz'))) {
                    loadFile(file);
                }
            });
        }

        function setupFileInput() {
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadFile(file);
                }
            });
        }

        // Streaming decompression with progress updates (returns text)
        async function decompressGzipWithProgress(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                // Native streaming decompression
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const decoder = new TextDecoder();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(decoder.decode(value, { stream: true }));
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    // Yield to UI every few MB
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }
                chunks.push(decoder.decode()); // Flush
                return chunks.join('');
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed, { to: 'string' });
        }

        // Streaming decompression for binary data (returns Uint8Array)
        async function decompressGzipBinary(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }

                // Combine all chunks into single Uint8Array
                const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    result.set(chunk, offset);
                    offset += chunk.length;
                }
                return result;
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed);
        }

        // Detect if file is binary format based on filename
        function isBinaryFormat(filename) {
            return filename.endsWith('.bin') || filename.endsWith('.bin.gz');
        }

        async function loadDemo() {
            showLoader('Loading demo...', 'Fetching demo data');
            await new Promise(r => requestAnimationFrame(r));

            try {
                // Load binary format (faster than JSON)
                const response = await fetch('demo.bin.gz');
                if (!response.ok) throw new Error('Failed to fetch demo file');

                const compressedSize = parseInt(response.headers.get('content-length') || '0');
                showLoader('Downloading...', `${(compressedSize / 1024 / 1024).toFixed(1)} MB compressed`);
                await new Promise(r => requestAnimationFrame(r));
                const arrayBuffer = await response.arrayBuffer();

                showLoader('Decompressing...', '0 MB');
                const binaryData = await decompressGzipBinary(arrayBuffer, (bytes) => {
                    showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                });

                showLoader('Parsing binary...', `${(binaryData.length / 1024 / 1024).toFixed(0)} MB`);
                await new Promise(r => setTimeout(r, 50));

                genomeData.load_binary(binaryData);

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                samples = JSON.parse(genomeData.get_sample_ids());
                pipelines = JSON.parse(genomeData.get_pipeline_ids());

                document.getElementById('header-info').textContent =
                    `${genomeData.get_ref_name()} (${genomeData.get_ref_length().toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer
                const timestamp = genomeData.get_generated_at();
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                document.getElementById('drop-zone').classList.add('hidden');
                document.getElementById('viewer').classList.remove('hidden');

                showLoader('Calculating KPIs...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                updateKPIs();

                showLoader('Building UI...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                displayWarnings();
                populatePipelineInfo();
                populatePerSampleStats();
                populateReproducibilityCommands();
                createFilterButtons(pipelines);
                createVisibilityControls(pipelines);

                showLoader('Drawing genome overview...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                drawGenomeOverview();
                populateMatrixPipelineSelector();
                populateCoverageStats();

                showLoader('Loading positions...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                loadPositions();

                hideLoader();

            } catch (error) {
                hideLoader();
                alert('Error loading demo: ' + error.message);
                console.error(error);
            }
        }
        // Expose to global scope for onclick
        window.loadDemo = loadDemo;

        async function loadFile(file) {
            showLoader('Loading file...', `${(file.size / 1024 / 1024).toFixed(1)} MB`);
            await new Promise(r => requestAnimationFrame(r)); // Force repaint

            try {
                const isGzip = file.name.endsWith('.gz');
                const isBinary = isBinaryFormat(file.name);

                if (isBinary) {
                    // Binary (bincode) format - much faster to parse
                    showLoader('Decompressing...', '0 MB');
                    await new Promise(r => requestAnimationFrame(r));
                    const arrayBuffer = await file.arrayBuffer();

                    let binaryData;
                    if (isGzip) {
                        binaryData = await decompressGzipBinary(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                    } else {
                        binaryData = new Uint8Array(arrayBuffer);
                    }

                    showLoader('Parsing binary...', `${(binaryData.length / 1024 / 1024).toFixed(0)} MB`);
                    await new Promise(r => setTimeout(r, 50)); // Allow UI to update

                    genomeData.load_binary(binaryData);
                } else {
                    // JSON format
                    let text;
                    if (isGzip) {
                        showLoader('Decompressing...', '0 MB');
                        await new Promise(r => requestAnimationFrame(r));
                        const arrayBuffer = await file.arrayBuffer();

                        text = await decompressGzipWithProgress(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                        showLoader('Parsing JSON...', `${(text.length / 1024 / 1024).toFixed(1)} MB`);
                    } else {
                        showLoader('Reading file...', '');
                        text = await file.text();
                    }

                    showLoader('Parsing JSON...', `${(text.length / 1024 / 1024).toFixed(0)} MB`);
                    await new Promise(r => setTimeout(r, 50)); // Allow UI to update

                    genomeData.load_json(text);
                }

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                samples = JSON.parse(genomeData.get_sample_ids());
                pipelines = JSON.parse(genomeData.get_pipeline_ids());

                document.getElementById('header-info').textContent =
                    `${genomeData.get_ref_name()} (${genomeData.get_ref_length().toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer (format: dd/mm/yyyy hh:mi:ss)
                const timestamp = genomeData.get_generated_at();
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                document.getElementById('drop-zone').classList.add('hidden');
                document.getElementById('viewer').classList.remove('hidden');

                showLoader('Calculating KPIs...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                updateKPIs();

                showLoader('Building UI...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                displayWarnings();
                populatePipelineInfo();
                populatePerSampleStats();
                populateReproducibilityCommands();
                createFilterButtons(pipelines);
                createVisibilityControls(pipelines);

                showLoader('Drawing genome overview...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                drawGenomeOverview();
                populateMatrixPipelineSelector();
                populateCoverageStats();

                showLoader('Loading positions...', '');
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                loadPositions();

                hideLoader();

            } catch (err) {
                hideLoader();
                console.error('Failed to load report:', err);
                alert('Failed to load report: ' + err);
            }
        }

        function displayWarnings() {
            const warningsJson = genomeData.get_warnings();
            const warnings = JSON.parse(warningsJson);
            const container = document.getElementById('warnings');

            if (warnings.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            for (const warning of warnings) {
                // Skip MNP warnings - they're shown in the table with warning icon
                if (warning.includes('MNP')) {
                    continue;
                }
                html += `<div class="warning-item">${warning}</div>`;
            }
            container.innerHTML = html;
        }

        function populatePipelineInfo() {
            const pipelineIds = JSON.parse(genomeData.get_pipeline_ids());
            const container = document.getElementById('pipelines-info');

            let html = '';
            for (const pipelineId of pipelineIds) {
                const label = genomeData.get_pipeline_label(pipelineId);
                const command = genomeData.get_pipeline_command(pipelineId);
                const isGroundTruth = genomeData.is_ground_truth(pipelineId);
                const isFromBamPileup = genomeData.is_from_bam_pileup(pipelineId);

                html += `<div class="pipeline-info-item">`;
                html += `<div class="pipeline-name">${label}`;
                if (isGroundTruth) {
                    html += `<span class="pipeline-badge">Ground Truth</span>`;
                    if (isFromBamPileup) {
                        html += `<span class="pipeline-badge" style="background:#ff9800;" title="SNPs derived from BAM pileup, no variant calling filters applied">BAM pileup</span>`;
                    }
                }
                html += `</div>`;
                if (command) {
                    html += `<div class="pipeline-command">${command}</div>`;
                }
                if (isGroundTruth && isFromBamPileup) {
                    html += `<div style="color:#ff9800;font-size:10px;margin-top:4px;">⚠️ SNPs from BAM pileup - no variant calling performed</div>`;
                }
                html += `</div>`;
            }

            if (html === '') {
                html = '<p style="color:var(--text-secondary);font-size:11px;">No pipeline information available.</p>';
            }

            container.innerHTML = html;
        }

        function populatePerSampleStats() {
            const container = document.getElementById('per-sample-stats');
            const stats = JSON.parse(genomeData.get_per_sample_stats());
            const sampleIds = JSON.parse(genomeData.get_sample_ids());
            const pipelineIds = JSON.parse(genomeData.get_pipeline_ids());
            const gtPipeline = genomeData.get_ground_truth_pipeline();
            const refLength = genomeData.get_ref_length();
            const consensusStats = JSON.parse(genomeData.get_consensus_stats());

            if (Object.keys(stats).length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No per-sample statistics available.</p>';
                return;
            }

            // Build table
            let html = '<table class="stats-table">';

            // Header row
            html += '<tr><th rowspan="2">Sample</th>';
            for (const pipelineId of pipelineIds) {
                const label = genomeData.get_pipeline_label(pipelineId);
                const isGT = pipelineId === gtPipeline;
                const colspan = isGT ? 2 : 4;
                html += `<th colspan="${colspan}" class="pipeline-header">${label}${isGT ? ' (GT)' : ''}</th>`;
            }
            // Add per-pipeline intersection with GT columns
            const perSampleIntersection = gtPipeline ? JSON.parse(genomeData.get_per_sample_intersection_with_gt()) : null;
            const vcfPipelines = JSON.parse(genomeData.get_vcf_pipelines());
            const nonGtPipelines = vcfPipelines.filter(p => p !== gtPipeline);
            if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                const gtLabel = genomeData.get_pipeline_label(gtPipeline).split(' ')[0];
                for (const pipelineId of nonGtPipelines) {
                    const pLabel = genomeData.get_pipeline_label(pipelineId).split(' ')[0];
                    html += `<th class="pipeline-header" style="background:#1565c0;" title="SNP intersection: ${pLabel} ∩ ${gtLabel}">${pLabel} ∩ ${gtLabel}</th>`;
                }
            }
            // Add Consensus columns if we have GT
            if (gtPipeline && consensusStats?.per_sample) {
                const pipelineNames = nonGtPipelines.map(p => genomeData.get_pipeline_label(p).split(' ')[0]).join(' ∩ ');
                const gtLabel = genomeData.get_pipeline_label(gtPipeline).split(' ')[0];
                html += `<th colspan="2" class="pipeline-header" style="background:#4a4a4a;" title="Positions where VCF pipelines agree">${pipelineNames}</th>`;
                html += `<th class="pipeline-header" style="background:#6a1b9a;" title="Positions where ALL pipelines (incl. GT) agree">${gtLabel} ∩ ${pipelineNames}</th>`;
            }
            html += '</tr>';

            // Sub-header row (with info icons)
            const psInfoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')" style="margin-left:3px;">ⓘ</span>`;
            html += '<tr>';
            for (const pipelineId of pipelineIds) {
                const isGT = pipelineId === gtPipeline;
                html += `<th>SNPs ${psInfoIcon('ps_snps')}</th><th>Gaps ${psInfoIcon('ps_gaps')}</th>`;
                if (!isGT) {
                    html += `<th>vs GT ${psInfoIcon('ps_vs_gt')}</th>`;
                    html += `<th>in GT Gaps ${psInfoIcon('ps_in_gt_gaps')}</th>`;
                }
            }
            // Add intersection sub-headers
            if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                for (const pipelineId of nonGtPipelines) {
                    html += `<th>∩ ${psInfoIcon('ps_intersection')}</th>`;
                }
            }
            // Add Consensus sub-headers with explicit % labels
            if (gtPipeline && consensusStats?.per_sample) {
                html += `<th>SNPs<br><span style="font-size:9px;color:var(--text-secondary);">% of ref</span> ${psInfoIcon('ps_vcf_consensus')}</th>`;
                html += `<th>in GT<br><span style="font-size:9px;color:var(--text-secondary);">% of cons</span> ${psInfoIcon('ps_consensus_in_gt')}</th>`;
                html += `<th>All<br><span style="font-size:9px;color:var(--text-secondary);">% of ref</span> ${psInfoIcon('ps_all_consensus')}</th>`;
            }
            html += '</tr>';

            // Data rows
            for (const sampleId of sampleIds) {
                const sampleLabel = genomeData.get_sample_label(sampleId) || sampleId;
                const sampleStats = stats[sampleId];
                if (!sampleStats) continue;

                html += `<tr><td>${sampleLabel}</td>`;

                for (const pipelineId of pipelineIds) {
                    const isGT = pipelineId === gtPipeline;
                    const pStats = sampleStats.pipelines[pipelineId];

                    if (pStats) {
                        // SNPs with percentage of reference
                        const snpPct = ((pStats.snps / refLength) * 100).toFixed(2);
                        html += `<td title="${pStats.snps.toLocaleString()} SNPs">${pStats.snps.toLocaleString()} (${snpPct}%)</td>`;

                        // Gaps with percentage of reference
                        const gapPct = ((pStats.gap_bp / refLength) * 100).toFixed(1);
                        html += `<td title="${pStats.gap_bp.toLocaleString()} bp gaps">${pStats.gap_bp.toLocaleString()} (${gapPct}%)</td>`;

                        if (!isGT) {
                            // Agreement with GT
                            const agreePct = pStats.agreement_with_gt_pct.toFixed(1);
                            const agreeClass = pStats.agreement_with_gt_pct >= 90 ? 'good' : pStats.agreement_with_gt_pct >= 70 ? 'warning' : 'bad';
                            html += `<td class="${agreeClass}" title="${pStats.agreement_with_gt.toLocaleString()} SNPs match GT positions">${pStats.agreement_with_gt.toLocaleString()} (${agreePct}%)</td>`;

                            // SNPs in GT gaps
                            const gapsPct = pStats.snps_in_gt_gaps_pct.toFixed(2);
                            const gapsClass = pStats.snps_in_gt_gaps_pct <= 1 ? 'good' : pStats.snps_in_gt_gaps_pct <= 5 ? 'warning' : 'bad';
                            html += `<td class="${gapsClass}" title="${pStats.snps_in_gt_gaps.toLocaleString()} SNPs in GT gaps">${pStats.snps_in_gt_gaps.toLocaleString()} (${gapsPct}%)</td>`;
                        }
                    } else {
                        html += '<td>-</td><td>-</td>';
                        if (!isGT) {
                            html += '<td>-</td><td>-</td>';
                        }
                    }
                }

                // Add per-pipeline intersection with GT columns
                if (gtPipeline && perSampleIntersection && perSampleIntersection[sampleId]) {
                    const sampleInt = perSampleIntersection[sampleId];
                    for (const pipelineId of nonGtPipelines) {
                        const iStats = sampleInt[pipelineId];
                        if (iStats) {
                            const intClass = iStats.pct_of_gt >= 90 ? 'good' : iStats.pct_of_gt >= 70 ? 'warning' : 'bad';
                            const gtLabel = genomeData.get_pipeline_label(gtPipeline).split(' ')[0];
                            const pLabel = genomeData.get_pipeline_label(pipelineId).split(' ')[0];
                            html += `<td class="${intClass}" title="${iStats.intersection.toLocaleString()} SNPs shared\n${pLabel}: ${iStats.pipeline_snps.toLocaleString()} SNPs\n${gtLabel}: ${iStats.gt_snps.toLocaleString()} SNPs\n${iStats.pct_of_pipeline.toFixed(1)}% of ${pLabel}, ${iStats.pct_of_gt.toFixed(1)}% of ${gtLabel}">${iStats.intersection.toLocaleString()} (${iStats.pct_of_gt.toFixed(1)}%)</td>`;
                        } else {
                            html += '<td>-</td>';
                        }
                    }
                } else if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                    for (const _ of nonGtPipelines) {
                        html += '<td>-</td>';
                    }
                }

                // Add Consensus columns
                if (gtPipeline && consensusStats?.per_sample) {
                    const cStats = consensusStats.per_sample[sampleId];
                    if (cStats && cStats.vcf_consensus) {
                        const vc = cStats.vcf_consensus;
                        const cSnpPct = ((vc.consensus_snps / refLength) * 100).toFixed(2);
                        html += `<td title="${vc.consensus_snps.toLocaleString()} VCF consensus SNPs">${vc.consensus_snps.toLocaleString()} (${cSnpPct}%)</td>`;

                        const inGtPct = vc.consensus_in_gt_pct.toFixed(1);
                        const inGtClass = vc.consensus_in_gt_pct >= 90 ? 'good' : vc.consensus_in_gt_pct >= 70 ? 'warning' : 'bad';
                        html += `<td class="${inGtClass}" title="${vc.consensus_in_gt.toLocaleString()} of ${vc.consensus_snps.toLocaleString()} VCF consensus SNPs are in GT">${vc.consensus_in_gt.toLocaleString()} (${inGtPct}%)</td>`;

                        // All consensus (GT ∩ all VCF)
                        const allPct = ((cStats.all_consensus / refLength) * 100).toFixed(2);
                        html += `<td style="color:#9c27b0;" title="Positions where ALL pipelines (incl. GT) agree">${cStats.all_consensus.toLocaleString()} (${allPct}%)</td>`;
                    } else {
                        html += '<td>-</td><td>-</td><td>-</td>';
                    }
                }

                html += '</tr>';
            }

            html += '</table>';

            // Add legend
            html += `<div style="margin-top:10px;font-size:10px;color:var(--text-secondary);">
                <strong>Legend:</strong>
                <span class="good">Green</span> = good,
                <span class="warning">Yellow</span> = moderate,
                <span class="bad">Red</span> = potential issue |
                <strong>vs GT:</strong> % of GT SNP positions also called by this pipeline |
                <strong>in GT Gaps:</strong> SNPs in regions with no GT coverage |
                <strong>Consensus:</strong> positions where ALL VCF pipelines agree
            </div>`;

            container.innerHTML = html;
        }

        function populateReproducibilityCommands() {
            const container = document.getElementById('reproducibility-content');
            const filePaths = JSON.parse(genomeData.get_file_paths());
            const kpis = JSON.parse(genomeData.get_kpis());
            const pipelineIds = JSON.parse(genomeData.get_pipeline_ids());
            const groundTruthPipeline = genomeData.get_ground_truth_pipeline();

            if (Object.keys(filePaths).length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No file paths available in report.</p>';
                return;
            }

            let html = '<p style="font-size:10px;color:var(--text-secondary);margin-bottom:15px;">Copy these commands to verify the statistics shown in the dashboard.</p>';

            // Group commands by type
            html += '<div class="repro-section"><h4>SNP Counts (bcftools)</h4>';
            for (const pipeline of pipelineIds) {
                if (!kpis.snps[pipeline]) continue;
                const label = genomeData.get_pipeline_label(pipeline);
                // Get first sample's VCF path as example
                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[pipeline]?.vcf) {
                        const vcf = pipelines[pipeline].vcf;
                        const cmd = `bcftools view -H "${vcf}" | wc -l`;
                        html += `<div class="repro-cmd"><code>${cmd}</code><button onclick="copyToClipboard(this, \`${cmd.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                        html += `<div class="repro-note">Expected: ~${kpis.snps[pipeline].toLocaleString()} for ${label} (${sample})</div>`;
                        break;
                    }
                }
            }
            html += '</div>';

            // Gap calculation commands
            html += '<div class="repro-section"><h4>Gap Regions (samtools depth)</h4>';
            for (const pipeline of pipelineIds) {
                if (!kpis.gaps[pipeline]) continue;
                const label = genomeData.get_pipeline_label(pipeline);
                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[pipeline]?.bam) {
                        const bam = pipelines[pipeline].bam;
                        const cmd = `samtools depth -a "${bam}" | awk '$3==0 {sum++} END {print sum}'`;
                        html += `<div class="repro-cmd"><code>${cmd}</code><button onclick="copyToClipboard(this, \`${cmd.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                        html += `<div class="repro-note">Zero-coverage positions for ${label} (${sample})</div>`;
                        break;
                    }
                }
            }
            html += '</div>';

            // SNPs in GT gaps verification
            if (groundTruthPipeline) {
                html += '<div class="repro-section"><h4>SNPs in Ground Truth Gaps (bedtools)</h4>';
                html += '<div class="repro-note" style="margin-bottom:8px;">Export gaps as BED, then intersect with VCF:</div>';

                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[groundTruthPipeline]?.bam) {
                        const gtBam = pipelines[groundTruthPipeline].bam;
                        const cmd1 = `samtools depth -a "${gtBam}" | awk '$3==0 {print $1"\\t"$2-1"\\t"$2}' > gt_gaps.bed`;
                        html += `<div class="repro-cmd"><code>${cmd1}</code><button onclick="copyToClipboard(this, \`${cmd1.replace(/`/g, '\\`')}\`)">Copy</button></div>`;

                        for (const pipeline of pipelineIds) {
                            if (pipeline === groundTruthPipeline) continue;
                            if (pipelines[pipeline]?.vcf) {
                                const vcf = pipelines[pipeline].vcf;
                                const label = genomeData.get_pipeline_label(pipeline);
                                const cmd2 = `bedtools intersect -a "${vcf}" -b gt_gaps.bed | wc -l`;
                                html += `<div class="repro-cmd"><code>${cmd2}</code><button onclick="copyToClipboard(this, \`${cmd2.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                                html += `<div class="repro-note">${label} SNPs in GT gaps (${sample})</div>`;
                            }
                        }
                        break;
                    }
                }
                html += '</div>';
            }

            container.innerHTML = html;
        }

        function copyToClipboard(button, text) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = originalText, 1500);
            });
        }

        function updateKPIs(filteredCount = null) {
            const kpisJson = genomeData.get_kpis();
            const kpis = JSON.parse(kpisJson);
            const refLength = genomeData.get_ref_length();
            const gtPipelineId = genomeData.get_ground_truth_pipeline();

            // Helper to sort pipeline entries with GT always first, then alphabetically
            const sortedPipelineEntries = (obj) => {
                return Object.entries(obj).sort(([a], [b]) => {
                    if (a === gtPipelineId) return -1;
                    if (b === gtPipelineId) return 1;
                    return a.localeCompare(b);
                });
            };

            // Helper to create info icon
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')">ⓘ</span>`;

            // Helper to create section header
            const sectionHeader = (title) => `<div class="kpi-section-header">${title}</div>`;

            let html = '';

            // === SECTION 1: Overview ===
            html += sectionHeader('Overview');
            html += `
                <div class="kpi"><div class="label">Reference ${infoIcon('reference')}</div><div class="value">${refLength.toLocaleString()} bp</div></div>
                <div class="kpi"><div class="label">Samples ${infoIcon('samples')}</div><div class="value">${kpis.samples}</div></div>
                <div class="kpi"><div class="label">Pipelines ${infoIcon('pipelines')}</div><div class="value">${kpis.pipelines}</div></div>
            `;

            // Show filtered positions count when filters are active
            if (filteredCount !== null) {
                html += `<div class="kpi"><div class="label">Filtered Positions ${infoIcon('filtered')}</div><div class="value">${filteredCount.toLocaleString()}</div></div>`;
            }

            // === SECTION 2: Per-Pipeline Statistics (Pivot Table) ===
            html += sectionHeader('Per-Pipeline Statistics');

            // Helper for subsection labels
            const subLabel = (title) => `<div class="kpi-sub-label">${title}</div>`;

            // Get MNP stats for table
            const mnpStats = JSON.parse(genomeData.get_mnp_stats());

            // Get GT counts for diff calculation
            const gtSnpCount = gtPipelineId ? (kpis.snps[gtPipelineId] || 0) : null;
            const gtGapCount = gtPipelineId ? (kpis.gaps[gtPipelineId] || 0) : null;

            // Build pivot table: rows = pipelines, columns = metrics
            html += `<table class="kpi-table">
                <thead>
                    <tr>
                        <th>Pipeline</th>
                        <th>SNPs ${infoIcon('snps')}</th>
                        <th>#All ${infoIcon('core_snps')}</th>
                        <th>#Consensus ${infoIcon('consensus_snps')}</th>
                        <th>Gaps ${infoIcon('gaps')}</th>
                        <th>MNPs ${infoIcon('mnps')}</th>
                    </tr>
                </thead>
                <tbody>`;

            for (const [pipeline, snpCount] of sortedPipelineEntries(kpis.snps)) {
                const label = genomeData.get_pipeline_label(pipeline).split(' ')[0]; // Short label
                const gapCount = kpis.gaps[pipeline] || 0;
                const coreCount = kpis.core_snps ? (kpis.core_snps[pipeline] || 0) : 0;
                const consCount = kpis.consensus_snps ? (kpis.consensus_snps[pipeline] || 0) : 0;
                const mStats = mnpStats ? mnpStats[pipeline] : null;
                const mnpCount = mStats ? mStats.mnps_found : 0;
                const isFromBamPileup = genomeData.is_from_bam_pileup(pipeline);

                // Calculate percentages
                const totalBases = refLength * kpis.samples;
                const snpPct = ((snpCount / totalBases) * 100).toFixed(2);
                const gapPct = ((gapCount / totalBases) * 100).toFixed(2);
                const corePct = snpCount > 0 ? ((coreCount / snpCount) * 100).toFixed(0) : 0;
                const consPct = snpCount > 0 ? ((consCount / snpCount) * 100).toFixed(0) : 0;

                // Calculate diff vs GT for non-GT pipelines
                let snpDiff = '';
                let gapDiff = '';
                if (gtPipelineId && pipeline !== gtPipelineId) {
                    if (gtSnpCount !== null) {
                        const diff = snpCount - gtSnpCount;
                        const diffSign = diff >= 0 ? '+' : '';
                        const diffPct = gtSnpCount > 0 ? ((diff / gtSnpCount) * 100).toFixed(1) : 0;
                        const diffPctSign = diff >= 0 ? '+' : '';
                        snpDiff = `<span class="pct" style="color:${diff < 0 ? '#e57373' : '#81c784'}">${diffSign}${diff.toLocaleString()} (${diffPctSign}${diffPct}%)</span>`;
                    }
                    if (gtGapCount !== null) {
                        const diff = gapCount - gtGapCount;
                        const diffSign = diff >= 0 ? '+' : '';
                        const diffPct = gtGapCount > 0 ? ((diff / gtGapCount) * 100).toFixed(1) : 0;
                        const diffPctSign = diff >= 0 ? '+' : '';
                        gapDiff = `<span class="pct" style="color:${diff > 0 ? '#e57373' : '#81c784'}">${diffSign}${diff.toLocaleString()} (${diffPctSign}${diffPct}%)</span>`;
                    }
                }

                // Warning icon for MNPs
                const mnpWarning = mnpCount > 0 ? `<span class="mnp-warning" onclick="event.stopPropagation();showKpiInfo('mnp')" title="Click for MNP info">⚠️</span>` : '';
                // Warning icon for BAM pileup (no variant calling)
                const bamPileupWarning = isFromBamPileup ? `<span class="mnp-warning" style="color:#ff9800;" onclick="event.stopPropagation();showKpiInfo('bam_pileup')" title="SNPs from BAM pileup - no variant calling">⚠️</span>` : '';

                html += `<tr>
                    <td>${label}</td>
                    <td>${snpCount.toLocaleString()}<span class="pct">(${snpPct}%)</span>${bamPileupWarning}${snpDiff}</td>
                    <td>${coreCount.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                    <td>${consCount.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                    <td>${gapCount.toLocaleString()}<span class="pct">(${gapPct}%)</span>${gapDiff}</td>
                    <td>${mnpCount.toLocaleString()}${mnpWarning}</td>
                </tr>`;
            }

            html += `</tbody></table>`;

            // === SECTION 3: Cross-Pipeline Concordance ===
            const concordance = JSON.parse(genomeData.get_pipeline_concordance());
            if (concordance && Object.keys(concordance).length > 0) {
                html += sectionHeader('Cross-Pipeline Concordance');

                // Build table with all pairwise concordance stats
                const allPipelines = sortedPipelineEntries(kpis.snps).map(([p]) => p);
                const getShortLabel = (p) => genomeData.get_pipeline_label(p).split(' ')[0];

                html += `<div style="font-size:11px;color:var(--text-secondary);margin-bottom:5px;">SNP positions shared between pipelines. % = shared / min(SNPs<sub>A</sub>, SNPs<sub>B</sub>)</div>`;
                html += `<table class="kpi-table">
                    <thead>
                        <tr>
                            <th></th>
                            <th colspan="2" style="text-align:center;">Concordance (same position) ${infoIcon('concordance')}</th>
                            <th colspan="2" style="text-align:center;">Consensus (same allele) ${infoIcon('consensus')}</th>
                        </tr>
                        <tr>
                            <th>A ∩ B</th>
                            <th style="text-align:center;" title="At least 1 sample has SNP in both pipelines. % = shared / min(SNPs_A, SNPs_B)">Any</th>
                            <th style="text-align:center;" title="ALL samples have SNP in both pipelines (Core ∩ Core). % = shared / min(SNPs_A, SNPs_B)">All</th>
                            <th style="text-align:center;" title="At least 1 sample has same allele in both pipelines. % = shared / min(SNPs_A, SNPs_B)">Any</th>
                            <th style="text-align:center;" title="ALL samples have same allele in both pipelines. % = shared / min(SNPs_A, SNPs_B)">All</th>
                        </tr>
                    </thead>
                    <tbody>`;

                // Show all unique pairs
                for (let i = 0; i < allPipelines.length; i++) {
                    const pipelineA = allPipelines[i];
                    const labelA = getShortLabel(pipelineA);
                    const snpsA = kpis.snps[pipelineA] || 0;
                    for (let j = i + 1; j < allPipelines.length; j++) {
                        const pipelineB = allPipelines[j];
                        const labelB = getShortLabel(pipelineB);
                        const snpsB = kpis.snps[pipelineB] || 0;

                        // Get concordance stats (check both directions since we only store one)
                        let stats = concordance[pipelineA]?.[pipelineB] || concordance[pipelineB]?.[pipelineA];
                        if (stats) {
                            // Calculate percentages relative to minimum SNPs (max possible overlap)
                            const minSnps = Math.min(snpsA, snpsB);
                            const pctConcAny = minSnps > 0 ? (stats.concordance_any / minSnps * 100).toFixed(1) : '0.0';
                            const pctConcAll = minSnps > 0 ? (stats.concordance_all / minSnps * 100).toFixed(1) : '0.0';
                            const pctConsAny = minSnps > 0 ? (stats.consensus_any / minSnps * 100).toFixed(1) : '0.0';
                            const pctConsAll = minSnps > 0 ? (stats.consensus_all / minSnps * 100).toFixed(1) : '0.0';

                            html += `<tr>
                                <td>${labelA} ∩ ${labelB}</td>
                                <td style="text-align:center;">${stats.concordance_any.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConcAny}%)</span></td>
                                <td style="text-align:center;">${stats.concordance_all.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConcAll}%)</span></td>
                                <td style="text-align:center;">${stats.consensus_any.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConsAny}%)</span></td>
                                <td style="text-align:center;">${stats.consensus_all.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConsAll}%)</span></td>
                            </tr>`;
                        }
                    }
                }

                html += `</tbody></table>`;
            }

            // === SECTION 4: Ground Truth Comparison (only if GT exists) ===
            if (gtPipelineId) {
                html += sectionHeader('Ground Truth Comparison');

                const gtLabel = genomeData.get_pipeline_label(gtPipelineId);
                const gtShortLabel = gtLabel.split(' ')[0];

                // SNPs in GT Gaps - consolidated table
                if (kpis.snps_in_gt_gaps_total && Object.keys(kpis.snps_in_gt_gaps_total).length > 0) {
                    html += subLabel(`SNPs in ${gtShortLabel} Gaps`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>Any ${infoIcon('snps_in_gt_gaps')}</th>
                                <th>All ${infoIcon('all_snps_in_gt_gaps')}</th>
                                <th>Consensus ${infoIcon('consensus_snps_in_gt_gaps')}</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    for (const [pipeline, totalCount] of sortedPipelineEntries(kpis.snps_in_gt_gaps_total)) {
                        const label = genomeData.get_pipeline_label(pipeline).split(' ')[0];
                        const coreCount = kpis.snps_in_gt_gaps_core ? (kpis.snps_in_gt_gaps_core[pipeline] || 0) : 0;
                        const consCount = kpis.snps_in_gt_gaps_consensus ? (kpis.snps_in_gt_gaps_consensus[pipeline] || 0) : 0;
                        const totalSnps = kpis.snps[pipeline] || 1;
                        const coreSnps = kpis.core_snps ? (kpis.core_snps[pipeline] || 1) : 1;
                        const consSnps = kpis.consensus_snps ? (kpis.consensus_snps[pipeline] || 1) : 1;
                        const totalPct = ((totalCount / totalSnps) * 100).toFixed(1);
                        const corePct = ((coreCount / coreSnps) * 100).toFixed(1);
                        const consPct = ((consCount / consSnps) * 100).toFixed(1);

                        html += `<tr>
                            <td>${label}</td>
                            <td>${totalCount.toLocaleString()}<span class="pct">(${totalPct}%)</span></td>
                            <td>${coreCount.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                            <td>${consCount.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }

                // GT SNPs Filtered - consolidated table
                if (kpis.gt_snps_missing && kpis.gt_total_snps > 0) {
                    html += subLabel(`${gtShortLabel} SNPs Filtered by Pipeline`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>Any (/${kpis.gt_total_snps.toLocaleString()}) ${infoIcon('gt_snps_missing')}</th>
                                <th>All (/${(kpis.core_gt_total || 0).toLocaleString()}) ${infoIcon('all_gt_missing')}</th>
                                <th>Consensus (/${(kpis.consensus_gt_total || 0).toLocaleString()}) ${infoIcon('consensus_gt_missing')}</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    for (const [pipeline, totalMissing] of sortedPipelineEntries(kpis.gt_snps_missing)) {
                        const label = genomeData.get_pipeline_label(pipeline).split(' ')[0];
                        const coreMissing = kpis.core_gt_missing ? (kpis.core_gt_missing[pipeline] || 0) : 0;
                        const consMissing = kpis.consensus_gt_missing ? (kpis.consensus_gt_missing[pipeline] || 0) : 0;
                        const totalPct = ((totalMissing / kpis.gt_total_snps) * 100).toFixed(1);
                        const corePct = kpis.core_gt_total > 0 ? ((coreMissing / kpis.core_gt_total) * 100).toFixed(1) : '0';
                        const consPct = kpis.consensus_gt_total > 0 ? ((consMissing / kpis.consensus_gt_total) * 100).toFixed(1) : '0';

                        html += `<tr>
                            <td>${label}</td>
                            <td>${totalMissing.toLocaleString()}<span class="pct">(${totalPct}%)</span></td>
                            <td>${coreMissing.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                            <td>${consMissing.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }
            }

            // === SECTION 5: Cross-Pipeline Gap Analysis (all pairwise combinations) ===
            const snpsInGapsJson = genomeData.get_snps_in_gaps();
            const snpsInGaps = snpsInGapsJson !== 'null' ? JSON.parse(snpsInGapsJson) : null;

            if (snpsInGaps && Object.keys(snpsInGaps).length > 0) {
                html += sectionHeader('Cross-Pipeline Gap Analysis');

                // For each pipeline that has gaps (gap source)
                for (const gapPipeline of Object.keys(snpsInGaps).sort()) {
                    const gapPipelineStats = snpsInGaps[gapPipeline];
                    if (!gapPipelineStats || Object.keys(gapPipelineStats).length === 0) continue;

                    const gapLabel = genomeData.get_pipeline_label(gapPipeline).split(' ')[0];

                    html += subLabel(`SNPs in ${gapLabel} Gaps ${infoIcon('snps_in_pipeline_gaps')}`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>SNPs in ${gapLabel} Gaps</th>
                                <th>Total SNPs</th>
                                <th>%</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    // Sort by pipeline name
                    const sortedSnpPipelines = Object.entries(gapPipelineStats)
                        .sort((a, b) => a[0].localeCompare(b[0]));

                    for (const [snpPipeline, stats] of sortedSnpPipelines) {
                        const snpLabel = genomeData.get_pipeline_label(snpPipeline).split(' ')[0];
                        const pct = stats.percentage.toFixed(2);
                        const pctClass = stats.percentage <= 1 ? 'good' : stats.percentage <= 5 ? 'warning' : 'bad';

                        html += `<tr>
                            <td>${snpLabel}</td>
                            <td>${stats.snps_in_gaps.toLocaleString()}</td>
                            <td>${stats.total_snps.toLocaleString()}</td>
                            <td class="${pctClass}">${pct}%</td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }
            }

            document.getElementById('kpis').innerHTML = html;
        }

        function createFilterButtons(pipelines) {
            const container = document.getElementById('filters');
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')" style="margin-left:3px;">ⓘ</span>`;

            container.innerHTML = '<span style="color:#808080;margin-right:5px;">SNP Filters:</span>';

            // Get pipelines with VCF data (only these can have SNP filters)
            const vcfPipelines = JSON.parse(genomeData.get_vcf_pipelines());

            // Pipeline SNP filters - only for pipelines with VCF (with info icon inside)
            for (const p of pipelines) {
                if (!vcfPipelines.includes(p)) continue;
                const label = genomeData.get_pipeline_label(p);
                container.innerHTML += `<button class="filter-btn" data-filter="${p}" onclick="toggleFilter('${p}')">${label} ${infoIcon('filter_pipeline')}</button>`;
            }

            // Special SNP filters with info icons inside
            container.innerHTML += `
                <button class="filter-btn" data-filter="consensus" onclick="toggleFilter('consensus')">Consensus ${infoIcon('filter_consensus')}</button>
                <button class="filter-btn" data-filter="discordant" onclick="toggleFilter('discordant')">Discordant ${infoIcon('filter_discordant')}</button>
            `;

            // Gap filters - show all pipelines (with info icon inside)
            container.innerHTML += '<span style="color:#808080;margin-left:15px;margin-right:5px;">Gap Filters:</span>';
            for (const p of pipelines) {
                const label = genomeData.get_pipeline_label(p);
                container.innerHTML += `<button class="filter-btn gap-filter" data-filter="gaps:${p}" onclick="toggleFilter('gaps:${p}')">${label} Gaps ${infoIcon('filter_gaps')}</button>`;
            }
        }

        // Track hidden rows
        let hiddenRows = new Set();

        function createVisibilityControls(pipelines) {
            const container = document.getElementById('visibility-controls');
            let html = '';

            // Get ground truth pipeline (if any) - it's hidden from individual rows
            const groundTruthPipeline = genomeData.get_ground_truth_pipeline();

            // Per-sample controls
            for (const sample of samples) {
                const sampleLabel = genomeData.get_sample_label(sample);
                html += `<div class="vis-group">
                    <div class="vis-group-title">${sampleLabel}</div>
                    <div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-main" checked onchange="toggleRowVisibility('${sampleLabel}', this.checked)">
                        <label for="vis-${sample}-main">Sample</label>
                    </div>`;

                for (const p of pipelines) {
                    // Skip ground truth pipeline - it's not shown as a separate row
                    if (groundTruthPipeline && p === groundTruthPipeline) {
                        continue;
                    }
                    const pipelineLabel = genomeData.get_pipeline_label(p);
                    const rowId = `${sampleLabel}|${pipelineLabel}`;
                    html += `<div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-${p}" checked onchange="toggleRowVisibility('${rowId}', this.checked)">
                        <label for="vis-${sample}-${p}">${pipelineLabel}</label>
                    </div>`;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function toggleRowVisibility(rowLabel, visible) {
            if (visible) {
                hiddenRows.delete(rowLabel);
            } else {
                hiddenRows.add(rowLabel);
            }
            applyRowVisibility();
        }

        function setAllRowVisibility(visible) {
            // Get all visibility checkboxes
            const checkboxes = document.querySelectorAll('#visibility-controls input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const isVisible = document.getElementById('visibility-filter').value.toLowerCase();
                const label = cb.nextElementSibling?.textContent?.toLowerCase() || '';
                // Only affect visible (not filtered out) checkboxes
                if (!isVisible || label.includes(isVisible)) {
                    cb.checked = visible;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        }

        function filterVisibilityCheckboxes(filter) {
            const lowerFilter = filter.toLowerCase();
            document.querySelectorAll('#visibility-controls .vis-item').forEach(item => {
                const label = item.querySelector('label')?.textContent?.toLowerCase() || '';
                item.style.display = !filter || label.includes(lowerFilter) ? '' : 'none';
            });
            // Also filter group titles visibility (hide group if all items hidden)
            document.querySelectorAll('#visibility-controls .vis-group').forEach(group => {
                const visibleItems = group.querySelectorAll('.vis-item:not([style*="display: none"])');
                group.style.display = visibleItems.length > 0 ? '' : 'none';
            });
        }

        function applyRowVisibility() {
            document.querySelectorAll('.alignment-view .row').forEach(row => {
                const lbl = row.querySelector('.lbl');
                if (lbl) {
                    const labelText = lbl.textContent.trim();
                    // Check if this row should be hidden
                    let shouldHide = hiddenRows.has(labelText);

                    // Also check for pipeline rows (sub labels)
                    if (lbl.classList.contains('sub')) {
                        // Find parent sample by looking at previous non-sub row
                        let prevRow = row.previousElementSibling;
                        while (prevRow && prevRow.querySelector('.lbl.sub')) {
                            prevRow = prevRow.previousElementSibling;
                        }
                        if (prevRow) {
                            const parentLabel = prevRow.querySelector('.lbl')?.textContent.trim();
                            const combinedLabel = `${parentLabel}|${labelText}`;
                            shouldHide = hiddenRows.has(combinedLabel) || hiddenRows.has(labelText);
                        }
                    }

                    row.classList.toggle('hidden-row', shouldHide);
                }
            });
        }

        window.toggleRowVisibility = toggleRowVisibility;

        let showNucleotideLetters = true;

        function toggleNucleotideLetters(show) {
            showNucleotideLetters = show;
            document.querySelectorAll('.alignment-view .row .cell').forEach(cell => {
                if (show) {
                    cell.classList.remove('hide-letters');
                } else {
                    cell.classList.add('hide-letters');
                }
            });
        }
        window.toggleNucleotideLetters = toggleNucleotideLetters;

        function updateQualityFilter() {
            const minQual = parseInt(document.getElementById('min-qual').value) || 0;
            const minDepth = parseInt(document.getElementById('min-depth').value) || 0;
            const minConsensus = parseInt(document.getElementById('min-consensus').value) || 50;

            qualityFilters.minQual = minQual;
            qualityFilters.minDepth = minDepth;
            qualityFilters.minConsensus = minConsensus;

            // Reload positions with quality filtering
            currentPage = 0;
            loadPositions();
        }

        function resetQualityFilters() {
            document.getElementById('min-qual').value = 0;
            document.getElementById('min-depth').value = 0;
            document.getElementById('min-consensus').value = 50;

            qualityFilters.minQual = 0;
            qualityFilters.minDepth = 0;
            qualityFilters.minConsensus = 50;

            currentPage = 0;
            loadPositions();
        }

        function filterByQuality(allPositions) {
            // If no quality filters, return all positions
            if (qualityFilters.minQual === 0 && qualityFilters.minDepth === 0) {
                return allPositions;
            }

            // Filter positions by quality
            // For each position, check if at least one sample/pipeline meets quality criteria
            const filtered = [];
            let checkedCount = 0;
            let passedQualCount = 0;
            let passedDepthCount = 0;

            for (const pos of allPositions) {
                let positionPasses = false;

                for (const sample of samples) {
                    for (const pipeline of pipelines) {
                        // get_snp returns "ref,alt,qual,depth" or empty string
                        const snpData = genomeData.get_snp(sample, pipeline, pos - 1); // 0-based
                        if (snpData) {
                            const parts = snpData.split(',');
                            if (parts.length >= 4) {
                                const qual = parseFloat(parts[2]) || 0;
                                const depth = parseInt(parts[3]) || 0;
                                checkedCount++;

                                const qualPasses = qual >= qualityFilters.minQual;
                                const depthPasses = depth >= qualityFilters.minDepth;

                                if (qualPasses) passedQualCount++;
                                if (depthPasses) passedDepthCount++;

                                if (qualPasses && depthPasses) {
                                    positionPasses = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (positionPasses) break;
                }

                if (positionPasses) {
                    filtered.push(pos);
                }
            }

            // Update quality stats display
            const statsEl = document.getElementById('quality-stats');
            if (statsEl && checkedCount > 0) {
                statsEl.textContent = `Checked ${checkedCount} SNPs: ${passedQualCount} passed QUAL filter, ${passedDepthCount} passed Depth filter`;
            }

            return filtered;
        }

        async function toggleFilter(filter) {
            console.log('toggleFilter called with:', filter);
            const idx = activeFilters.indexOf(filter);
            if (idx >= 0) {
                activeFilters.splice(idx, 1);
                console.log('Filter removed:', filter);
            } else {
                activeFilters.push(filter);
                console.log('Filter added:', filter);
            }
            console.log('Active filters:', activeFilters);

            // Update button states with INLINE styles (no cache issues)
            document.querySelectorAll('.filter-btn').forEach(btn => {
                const f = btn.dataset.filter;
                const isActive = activeFilters.includes(f);
                btn.classList.toggle('active', isActive);

                // Force inline styles
                if (isActive) {
                    btn.style.background = '#0066ff';
                    btn.style.color = 'white';
                    btn.style.fontWeight = 'bold';
                    btn.style.boxShadow = '0 0 10px #0066ff';
                    if (!btn.textContent.startsWith('✓')) {
                        btn.textContent = '✓ ' + btn.textContent;
                    }
                    console.log('Button activated:', f);
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.fontWeight = '';
                    btn.style.boxShadow = '';
                    btn.textContent = btn.textContent.replace(/^✓ /, '');
                }
            });

            currentPage = 0;
            showLoader('Applying filters...', '');
            // Allow UI to update before heavy computation
            await new Promise(r => setTimeout(r, 10));
            loadPositions();
            hideLoader();
        }

        function loadPositions() {
            const filterStr = activeFilters.join(',');
            const filterMode = document.getElementById('filter-mode').value;
            const sampleMode = document.getElementById('sample-mode').value;

            // Log filter info
            const pipelineFilters = activeFilters.filter(f =>
                !f.startsWith('gaps:') && f !== 'consensus' && f !== 'discordant'
            );
            const vcfPipelines = JSON.parse(genomeData.get_vcf_pipelines());
            const hasConsensus = activeFilters.includes('consensus');
            const hasDiscordant = activeFilters.includes('discordant');

            if (hasConsensus || hasDiscordant) {
                const scopeInfo = pipelineFilters.length > 0
                    ? `Selected: [${pipelineFilters.join(', ')}]`
                    : `All VCF pipelines: [${vcfPipelines.join(', ')}]`;
                console.log(`🔍 ${hasConsensus ? 'Consensus' : 'Discordant'} scope: ${scopeInfo}`);
            }

            const positionsJson = genomeData.get_filtered_positions_v2(
                JSON.stringify(samples),
                filterStr,
                filterMode,
                sampleMode
            );
            let allPositions = JSON.parse(positionsJson);
            console.log(`📊 Filters: [${filterStr}] → ${allPositions.length} positions`);

            // Apply quality filters
            const beforeQualityFilter = allPositions.length;
            positions = filterByQuality(allPositions);

            const modeInfo = activeFilters.length > 1 ? ` [${filterMode.toUpperCase()}, ${sampleMode}]` : '';
            let qualInfo = '';
            if (qualityFilters.minQual > 0 || qualityFilters.minDepth > 0) {
                qualInfo = ` (${beforeQualityFilter - positions.length} filtered by quality)`;
            }
            document.getElementById('status').textContent = `${positions.length.toLocaleString()} positions match filters${modeInfo}${qualInfo}`;

            // Update KPIs with filtered count when filters are active
            const hasFilters = activeFilters.length > 0 || qualityFilters.minQual > 0 || qualityFilters.minDepth > 0;
            updateKPIs(hasFilters ? positions.length : null);

            renderPage();
        }

        async function onFilterConfigChange() {
            if (activeFilters.length > 0) {
                showLoader('Applying filters...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage = 0;
                loadPositions();
                hideLoader();
            }
        }

        function renderPage() {
            const offset = currentPage * getPageSize();
            const html = genomeData.render_filtered(
                JSON.stringify(samples),
                JSON.stringify(positions),
                offset,
                getPageSize()
            );

            document.getElementById('alignment').innerHTML = html;

            // Apply row visibility settings
            applyRowVisibility();

            // Update pagination
            const totalPages = Math.ceil(positions.length / getPageSize());
            document.getElementById('page-info').textContent =
                `Page ${currentPage + 1} of ${totalPages} (${positions.length.toLocaleString()} positions)`;

            document.getElementById('prev-btn').disabled = currentPage === 0;
            document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
        }

        async function nextPage() {
            const totalPages = Math.ceil(positions.length / getPageSize());
            if (currentPage < totalPages - 1) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage++;
                renderPage();
                hideLoader();
            }
        }

        async function prevPage() {
            if (currentPage > 0) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage--;
                renderPage();
                hideLoader();
            }
        }

        async function gotoPosition() {
            const pos = parseInt(document.getElementById('goto-pos').value);
            if (!pos || pos < 1) return;

            showLoader('Finding position...', `Position ${pos}`);
            await new Promise(r => setTimeout(r, 10));

            // Find the page containing this position
            const idx = positions.findIndex(p => p >= pos);
            if (idx >= 0) {
                currentPage = Math.floor(idx / getPageSize());
                renderPage();
                hideLoader();
            } else {
                hideLoader();
                alert('Position not found in current filter');
            }
        }

        function populateMatrixPipelineSelector() {
            const select = document.getElementById('matrix-pipeline');
            if (!select) return;

            select.innerHTML = '';
            for (const p of pipelines) {
                const label = genomeData.get_pipeline_label(p);
                select.innerHTML += `<option value="${p}">${label}</option>`;
            }
        }

        function populateCoverageStats() {
            const container = document.getElementById('coverage-stats-content');
            if (!container) return;

            // Get coverage stats from WASM module
            try {
                const statsJson = genomeData.get_coverage_stats();
                const stats = JSON.parse(statsJson);
                console.log('Coverage stats:', stats);

                if (!stats || Object.keys(stats).length === 0) {
                    container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">Coverage statistics not available in this report.</p>';
                    return;
                }

                // Helper to format min-max (avg)
                const formatRange = (min, max, avg, suffix = '') => {
                    if (min == null || max == null || avg == null) return 'N/A';
                    return `${min.toFixed ? min.toFixed(0) : min}-${max.toFixed ? max.toFixed(0) : max} (${avg.toFixed(1)})${suffix}`;
                };

                const formatPercent = (min, max, avg) => {
                    if (min == null || max == null || avg == null) return 'N/A';
                    return `${(min*100).toFixed(0)}-${(max*100).toFixed(0)}% (${(avg*100).toFixed(1)}%)`;
                };

                let html = '<table class="distance-matrix-table" style="font-size:10px;width:100%;">';
                html += '<thead><tr><th>Sample</th>';
                for (const p of pipelines) {
                    const label = genomeData.get_pipeline_label(p);
                    html += `<th>${label}<br><small>SNPs</small></th>`;
                    html += `<th>${label}<br><small>Depth</small></th>`;
                    html += `<th>${label}<br><small>Qual</small></th>`;
                    html += `<th>${label}<br><small>Consensus</small></th>`;
                }
                html += '</tr></thead><tbody>';

                for (const sample of samples) {
                    const sampleLabel = genomeData.get_sample_label(sample);
                    html += `<tr><th>${sampleLabel}</th>`;

                    for (const p of pipelines) {
                        const sampleStats = stats[sample]?.[p] || {};
                        const snpCount = sampleStats.snp_count || 0;

                        // Depth: min-max (avg)
                        const depthStr = formatRange(sampleStats.depth_min, sampleStats.depth_max, sampleStats.depth_avg, 'x');

                        // Qual: min-max (avg)
                        const qualStr = formatRange(sampleStats.qual_min, sampleStats.qual_max, sampleStats.qual_avg);

                        // Consensus: min-max% (avg%)
                        const consStr = formatPercent(sampleStats.consensus_min, sampleStats.consensus_max, sampleStats.consensus_avg);

                        // Color code based on average depth
                        let depthClass = '';
                        if (sampleStats.depth_avg) {
                            if (sampleStats.depth_avg < 10) depthClass = 'high-dist';
                            else if (sampleStats.depth_avg < 20) depthClass = 'medium-dist';
                            else depthClass = 'low-dist';
                        }

                        html += `<td>${snpCount.toLocaleString()}</td>`;
                        html += `<td class="${depthClass}">${depthStr}</td>`;
                        html += `<td>${qualStr}</td>`;
                        html += `<td>${consStr}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody></table>';

                html += '<p style="color:var(--text-secondary);font-size:10px;margin-top:8px;">';
                html += 'Values show min-max (avg). Depth color: <span style="color:var(--snp-consensus);">≥20x</span> | <span style="color:var(--snp-uncertain);">10-20x</span> | <span style="color:var(--snp-discord);">&lt;10x</span>';
                html += '</p>';

                container.innerHTML = html;
            } catch (err) {
                console.error('Error loading coverage stats:', err);
                container.innerHTML = '<p style="color:var(--gap-color);font-size:11px;">Error loading coverage statistics.</p>';
            }
        }

        async function calculateDistanceMatrix() {
            showLoader('Calculating distance matrix...', '');
            // Wait for browser to paint the loader before blocking WASM calculation
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

            const selectedPipeline = document.getElementById('matrix-pipeline')?.value || '';
            const selectedMode = document.getElementById('matrix-mode')?.value || 'vcf_ref';
            // Use global quality filters
            const minDepth = parseInt(document.getElementById('min-depth')?.value) || 0;
            const minConsensus = parseInt(document.getElementById('min-consensus')?.value) || 0;
            const minQual = parseFloat(document.getElementById('min-qual')?.value) || 0;

            console.log('Distance matrix params:', { selectedPipeline, selectedMode, minDepth, minConsensus, minQual });

            try {
                const resultJson = genomeData.calculate_distance_matrix_filtered(
                    selectedPipeline, selectedMode, minDepth, minConsensus, minQual
                );
                console.log('Distance matrix result:', JSON.parse(resultJson));
                const result = JSON.parse(resultJson);

                if (!result.samples || result.samples.length === 0) {
                    document.getElementById('matrix-result').innerHTML = `
                        <p style="color:var(--gap-color);">No distance matrix data available.
                        Make sure the report was generated with BAM files for polymorphic site data.</p>
                    `;
                    hideLoader();
                    return;
                }

                const n = result.samples.length;
                const labels = result.labels || result.samples;

                // Find max distance for color scaling
                let maxDist = 0;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== j && result.matrix[i][j] > maxDist) {
                            maxDist = result.matrix[i][j];
                        }
                    }
                }

                // Build table HTML
                const pipelineLabel = result.pipeline ? genomeData.get_pipeline_label(result.pipeline) : 'Unknown';
                const modeLabels = {
                    'vcf_ref': 'VCF + Reference',
                    'vcf_bam': 'VCF + BAM pileup',
                    'bam_only': 'BAM only'
                };
                const modeLabel = modeLabels[result.mode] || result.mode;
                let filtersInfo = `depth≥${result.min_depth}`;
                if (result.min_qual > 0) filtersInfo += `, qual≥${result.min_qual}`;
                let html = `<div style="margin:10px 0;color:var(--text-secondary);font-size:11px;">
                    <strong>${pipelineLabel}</strong> (${modeLabel}, ${filtersInfo}): ${result.polymorphic_count || 'N/A'} polymorphic sites analyzed.
                    Values show SNP distance (comparable positions in parentheses).
                </div>`;

                html += '<table class="distance-matrix-table"><thead><tr><th></th>';
                for (const label of labels) {
                    html += `<th>${label}</th>`;
                }
                html += '</tr></thead><tbody>';

                for (let i = 0; i < n; i++) {
                    html += `<tr><th>${labels[i]}</th>`;
                    for (let j = 0; j < n; j++) {
                        if (i === j) {
                            html += '<td class="diagonal">-</td>';
                        } else {
                            const dist = result.matrix[i][j];
                            const comp = result.comparable[i][j];

                            // Color based on distance
                            let cellClass = 'low-dist';
                            if (maxDist > 0) {
                                const ratio = dist / maxDist;
                                if (ratio > 0.6) cellClass = 'high-dist';
                                else if (ratio > 0.2) cellClass = 'medium-dist';
                            }

                            html += `<td class="${cellClass}">${dist}<span class="comparable">(${comp})</span></td>`;
                        }
                    }
                    html += '</tr>';
                }

                html += '</tbody></table>';

                // Update info badge
                document.getElementById('matrix-info').textContent = `(${n} samples)`;
                document.getElementById('matrix-result').innerHTML = html;

            } catch (err) {
                console.error('Distance matrix calculation failed:', err);
                document.getElementById('matrix-result').innerHTML = `
                    <p style="color:var(--gap-color);">Error calculating distance matrix: ${err}</p>
                `;
            }

            hideLoader();
        }

        function drawGenomeOverview() {
            const canvas = document.getElementById('genome-canvas');
            const ctx = canvas.getContext('2d');
            const refLen = genomeData.get_ref_length();

            // Get theme colors from CSS variables
            const styles = getComputedStyle(document.documentElement);
            const bgPrimary = styles.getPropertyValue('--bg-primary').trim() || '#1e1e1e';
            const bgSecondary = styles.getPropertyValue('--bg-secondary').trim() || '#252526';
            const bgTertiary = styles.getPropertyValue('--bg-tertiary').trim() || '#3c3c3c';
            const textSecondary = styles.getPropertyValue('--text-secondary').trim() || '#808080';

            // Calculate dimensions
            const trackHeight = 28;
            const trackSpacing = 10;
            const height = (pipelines.length + 1) * (trackHeight + trackSpacing);
            const width = canvas.parentElement.clientWidth - 8; // Full container width minus padding

            // Set canvas size properly (set dimensions before scaling)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Clear canvas
            ctx.fillStyle = bgPrimary;
            ctx.fillRect(0, 0, width, height);

            // Draw reference bar
            ctx.fillStyle = bgTertiary;
            ctx.fillRect(0, 0, width, trackHeight);

            // Draw pipeline tracks
            const kpis = JSON.parse(genomeData.get_kpis());

            // SNP and Gap colors matching legend
            const snpColor = '#4ec9b0';  // Teal for SNPs
            const gapColor = 'rgba(244, 71, 71, 0.7)';  // Red for gaps

            pipelines.forEach((pipeline, idx) => {
                const y = (idx + 1) * (trackHeight + trackSpacing);

                // Draw track background
                ctx.fillStyle = bgSecondary;
                ctx.fillRect(0, y, width, trackHeight);

                // Draw pipeline label
                ctx.fillStyle = textSecondary;
                ctx.font = '9px monospace';
                const label = genomeData.get_pipeline_label(pipeline);
                ctx.fillText(label.substring(0, 15), 5, y + trackHeight / 2 + 3);

                // Draw SNP density (simplified - using bins)
                const binCount = Math.min(width, 500);
                const binSize = refLen / binCount;
                const snpBins = new Uint32Array(binCount);
                const gapBins = new Uint32Array(binCount);

                // Collect data from all samples for this pipeline
                for (const sample of samples) {
                    // Get SNP positions for this sample/pipeline
                    const allPositions = JSON.parse(
                        genomeData.get_filtered_positions_v2(
                            JSON.stringify([sample]),
                            pipeline,
                            'and',
                            'any'
                        )
                    );
                    for (const pos of allPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            snpBins[bin]++;
                        }
                    }

                    // Get gap positions
                    const gapPositions = JSON.parse(
                        genomeData.get_filtered_positions_v2(
                            JSON.stringify([sample]),
                            `gaps:${pipeline}`,
                            'and',
                            'any'
                        )
                    );
                    for (const pos of gapPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            gapBins[bin]++;
                        }
                    }
                }

                // Find max for normalization
                const maxSnp = Math.max(...snpBins, 1);
                const maxGap = Math.max(...gapBins, 1);

                // Draw gaps (red, bottom half)
                ctx.fillStyle = gapColor;
                for (let i = 0; i < binCount; i++) {
                    if (gapBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (gapBins[i] / maxGap) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + trackHeight - h, width / binCount + 1, h);
                    }
                }

                // Draw SNPs (teal, top half)
                ctx.fillStyle = snpColor;
                for (let i = 0; i < binCount; i++) {
                    if (snpBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (snpBins[i] / maxSnp) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + 1, width / binCount + 1, h);
                    }
                }
            });

            // Draw genome ruler
            ctx.fillStyle = textSecondary;
            ctx.font = '9px monospace';
            const tickInterval = Math.pow(10, Math.floor(Math.log10(refLen)) - 1) * 5;
            for (let pos = 0; pos <= refLen; pos += tickInterval) {
                const x = (pos / refLen) * width;
                ctx.fillRect(x, 0, 1, 5);
                if (pos > 0 && pos < refLen) {
                    const label = (pos / 1000000).toFixed(1) + 'M';
                    ctx.fillText(label, x - 10, 12);
                }
            }

            // Update genome info
            document.getElementById('genome-info').textContent = `(${(refLen / 1000000).toFixed(2)} Mbp)`;

            // Click handler to navigate
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const pos = Math.floor((x / rect.width) * refLen) + 1;
                document.getElementById('goto-pos').value = pos;
                gotoPosition();
            };
        }

        main();
    </script>
</body>
</html>
