<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGuard SNP Comparison Viewer</title>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #3c3c3c;
            --text-primary: #d4d4d4;
            --text-secondary: #808080;
            --text-muted: #555;
            --border-color: #3c3c3c;
            --accent: #569cd6;
            --accent-hover: #1177bb;
            --btn-bg: #3c3c3c;
            --btn-border: #555;
            --label-color: #9cdcfe;
            --ref-color: #6a9955;
            --snp-consensus: #4ec9b0;
            --snp-consensus-bg: rgba(78, 201, 176, 0.2);
            --snp-uncertain: #dcdcaa;
            --snp-uncertain-bg: rgba(220, 220, 170, 0.2);
            --snp-discord: #f44747;
            --snp-discord-bg: rgba(244, 71, 71, 0.2);
            --snp-pipeline: #ce9178;
            --snp-pipeline-bg: rgba(206, 145, 120, 0.2);
            --snp-vcf: #569cd6;
            --snp-vcf-bg: rgba(86, 156, 214, 0.2);
            --snp-bam: #b5cea8;
            --snp-bam-bg: rgba(181, 206, 168, 0.2);
            --gap-color: #f44747;
            --gap-bg: rgba(244, 71, 71, 0.1);
        }
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #cccccc;
            --accent: #0066cc;
            --accent-hover: #0055aa;
            --btn-bg: #e8e8e8;
            --btn-border: #cccccc;
            --label-color: #0066cc;
            --ref-color: #228b22;
            --snp-consensus: #008080;
            --snp-consensus-bg: rgba(0, 128, 128, 0.15);
            --snp-uncertain: #b8860b;
            --snp-uncertain-bg: rgba(184, 134, 11, 0.15);
            --snp-discord: #cc0000;
            --snp-discord-bg: rgba(204, 0, 0, 0.15);
            --snp-pipeline: #8b4513;
            --snp-pipeline-bg: rgba(139, 69, 19, 0.15);
            --snp-vcf: #0066cc;
            --snp-vcf-bg: rgba(0, 102, 204, 0.15);
            --snp-bam: #228b22;
            --snp-bam-bg: rgba(34, 139, 34, 0.15);
            --gap-color: #cc0000;
            --gap-bg: rgba(204, 0, 0, 0.1);
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s, color 0.3s;
        }
        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            color: var(--accent);
        }
        .header .info {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .theme-toggle {
            position: relative;
            width: 44px;
            height: 22px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.3s ease;
            padding: 0;
        }
        .theme-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: transform 0.3s ease, background 0.3s ease;
        }
        .theme-toggle.light::after {
            transform: translateX(22px);
            background: #ffc107;
        }
        .theme-toggle:hover {
            border-color: var(--accent-color);
        }
        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            margin: 40px;
            padding: 40px;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(86, 156, 214, 0.1);
        }
        .drop-zone h2 {
            color: var(--text-secondary);
            font-weight: normal;
            margin: 0 0 10px 0;
        }
        .loader-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        [data-theme="light"] .loader-overlay {
            background: rgba(255,255,255,0.9);
        }
        .loader-overlay.active {
            display: flex;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loader-text {
            margin-top: 20px;
            color: var(--text-primary);
            font-size: 14px;
        }
        .loader-progress {
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        /* Skeleton loading styles */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: skeleton-pulse 1.5s ease-in-out infinite;
            border-radius: 4px;
        }
        @keyframes skeleton-pulse {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .skeleton-text {
            height: 12px;
            margin: 8px 0;
        }
        .skeleton-box {
            height: 80px;
            margin: 10px 0;
        }
        .section-loading {
            padding: 15px;
            text-align: center;
            color: var(--text-muted);
            font-size: 11px;
        }
        .section-loading .mini-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        .drop-zone p {
            color: var(--text-muted);
            margin: 5px 0;
        }
        .drop-zone .or {
            margin: 20px 0;
            color: var(--text-muted);
        }
        .drop-zone button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .drop-zone button:hover {
            background: var(--accent-hover);
        }
        .hidden {
            display: none !important;
        }
        .main-content {
            padding: 5px 0;
            max-width: 100%;
            width: 100%;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .kpis {
            margin-top: 8px;
        }
        .kpi {
            background: var(--bg-secondary);
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .kpi-section {
            margin-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        .kpi-section:first-child {
            margin-top: 0;
            border-top: none;
        }
        .kpi-section > summary {
            width: 100%;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-secondary);
            text-transform: uppercase;
            padding: 8px 0 4px 0;
            letter-spacing: 0.5px;
            cursor: pointer;
            list-style: none;
        }
        .kpi-section > summary::-webkit-details-marker { display: none; }
        .kpi-section > summary::before {
            content: '▶';
            display: inline-block;
            margin-right: 6px;
            font-size: 8px;
            transition: transform 0.15s;
        }
        .kpi-section[open] > summary::before {
            transform: rotate(90deg);
        }
        .kpi-section-content {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 4px;
        }
        .kpi-section-content > table,
        .kpi-section-content > .kpi-sub-label,
        .kpi-section-content > div[style] {
            width: 100%;
        }
        .kpi-sub-label {
            width: 100%;
            font-size: 10px;
            color: var(--text-secondary);
            padding: 6px 0 2px 0;
            opacity: 0.7;
        }
        .kpi-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin: 8px 0;
        }
        .kpi-table th, .kpi-table td {
            padding: 6px 10px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }
        .kpi-table th {
            font-size: 10px;
            font-weight: normal;
            color: var(--text-secondary);
            text-transform: uppercase;
            background: var(--bg-secondary);
        }
        .kpi-table th:first-child, .kpi-table td:first-child {
            text-align: left;
        }
        .kpi-table td:first-child {
            font-weight: 500;
            color: var(--text-primary);
        }
        .kpi-table td {
            color: var(--snp-consensus);
        }
        .kpi-table tr:hover {
            background: var(--bg-secondary);
        }
        .kpi-table .pct {
            font-size: 10px;
            color: var(--text-secondary);
            margin-left: 4px;
        }
        .kpi-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .kpi-table .info-icon:hover {
            opacity: 1;
        }
        .kpi.kpi-gt {
            border-color: #7cb342;
        }
        .kpi .label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .kpi .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 12px;
            transition: opacity 0.2s;
        }
        .kpi .info-icon:hover {
            opacity: 1;
        }
        .kpi .value {
            font-size: 18px;
            color: var(--snp-consensus);
            font-weight: bold;
        }
        /* Info Modal */
        .info-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .info-modal.active {
            display: flex;
        }
        .info-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .info-modal-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .info-modal-content p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            font-size: 13px;
            line-height: 1.5;
        }
        .info-modal-content .formula {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        .info-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        .info-modal-close:hover {
            color: var(--text-primary);
        }
        /* Scroll to top button */
        .scroll-top-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 45px;
            height: 45px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: opacity 0.3s, transform 0.3s;
        }
        .scroll-top-btn:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }
        .scroll-top-btn.visible {
            display: flex;
        }
        /* Per-sample statistics table */
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 10px;
        }
        .stats-table th, .stats-table td {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            text-align: right;
        }
        .stats-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
        }
        .stats-table th:first-child, .stats-table td:first-child {
            text-align: left;
            font-weight: bold;
            color: var(--label-color);
        }
        .stats-table tr:hover {
            background: var(--bg-tertiary);
        }
        .stats-table .pipeline-header {
            background: var(--bg-secondary);
            color: var(--accent);
        }
        .stats-table .good { color: #81c784; }
        .stats-table .warning { color: #ffd54f; }
        .stats-table .bad { color: #e57373; }
        .stats-table .info-icon {
            cursor: pointer;
            opacity: 0.5;
            font-size: 11px;
            margin-left: 3px;
        }
        .stats-table .info-icon:hover {
            opacity: 1;
        }
        .filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.02);
            border-color: var(--accent);
        }
        .filter-btn:active {
            transform: scale(0.98);
        }
        .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent-hover);
            color: white;
            box-shadow: 0 0 8px var(--accent), inset 0 0 4px rgba(255,255,255,0.3);
            font-weight: bold;
            transform: scale(1.05);
        }
        .filter-btn.active::before {
            content: "✓ ";
        }
        .filter-btn.gap-filter {
            color: var(--gap-color);
        }
        .filter-btn.gap-filter.active {
            background: #8b0000;
            border-color: var(--gap-color);
            color: white;
            box-shadow: 0 0 8px var(--gap-color);
            font-weight: bold;
            transform: scale(1.05);
        }
        .nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .nav-controls input {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 10px;
            border-radius: 4px;
            width: 100px;
            font-family: inherit;
        }
        .nav-controls button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .nav-controls button:hover {
            background: var(--bg-tertiary);
        }
        .alignment-view {
            font-size: 11px;
            line-height: 1.1;
            overflow-x: auto;
            white-space: pre;
            width: 100%;
        }
        .alignment-view .row {
            display: flex;
            width: 100%;
        }
        .alignment-view .row.hidden-row {
            display: none;
        }
        .alignment-view .hide-letters {
            color: transparent !important;
            font-size: 0 !important;
        }
        .alignment-view .lbl {
            display: inline-block;
            width: 70px;
            min-width: 70px;
            color: var(--label-color);
            flex-shrink: 0;
            text-align: right;
            padding-right: 3px;
            font-size: 9px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .alignment-view .ref,
        .alignment-view .sample {
            flex-grow: 1;
            letter-spacing: 0px;
        }
        .alignment-view .lbl.sub {
            color: var(--text-secondary);
            font-style: italic;
        }
        .alignment-view .ref {
            color: var(--ref-color);
        }
        .alignment-view .sample {
            color: var(--text-primary);
        }
        .alignment-view .gap {
            color: var(--gap-color);
            background: var(--gap-bg);
        }
        .alignment-view .dim {
            color: var(--text-muted);
        }
        .alignment-view .snp-consensus {
            color: var(--snp-consensus);
            background: var(--snp-consensus-bg);
            font-weight: bold;
        }
        .alignment-view .snp-uncertain {
            color: var(--snp-uncertain);
            background: var(--snp-uncertain-bg);
        }
        .alignment-view .snp-discord {
            color: var(--snp-discord);
            background: var(--snp-discord-bg);
            font-weight: bold;
        }
        .alignment-view .snp-pipeline {
            color: var(--snp-pipeline);
            background: var(--snp-pipeline-bg);
        }
        .alignment-view .snp-vcf {
            color: var(--snp-vcf);
            background: var(--snp-vcf-bg);
        }
        .alignment-view .snp-bam {
            color: var(--snp-bam);
            background: var(--snp-bam-bg);
        }
        .alignment-view .nuc {
            color: var(--text-primary);
        }
        .alignment-view .pos-num,
        .alignment-view .nuc,
        .alignment-view .gap,
        .alignment-view .dim,
        .alignment-view .snp-consensus,
        .alignment-view .snp-uncertain,
        .alignment-view .snp-discord,
        .alignment-view .snp-pipeline,
        .alignment-view .snp-vcf,
        .alignment-view .snp-bam {
            display: inline-block;
            width: 7px;
            text-align: center;
            font-size: 10px;
            position: relative;
        }
        .alignment-view [data-pos]:hover::after {
            content: attr(data-pos);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            border: 1px solid var(--border-color);
        }
        .alignment-view .pos-num {
            color: var(--text-secondary);
        }
        .block.compact .row {
            margin: 2px 0;
        }
        .collapsible-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            margin: 0 4px 10px 4px;
            font-size: 11px;
        }
        .collapsible-panel summary {
            cursor: pointer;
            color: var(--accent);
            user-select: none;
            font-weight: bold;
            padding: 4px 0;
        }
        .collapsible-panel summary:hover {
            color: var(--text-primary);
        }
        .collapsible-panel summary::marker {
            color: var(--text-secondary);
        }
        .collapsible-panel.nested {
            background: var(--bg-primary);
            margin: 0 0 10px 0;
            padding: 6px 10px;
        }
        .collapsible-panel.nested summary {
            font-size: 12px;
            color: var(--label-color);
        }
        #visibility-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }
        .vis-group {
            background: var(--bg-primary);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .vis-group-title {
            color: var(--label-color);
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 10px;
        }
        .vis-item {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 2px 0;
        }
        .vis-item input {
            cursor: pointer;
        }
        .vis-item label {
            cursor: pointer;
            color: var(--text-primary);
            font-size: 10px;
        }
        .filter-options {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-options select {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        .genome-overview-content {
            margin-top: 8px;
        }
        .genome-legend-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
            justify-content: flex-end;
        }
        .genome-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-primary);
            font-size: 10px;
        }
        .genome-legend-item span {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        #genome-canvas {
            width: 100%;
            display: block;
            cursor: crosshair;
        }
        .footer {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            color: var(--text-secondary);
        }
        .legend-content {
            display: flex;
            gap: 20px;
            padding: 8px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }
        .legend-item span.swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        .legend-item .swatch.consensus { background: var(--snp-consensus-bg); border: 1px solid var(--snp-consensus); }
        .legend-item .swatch.uncertain { background: var(--snp-uncertain-bg); border: 1px solid var(--snp-uncertain); }
        .legend-item .swatch.discord { background: var(--snp-discord-bg); border: 1px solid var(--snp-discord); }
        .legend-item .swatch.vcf { background: var(--snp-vcf-bg); border: 1px solid var(--snp-vcf); }
        .legend-item .swatch.bam { background: var(--snp-bam-bg); border: 1px solid var(--snp-bam); }
        .legend-item .swatch.gap { background: var(--gap-bg); border: 1px solid var(--gap-color); }
        .quality-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .quality-filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quality-filter-item label {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .quality-filter-item input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        .quality-filter-item input[type="number"] {
            width: 60px;
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 11px;
        }
        .quality-filter-item .value-display {
            min-width: 35px;
            color: var(--accent);
            font-size: 11px;
        }
        .warnings-container {
            margin-top: 10px;
        }
        .warning-item {
            background: rgba(220, 180, 50, 0.15);
            border: 1px solid #dcb432;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 6px;
            color: #dcb432;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .warning-item::before {
            content: "⚠";
            font-size: 14px;
        }
        .mnp-warning {
            cursor: pointer;
            margin-left: 4px;
            font-size: 12px;
        }
        .description-content {
            font-size: 12px;
            line-height: 1.6;
            color: var(--text-primary);
        }
        .description-content h1 { font-size: 18px; margin: 0 0 12px 0; color: var(--accent); }
        .description-content h2 { font-size: 15px; margin: 16px 0 8px 0; color: var(--accent); }
        .description-content h3 { font-size: 13px; margin: 12px 0 6px 0; color: var(--text-primary); }
        .description-content p { margin: 8px 0; }
        .description-content ul, .description-content ol { margin: 8px 0; padding-left: 24px; }
        .description-content li { margin: 4px 0; }
        .description-content code { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; font-size: 11px; }
        .description-content pre { background: var(--bg-tertiary); padding: 12px; border-radius: 4px; overflow-x: auto; }
        .description-content pre code { background: none; padding: 0; }
        .description-content strong { color: var(--text-primary); }
        .description-content em { font-style: italic; }
        .description-content a { color: var(--accent); }
        .pipeline-info-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 8px;
        }
        .pipeline-info-item .pipeline-name {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .pipeline-info-item .pipeline-command {
            font-family: monospace;
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .pipeline-info-item .pipeline-badge {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            background: var(--accent-color);
            color: white;
        }
        .repro-section {
            margin-bottom: 15px;
        }
        .repro-section h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 12px;
        }
        .repro-cmd {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 6px;
        }
        .repro-cmd code {
            flex: 1;
            font-family: monospace;
            font-size: 10px;
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre;
            color: var(--text-secondary);
        }
        .repro-cmd button {
            padding: 4px 8px;
            font-size: 10px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .repro-cmd button:hover {
            opacity: 0.8;
        }
        .repro-note {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            font-style: italic;
        }
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }
        .pagination button {
            background: var(--btn-bg);
            color: var(--text-primary);
            border: 1px solid var(--btn-border);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
        }
        .pagination button:hover {
            background: var(--bg-tertiary);
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 10px 0;
        }
        #file-input {
            display: none;
        }
        .distance-matrix-table {
            margin-top: 10px;
            font-size: 10px;
            border-collapse: collapse;
            width: 100%;
        }
        .table-wrapper {
            overflow-x: auto;
            width: 100%;
        }
        .distance-matrix-table th,
        .distance-matrix-table td {
            padding: 4px 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            white-space: nowrap;
        }
        .distance-matrix-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: bold;
        }
        .distance-matrix-table td.diagonal {
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        .distance-matrix-table td.low-dist {
            background: rgba(78, 201, 176, 0.2);
            color: var(--snp-consensus);
        }
        .distance-matrix-table td.medium-dist {
            background: rgba(220, 220, 170, 0.2);
            color: var(--snp-uncertain);
        }
        .distance-matrix-table td.high-dist {
            background: rgba(244, 71, 71, 0.2);
            color: var(--snp-discord);
        }
        .distance-matrix-table td .comparable {
            font-size: 8px;
            color: var(--text-muted);
            display: block;
        }
    </style>
</head>
<body>
    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-text">Loading...</div>
        <div class="loader-progress" id="loader-progress"></div>
    </div>

    <!-- Scroll to top button -->
    <button class="scroll-top-btn" id="scroll-top-btn" onclick="scrollToTop()" title="Scroll to top">↑</button>

    <!-- Info Modal -->
    <div class="info-modal" id="info-modal" onclick="if(event.target===this)closeInfoModal()">
        <div class="info-modal-content">
            <button class="info-modal-close" onclick="closeInfoModal()">&times;</button>
            <h3 id="info-modal-title">KPI Info</h3>
            <div id="info-modal-body"></div>
        </div>
    </div>

    <div class="header">
        <h1>CoreGuard SNP Comparison Viewer</h1>
        <div class="header-right">
            <div class="info" id="header-info">Drop a report to begin (.json, .json.gz, .bin, .bin.gz)</div>
            <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark mode"></button>
        </div>
    </div>

    <div id="drop-zone" class="drop-zone">
        <div style="max-width: 700px; text-align: left;">
            <h2 style="text-align: center; margin-bottom: 1.5rem;">SNP Pipeline Comparison Viewer</h2>

            <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">1. Generate a report</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0; color: var(--text-secondary);">Create a YAML config with your VCF/BAM files, then run:</p>
                    <code style="display: block; background: var(--bg-primary); padding: 8px 12px; border-radius: 4px; font-size: 11px; overflow-x: auto;">coreguard compare --config project.yaml -o report.bin.gz --binary --gzip</code>
                </div>
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent);">
                    <div style="color: var(--accent); font-weight: bold; margin-bottom: 0.5rem;">2. Upload and visualize</div>
                    <p style="font-size: 12px; margin: 0 0 0.5rem 0; color: var(--text-secondary);">Drop your report file here or click to browse:</p>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button onclick="document.getElementById('file-input').click()" style="flex: 1;">Choose File</button>
                        <span style="font-size: 11px; color: var(--text-muted);">.json .json.gz .bin .bin.gz</span>
                    </div>
                </div>
            </div>

            <input type="file" id="file-input" accept=".json,.json.gz,.bin,.bin.gz,.gz" style="display: none;" />

            <div style="padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <div style="text-align: center; margin-bottom: 1rem;">
                    <p style="font-size: 12px; color: var(--text-secondary); margin: 0 0 0.75rem 0;">Or try the demo dataset:</p>
                    <button onclick="loadDemo()" style="background: #455a64; font-size: 13px; padding: 10px 20px;">Load Demo</button>
                    <p style="font-size: 11px; opacity: 0.7; margin-top: 8px;">4 <i>Listeria monocytogenes</i> samples &bull; Snippy vs CFSAN vs Ground Truth (minimap2)</p>
                </div>
                <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem;">
                    <p style="font-size: 10px; color: var(--accent); margin: 0 0 0.5rem 0; font-weight: bold;">Demo YAML config:</p>
                    <pre style="background: var(--bg-primary); padding: 8px; border-radius: 4px; font-size: 9px; overflow-x: auto; line-height: 1.3; white-space: pre; margin: 0;">description: testdata/demo_description.md

reference:
  path: reference/AL591824.1.fasta
  label: "Listeria monocytogenes EGD-e"

samples:
  TE15676: { label: "15676" }
  TE15677: { label: "15677" }
  TE15678: { label: "15678" }
  TE8064:  { label: "8064" }

pipelines:
  mm2:
    label: "Ground Truth"
    ground_truth: true
    samples:
      TE15676: { bam: mm2_bams/TE15676.bam }
      TE15677: { bam: mm2_bams/TE15677.bam }
      TE15678: { bam: mm2_bams/TE15678.bam }
      TE8064:  { bam: mm2_bams/TE8064.bam }

  snippy:
    label: "Snippy"
    command: "snippy --ref ref.fa --R1 r1.fq.gz --R2 r2.fq.gz"
    distance_matrix: snippy_distance_matrix.tsv
    samples:
      TE15676: { vcf: TE15676_snippy.vcf, bam: TE15676_snippy.bam }
      TE15677: { vcf: TE15677_snippy.vcf, bam: TE15677_snippy.bam }
      TE15678: { vcf: TE15678_snippy.vcf, bam: TE15678_snippy.bam }
      TE8064:  { vcf: TE8064_snippy.vcf,  bam: TE8064_snippy.bam }

  cfsan:
    label: "CFSAN"
    command: "cfsan_snp_pipeline run -s samples/ -o out/ ref.fa"
    distance_matrix: cfsan_distance_matrix.tsv
    samples:
      TE15676: { vcf: cfsan/TE15676/var.flt.vcf, bam: cfsan/TE15676/reads.sorted.bam }
      TE15677: { vcf: cfsan/TE15677/var.flt.vcf, bam: cfsan/TE15677/reads.sorted.bam }
      TE15678: { vcf: cfsan/TE15678/var.flt.vcf, bam: cfsan/TE15678/reads.sorted.bam }
      TE8064:  { vcf: cfsan/TE8064/var.flt.vcf,  bam: cfsan/TE8064/reads.sorted.bam }</pre>
                </div>
            </div>
        </div>

        <div style="margin-top: 1.5rem; opacity: 0.6;">
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none;" title="View on GitHub">
                <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <div id="viewer" class="main-content hidden">
        <details class="collapsible-panel" id="description-panel" style="display:none;">
            <summary>Description</summary>
            <div id="description-view" class="description-content"></div>
        </details>

        <details class="collapsible-panel" id="pipelines-panel" open>
            <summary>Pipelines</summary>
            <div id="pipelines-info">
                <p style="color:var(--text-secondary);font-size:11px;">Pipeline information will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Statistics</summary>
            <div class="kpis" id="kpis"></div>
            <div class="warnings-container" id="warnings"></div>
        </details>

        <details class="collapsible-panel" id="per-sample-panel" open>
            <summary>Per-Sample Statistics</summary>
            <div id="per-sample-stats" style="overflow-x:auto;">
                <p style="color:var(--text-secondary);font-size:11px;">Per-sample statistics will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" id="coverage-panel">
            <summary>Coverage Statistics</summary>
            <div id="coverage-stats-content">
                <p style="color:var(--text-secondary);font-size:11px;">Coverage statistics will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel" id="reproducibility-panel">
            <summary>Reproducibility Commands</summary>
            <div id="reproducibility-content">
                <p style="color:var(--text-secondary);font-size:11px;">Verification commands will be shown here after loading data.</p>
            </div>
        </details>

        <details class="collapsible-panel">
            <summary>Quality Filters</summary>
            <div class="quality-filters">
                <div class="quality-filter-item">
                    <label for="min-qual">Min QUAL:</label>
                    <input type="number" id="min-qual" min="0" max="10000" value="0" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <label for="min-depth">Min Depth:</label>
                    <input type="number" id="min-depth" min="0" max="1000" value="0" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <label for="min-consensus">Min Consensus %:</label>
                    <input type="number" id="min-consensus" min="50" max="100" value="50" step="1" onchange="updateQualityFilter()" style="width:70px;">
                </div>
                <div class="quality-filter-item">
                    <button onclick="resetQualityFilters()">Reset</button>
                </div>
            </div>
            <p style="margin:8px 0 0 0;color:var(--text-secondary);font-size:10px;">
                <strong>Distance Matrix:</strong> Filters apply per-position. Min Depth filters all sources with depth data. Min QUAL filters VCF sources only. Min Consensus filters BAM sources only.<br>
                <strong>Note:</strong> QUAL works for Snippy (CFSAN uses "."). Depth/consensus available for BAM sources.
            </p>
            <div class="quality-stats" id="quality-stats" style="margin-top:8px;color:var(--text-secondary);font-size:10px;"></div>
        </details>

        <details class="collapsible-panel" id="distance-matrix-panel">
            <summary>SNP Distance Matrix <span id="matrix-info"></span></summary>
            <div class="distance-matrix-content" id="distance-matrix-content">
                <div style="display:flex;align-items:center;gap:15px;margin:10px 0;flex-wrap:wrap;">
                    <label style="color:var(--text-secondary);font-size:11px;">Pipeline:
                        <select id="matrix-pipeline" onchange="onMatrixPipelineChange()" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                        </select>
                    </label>
                    <label style="color:var(--text-secondary);font-size:11px;">Source:
                        <select id="matrix-source" onchange="onMatrixSourceChange()" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                            <option value="coreguard">CoreGuard (calculated)</option>
                        </select>
                    </label>
                    <label id="matrix-mode-label" style="color:var(--text-secondary);font-size:11px;">Mode:
                        <select id="matrix-mode" style="margin-left:5px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);padding:4px 8px;border-radius:4px;font-size:11px;">
                            <option value="vcf_ref">VCF + Reference</option>
                            <option value="vcf_bam">VCF + BAM pileup</option>
                            <option value="bam_only">BAM only</option>
                        </select>
                    </label>
                </div>
                <div id="matrix-calculate-row" style="display:flex;align-items:center;gap:15px;margin:10px 0;flex-wrap:wrap;">
                    <button onclick="calculateDistanceMatrix()" style="padding:8px 16px;background:var(--accent);color:white;border:none;border-radius:4px;cursor:pointer;">Calculate</button>
                    <span style="color:var(--text-secondary);font-size:11px;">(Uses global quality filters above)</span>
                </div>
                <p style="color:var(--text-secondary);font-size:11px;margin:5px 0;">
                    <strong>VCF + Reference:</strong> Uses VCF calls where available, reference allele otherwise (matches Snippy-core).<br>
                    <strong>VCF + BAM:</strong> Uses VCF calls where available, BAM pileup otherwise.<br>
                    <strong>BAM only:</strong> Uses only BAM pileup bases, ignoring VCF calls (most accurate for real differences).
                </p>
                <div id="matrix-result"></div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Genome Overview <span id="genome-info"></span></summary>
            <div class="genome-overview-content">
                <div class="genome-legend-bar">
                    <span class="genome-legend-item"><span style="background:#4ec9b0;"></span> SNPs (top)</span>
                    <span class="genome-legend-item"><span style="background:rgba(244, 71, 71, 0.7);"></span> Gaps (bottom)</span>
                </div>
                <canvas id="genome-canvas" height="100"></canvas>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>View Settings</summary>

            <details class="collapsible-panel nested" open>
                <summary>Row Visibility</summary>
                <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;margin-top:8px;">
                    <input type="text" id="visibility-filter" placeholder="Filter rows..." style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;width:150px;" oninput="filterVisibilityCheckboxes(this.value)">
                    <button onclick="setAllRowVisibility(true)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Select All</button>
                    <button onclick="setAllRowVisibility(false)" style="padding:4px 8px;background:var(--btn-bg);color:var(--text-primary);border:1px solid var(--btn-border);border-radius:4px;font-size:11px;cursor:pointer;">Deselect All</button>
                </div>
                <div id="visibility-controls"></div>
            </details>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;margin-bottom:15px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Nucleotide Display</strong>
                <div style="display:flex;gap:15px;flex-wrap:wrap;">
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-nucleotide-letters" checked onchange="toggleNucleotideLetters(this.checked)">
                        Show base letters (A, C, G, T)
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-ref-row" checked onchange="toggleRowVisibility('REF', this.checked)">
                        Show reference row
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:11px;color:var(--text-secondary);cursor:pointer;">
                        <input type="checkbox" id="show-pos-row" checked onchange="toggleRowVisibility('Pos', this.checked)">
                        Show position row
                    </label>
                </div>
            </div>

            <div style="border-top:1px solid var(--border-color);padding-top:10px;">
                <strong style="color:var(--label-color);font-size:12px;display:block;margin-bottom:8px;">Legend</strong>
                <div class="legend-content">
                    <div class="legend-item"><span class="swatch consensus"></span> Consensus (all pipelines agree)</div>
                    <div class="legend-item"><span class="swatch uncertain"></span> Uncertain (only one pipeline)</div>
                    <div class="legend-item"><span class="swatch discord"></span> Discordant (pipelines disagree)</div>
                    <div class="legend-item"><span class="swatch vcf"></span> VCF call (from variant caller)</div>
                    <div class="legend-item"><span class="swatch bam"></span> BAM pileup (from reads)</div>
                    <div class="legend-item"><span class="swatch gap"></span> Gap (no coverage)</div>
                </div>
            </div>
        </details>

        <details class="collapsible-panel" open>
            <summary>Filters & Navigation</summary>
            <div class="controls">
                <div class="filters" id="filters">
                    <span style="color:#808080;margin-right:5px;">Filters:</span>
                </div>
                <div class="filter-options">
                    <label title="How to combine multiple filters">
                        <select id="filter-mode" onchange="onFilterConfigChange()">
                            <option value="and">AND (all filters)</option>
                            <option value="or">OR (any filter)</option>
                        </select>
                    </label>
                    <label title="How to match across samples">
                        <select id="sample-mode" onchange="onFilterConfigChange()">
                            <option value="any">Any sample</option>
                            <option value="all">All samples</option>
                        </select>
                    </label>
                </div>
                <div class="nav-controls">
                    <span style="color:#808080;">Go to:</span>
                    <input type="number" id="goto-pos" placeholder="Position" min="1" />
                    <button onclick="gotoPosition()">Go</button>
                </div>
            </div>
            <details class="collapsible-panel nested" style="margin-top:10px;">
                <summary>Filter Legend</summary>
                <div class="filter-legend" style="font-size:11px;color:var(--text-secondary);line-height:1.6;">
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">SNP Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline Name]</strong>: Show positions where this pipeline called a SNP (variant different from reference)
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Consensus</strong>: Show positions where <em>all selected VCF pipelines called a SNP</em> and they all agree<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: Select pipeline buttons first to compare only those (e.g., Snippy + CFSAN)</span>
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <strong>Discordant</strong>: Show positions where <em>selected pipelines called different SNPs</em> (they disagree)<br>
                        <span style="color:var(--text-muted);font-size:10px;margin-left:10px;">Tip: If no pipelines selected, uses all VCF pipelines</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Gap Filters (per pipeline)</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>[Pipeline] Gaps</strong>: Show positions where this pipeline has no read coverage (gap)
                    </div>
                    <div style="margin-left:10px;margin-bottom:10px;">
                        <span style="color:var(--text-muted);font-size:10px;">If a pipeline is marked as "ground truth", its gaps indicate positions where the baseline has no data</span>
                    </div>
                    <div style="margin-bottom:8px;"><strong style="color:var(--label-color);">Combination Logic</strong></div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>AND</strong>: Position must match <em>all</em> selected filters
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>OR</strong>: Position must match <em>any</em> selected filter
                    </div>
                    <div style="margin-left:10px;margin-bottom:6px;">
                        <strong>Any sample</strong>: Filter matches if at least one sample meets the condition
                    </div>
                    <div style="margin-left:10px;">
                        <strong>All samples</strong>: Filter matches only if all samples meet the condition
                    </div>
                </div>
            </details>
        </details>

        <div class="status" id="status"></div>
        <div class="alignment-view" id="alignment"></div>

        <div class="pagination" id="pagination">
            <button id="prev-btn" onclick="prevPage()" disabled>&larr; Previous</button>
            <span id="page-info">Page 1</span>
            <button id="next-btn" onclick="nextPage()">Next &rarr;</button>
        </div>

        <div class="footer" id="footer">
            <span onclick="goToLanding()" style="cursor: pointer;" title="Back to home">CoreGuard SNP Comparison Viewer</span>
            <span id="report-timestamp"></span>
            <a href="https://github.com/genpat-it/coreguard" target="_blank" style="color: inherit; text-decoration: none; margin-left: 1rem;" title="View on GitHub">
                <svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
        </div>
    </div>

    <!-- Pako for gzip decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <script>
        // Theme toggling (non-module, runs immediately)
        function initTheme() {
            const savedTheme = localStorage.getItem('coreguard-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : '');
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('coreguard-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('coreguard-theme', newTheme);
            document.documentElement.setAttribute('data-theme', newTheme === 'light' ? 'light' : '');
            updateThemeIcon(newTheme);
            // Redraw canvas with new theme colors
            if (typeof redrawGenomeOverview === 'function') {
                redrawGenomeOverview();
            }
        }

        function updateThemeIcon(theme) {
            const btn = document.getElementById('theme-toggle');
            if (btn) {
                btn.classList.toggle('light', theme === 'light');
                btn.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
            }
        }

        // Initialize theme on page load
        initTheme();

        // KPI Info Modal
        const kpiDescriptions = {
            'reference': {
                title: 'Reference Genome',
                body: `<p>The length of the reference genome in base pairs (bp).</p>
                       <p>All samples are aligned against this reference sequence for SNP calling.</p>`
            },
            'usable_space': {
                title: 'Usable Space',
                body: `<p>The number of reference base pairs <strong>not covered by gaps</strong> in the Ground Truth pipeline.</p>
                       <div class="formula">Usable Space = Reference Length − avg(GT gaps per sample)</div>
                       <p>This represents the effective genome size available for SNP comparison. Regions where the Ground Truth has no coverage (gaps) cannot be used to validate other pipelines.</p>`
            },
            'pw_usable_space': {
                title: 'Avg Pairwise Usable Space',
                body: `<p>Average usable genome space across all sample pairs.</p>
                       <div class="formula">For each pair (A, B): Usable = RefLength − union(GT gaps A, GT gaps B)</div>
                       <p>This considers the GT gaps specific to each pair of samples. The union of gaps from both samples is excluded, giving the effective comparable space for that pair.</p>`
            },
            'pw_usable_snps': {
                title: 'Avg Pairwise Usable SNPs',
                body: `<p>Average number of <strong>discriminating SNPs</strong> per sample pair, excluding unreliable positions.</p>
                       <div class="formula">For each pair (A, B): count positions where A ≠ B, not in GT gaps</div>
                       <p>A position is discriminating if one sample has a SNP and the other doesn't, or both have different alt alleles. Positions in GT gaps (union for the pair) are excluded.</p>
                       <p>This represents the average pairwise distance using only validated, reliable SNP positions.</p>`
            },
            'samples': {
                title: 'Number of Samples',
                body: `<p>Total number of samples (isolates) included in this comparison.</p>`
            },
            'pipelines': {
                title: 'Number of Pipelines',
                body: `<p>Number of different SNP calling pipelines being compared.</p>
                       <p>Each pipeline may use different algorithms, parameters, or reference-based variant calling approaches.</p>`
            },
            'usable_snps': {
                title: 'Usable SNPs',
                body: `<p>SNP positions that are <strong>actually informative</strong> for discriminating between samples.</p>
                       <div class="formula">Usable = Core SNPs − SNPs in GT Gaps − Consensus SNPs (not in GT gaps)</div>
                       <p>Removed positions:</p>
                       <ul>
                           <li><strong>In GT Gaps:</strong> positions where the Ground Truth has no coverage — cannot be validated</li>
                           <li><strong>Consensus:</strong> positions where ALL samples share the same alt allele — these are reference differences, not real variation between samples</li>
                       </ul>
                       <p>The remaining positions represent true inter-sample variation usable for phylogenetics and distance matrices.</p>`
            },
            'snps': {
                title: 'SNP Count',
                body: `<p>Total number of Single Nucleotide Polymorphisms (SNPs) detected by this pipeline across all samples.</p>
                       <div class="formula">% = (SNPs / Reference Length / Samples) × 100</div>
                       <p>The percentage indicates the average SNP density per sample relative to the reference genome.</p>`
            },
            'gaps': {
                title: 'Gap Regions',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) across all samples.</p>
                       <div class="formula">% = (Gap bp / Reference Length / Samples) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants due to low read coverage.</p>
                       <p><strong>High gap percentage</strong> may indicate poor sequencing quality or divergent samples.</p>`
            },
            'snps_in_gt_gaps': {
                title: 'Any SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>at least 1 sample</strong> has a SNP.</p>
                       <div class="formula">% = (Any SNPs in GT Gaps / Any SNPs) × 100</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (&lt;1%)</span>: Good - few SNPs in unreliable regions</li>
                           <li><span style="color:#e57373;">Red (&gt;1%)</span>: Potential false positives in low-coverage regions</li>
                       </ul>`
            },
            'all_snps_in_gt_gaps': {
                title: 'All SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples</strong> have a SNP.</p>
                       <div class="formula">% = (All SNPs in GT Gaps / All SNPs) × 100</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based, any allele)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>These are consistently called SNPs in unreliable regions</li>
                           <li>May indicate systematic differences between pipelines</li>
                       </ul>`
            },
            'consensus_snps_in_gt_gaps': {
                title: 'Consensus SNPs in GT Gaps',
                body: `<p>SNP positions in GT gap regions where <strong>ALL samples have the SAME allele</strong>.</p>
                       <div class="formula">% = (Consensus SNPs in GT Gaps / Consensus SNPs) × 100</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Most reliable variant calls in unreliable regions</li>
                           <li>Consensus SNPs in GT gaps warrant closer inspection</li>
                       </ul>`
            },
            'snps_in_pipeline_gaps': {
                title: 'SNPs in Pipeline Gaps',
                body: `<p>SNPs from one pipeline that fall within gap regions of another pipeline.</p>
                       <div class="formula">% = (SNPs in Gaps / Total SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows SNPs called by one pipeline in regions where another has low coverage</li>
                           <li>High values may indicate false positives or differences in coverage</li>
                           <li>Useful for comparing pipeline reliability across different regions</li>
                       </ul>`
            },
            // Per-Sample Statistics metrics
            'ps_snps': {
                title: 'Per-Sample SNPs',
                body: `<p>Number of SNPs called by this pipeline for this sample.</p>
                       <div class="formula">% = (SNPs / Reference Length) × 100</div>
                       <p>Percentage shows SNP density relative to the reference genome size.</p>`
            },
            'ps_gaps': {
                title: 'Per-Sample Gaps',
                body: `<p>Total base pairs with insufficient coverage (depth < minimum threshold) for this sample.</p>
                       <div class="formula">% = (Gap bp / Reference Length) × 100</div>
                       <p>Gaps indicate regions where the pipeline could not confidently call variants.</p>`
            },
            'ps_vs_gt': {
                title: 'vs GT (Agreement)',
                body: `<p>Pipeline SNPs that are at the same positions as GT SNPs for this sample.</p>
                       <div class="formula">% = (Pipeline ∩ GT SNP positions / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≥90%</span>: Good agreement with ground truth</li>
                           <li><span style="color:#ffc107;">70-90%</span>: Moderate agreement</li>
                           <li><span style="color:#e57373;">&lt;70%</span>: Poor agreement</li>
                       </ul>`
            },
            'ps_in_gt_gaps': {
                title: 'in GT Gaps',
                body: `<p>Pipeline SNPs that fall within GT gap regions (low coverage in GT).</p>
                       <div class="formula">% = (SNPs in GT Gaps / Pipeline SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">≤1%</span>: Good - few SNPs in unreliable GT regions</li>
                           <li><span style="color:#ffc107;">1-5%</span>: Some SNPs in GT gaps</li>
                           <li><span style="color:#e57373;">&gt;5%</span>: Many SNPs in GT gaps - potential false positives</li>
                       </ul>`
            },
            'ps_intersection': {
                title: 'Pipeline ∩ GT Intersection',
                body: `<p>SNP positions where both the pipeline and GT have called a SNP for this sample.</p>
                       <div class="formula">Intersection = |Pipeline SNP positions ∩ GT SNP positions|</div>
                       <div class="formula">% = (Intersection / GT SNPs) × 100</div>
                       <p>Shows what percentage of GT SNPs are also called by the pipeline.</p>`
            },
            'ps_vcf_consensus': {
                title: 'VCF Consensus SNPs',
                body: `<p>SNP positions where ALL VCF pipelines (excluding GT) agree for this sample.</p>
                       <div class="formula">VCF Consensus = ∩ all VCF pipelines</div>
                       <div class="formula">% = (VCF Consensus / Reference Length) × 100</div>
                       <p>These are the most confident variant calls where all VCF-based pipelines agree.</p>`
            },
            'ps_consensus_in_gt': {
                title: 'VCF Consensus in GT',
                body: `<p>VCF consensus SNPs that are also present in GT for this sample.</p>
                       <div class="formula">% = (VCF Consensus ∩ GT / VCF Consensus) × 100</div>
                       <p>High percentage means VCF consensus aligns well with ground truth.</p>`
            },
            'ps_all_consensus': {
                title: 'All Consensus (GT ∩ VCF)',
                body: `<p>Positions where ALL pipelines (including GT) agree for this sample.</p>
                       <div class="formula">All Consensus = GT ∩ VCF Consensus</div>
                       <div class="formula">% = (All Consensus / Reference Length) × 100</div>
                       <p>These are the highest confidence calls - all pipelines agree.</p>`
            },
            'gt_snps_missing': {
                title: 'Any GT SNPs Filtered',
                body: `<p>GT SNP positions (≥1 sample) that this pipeline does <strong>NOT</strong> call.</p>
                       <div class="formula">Σ(GT<sub>sample</sub> - (GT<sub>sample</sub> ∩ Pipeline<sub>sample</sub>))</div>
                       <p><strong>Any</strong> = position has SNP in ≥1 sample</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows GT SNPs being "filtered out" by each pipeline</li>
                           <li>Higher values = more aggressive filtering</li>
                       </ul>`
            },
            'all_gt_missing': {
                title: 'All GT SNPs Filtered',
                body: `<p>GT SNP positions (ALL samples) not present in the pipeline.</p>
                       <div class="formula">|All GT| - |All GT ∩ All Pipeline|</div>
                       <p><strong>All</strong> = position has SNP in ALL samples (position-based)</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows consistent GT SNPs missing from pipeline</li>
                           <li>Lower = pipeline captures consistent GT signal</li>
                       </ul>`
            },
            'consensus_gt_missing': {
                title: 'Consensus GT SNPs Filtered',
                body: `<p>GT Consensus positions not present in the pipeline's consensus.</p>
                       <div class="formula">|Consensus GT| - |Consensus GT ∩ Consensus Pipeline|</div>
                       <p><strong>Consensus</strong> = ALL samples have identical alt allele</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows highly reliable GT SNPs missing from pipeline's consensus</li>
                           <li>Lower = pipeline captures consistent variant calls</li>
                       </ul>`
            },
            'gt_pileup': {
                title: 'Ground Truth Pileup SNPs',
                body: `<p>Total SNPs detected directly from BAM pileup analysis <strong>without variant calling filters</strong>.</p>
                       <div class="formula">% = (Pileup SNPs / Reference Length / Samples) × 100</div>
                       <p>This is a raw count of positions where the consensus base from read alignments differs from the reference.</p>
                       <p><strong>Purpose:</strong> Provides a baseline for comparing how many potential variants each pipeline reports vs. the raw signal in the data.</p>`
            },
            'bam_pileup': {
                title: 'BAM Pileup Warning',
                body: `<p>⚠️ <strong>These SNPs were derived from BAM pileup analysis</strong>, not from a variant calling pipeline.</p>
                       <p><strong>What this means:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>No variant calling filters were applied (QUAL, depth, etc.)</li>
                           <li>SNPs are raw differences between reads and reference</li>
                           <li>May include sequencing errors and low-confidence calls</li>
                           <li>Counts are typically higher than filtered VCF pipelines</li>
                       </ul>
                       <p><strong>Use case:</strong> Ground truth baseline for comparing pipeline filtering behavior.</p>`
            },
            'vs_gt': {
                title: 'Pipeline vs Ground Truth',
                body: `<p>Comparison of this pipeline's SNP count against the Ground Truth pileup count.</p>
                       <div class="formula">Difference = Pipeline SNPs - GT Pileup SNPs</div>
                       <div class="formula">% = (Difference / GT Pileup SNPs) × 100</div>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (±5%)</span>: Close to raw signal</li>
                           <li><span style="color:#ffd54f;">Yellow (5-10%)</span>: Moderate filtering/differences</li>
                           <li><span style="color:#e57373;">Red (&gt;10%)</span>: Significant deviation - heavy filtering or artifacts</li>
                       </ul>
                       <p><strong>Negative values:</strong> Pipeline reports fewer SNPs than raw pileup (filtering)</p>
                       <p><strong>Positive values:</strong> Pipeline reports more SNPs (possible artifacts or MNP decomposition)</p>`
            },
            'filtered': {
                title: 'Filtered Positions',
                body: `<p>Number of genomic positions matching the currently active filter criteria.</p>
                       <p>Use filters to focus on specific types of variants (consensus, discordant, pipeline-specific, etc.)</p>`
            },
            'intersection': {
                title: 'SNP Intersection with Ground Truth',
                body: `<p>Number of SNP positions that are <strong>shared</strong> between this pipeline and the Ground Truth.</p>
                       <div class="formula">Intersection = positions where BOTH pipelines call a SNP</div>
                       <p>The two percentages show:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>% GT:</strong> What fraction of GT SNPs are also found by this pipeline (sensitivity/recall)</li>
                           <li><strong>% Pipeline:</strong> What fraction of this pipeline's SNPs are confirmed by GT (precision)</li>
                       </ul>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">Green (≥90%)</span>: High agreement with ground truth</li>
                           <li><span style="color:#ffd54f;">Yellow (70-90%)</span>: Moderate agreement</li>
                           <li><span style="color:#e57373;">Red (&lt;70%)</span>: Low agreement - investigate differences</li>
                       </ul>`
            },
            'concordance': {
                title: 'Position Concordance',
                body: `<p><strong>Concordance</strong> = SNP positions called by BOTH pipelines (regardless of allele).</p>
                       <div class="formula">Concordance = positions where Pipeline A AND Pipeline B call a SNP</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has SNP in both pipelines at this position</li>
                           <li><strong>All:</strong> ALL samples have SNP in both pipelines (Core_A ∩ Core_B)</li>
                       </ul>
                       <p><strong>Note:</strong> Concordance only checks if a SNP exists - it does NOT compare the actual allele called.</p>`
            },
            'consensus': {
                title: 'Allele Consensus',
                body: `<p><strong>Consensus</strong> = SNP positions where BOTH pipelines call the SAME allele.</p>
                       <div class="formula">Consensus = positions where Pipeline A alt == Pipeline B alt</div>
                       <p><strong>Two modes:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Any:</strong> At least 1 sample has the same allele in both pipelines</li>
                           <li><strong>All:</strong> ALL samples have the same allele in both pipelines</li>
                       </ul>
                       <p><strong>Note:</strong> Consensus ≤ Concordance (consensus is a subset where alleles match).</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consensus ≈ Concordance: pipelines agree on alleles</li>
                           <li>Consensus &lt;&lt; Concordance: pipelines find same positions but call different alleles</li>
                       </ul>`
            },
            'consensus_vs_gt': {
                title: 'VCF Consensus vs Ground Truth',
                body: `<p><strong>VCF Consensus</strong> = SNP positions where <strong>ALL VCF pipelines agree</strong> (e.g., CFSAN ∩ Snippy).</p>
                       <p>This metric compares VCF consensus positions with Ground Truth:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Consensus in GT:</strong> How many VCF consensus SNPs are also in GT (precision)</li>
                           <li><strong>GT in Consensus:</strong> How many GT SNPs are in the VCF consensus (sensitivity)</li>
                       </ul>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><span style="color:#81c784;">High % (≥90%)</span>: VCF consensus is well-supported by GT</li>
                           <li><span style="color:#ffd54f;">Moderate % (70-90%)</span>: Some disagreement</li>
                           <li><span style="color:#e57373;">Low % (&lt;70%)</span>: Significant discrepancy</li>
                       </ul>
                       <p><strong>Note:</strong> This does NOT include GT in the consensus calculation - it's VCF pipelines only, then compared to GT.</p>`
            },
            'all_consensus': {
                title: 'All Pipelines Consensus',
                body: `<p><strong>All Consensus</strong> = SNP positions where <strong>ALL pipelines INCLUDING Ground Truth</strong> agree.</p>
                       <div class="formula">All Consensus = GT ∩ Pipeline1 ∩ Pipeline2 ∩ ...</div>
                       <p>These are the "high confidence" SNPs - positions where every pipeline, including the ground truth, calls a variant.</p>
                       <p><strong>Interpretation:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Higher count = more agreement across all methods</li>
                           <li>These SNPs are the most reliable for downstream analysis</li>
                           <li>Can be used as a "gold standard" SNP set</li>
                       </ul>
                       <p><strong>% of Reference:</strong> Indicates the SNP density for the consensus set.</p>`
            },
            'mnp': {
                title: 'MNP Decomposition',
                body: `<p><strong>MNP (Multi-Nucleotide Polymorphism)</strong> = multiple adjacent SNPs reported as a single variant in VCF.</p>
                       <p><strong>Example:</strong></p>
                       <div class="formula">VCF: pos=100, REF=ACG, ALT=TGA</div>
                       <p>This MNP is decomposed into 3 individual SNPs:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>pos=100: A→T</li>
                           <li>pos=101: C→G</li>
                           <li>pos=102: G→A</li>
                       </ul>
                       <p><strong>Why decompose?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Consistent position-level comparison between pipelines</li>
                           <li>Some pipelines report MNPs, others report individual SNPs</li>
                           <li>Enables accurate intersection and agreement calculations</li>
                       </ul>
                       <p><strong>Note:</strong> The total SNP count increases after decomposition, which is expected.</p>`
            },
            'mnps': {
                title: 'MNP Statistics',
                body: `<p><strong>MNPs Detected</strong> = Number of Multi-Nucleotide Polymorphisms found and decomposed into individual SNPs.</p>
                       <div class="formula">Format: X → Y SNPs</div>
                       <p>Where X = number of MNPs found, Y = total individual SNPs they produced.</p>
                       <p><strong>Example:</strong> "50 → 127 SNPs" means 50 MNPs were decomposed into 127 individual SNPs.</p>
                       <p><strong>Why track this?</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Shows pipeline-specific MNP handling</li>
                           <li>Higher MNP count may indicate different variant calling approach</li>
                           <li>Helps understand differences between pipelines</li>
                       </ul>`
            },
            'vcf_consensus': {
                title: 'VCF Pipelines Consensus',
                body: `<p><strong>VCF Consensus</strong> = SNP positions where <strong>ALL VCF pipelines</strong> (excluding Ground Truth) agree.</p>
                       <div class="formula">VCF Consensus = Pipeline1 ∩ Pipeline2 ∩ ...</div>
                       <p>This represents the intersection of all VCF-based pipelines, not including the ground truth BAM-based SNPs.</p>
                       <p><strong>Use:</strong> Identifies positions where different variant callers independently found the same SNP.</p>`
            },
            'filtered': {
                title: 'Filtered Positions',
                body: `<p>Number of positions matching the currently active filters.</p>
                       <p>Use the filter buttons to narrow down positions by:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>Pipeline filters:</strong> Show only SNPs from specific pipelines</li>
                           <li><strong>Consensus:</strong> Show positions where selected pipelines agree</li>
                           <li><strong>Discordant:</strong> Show positions where pipelines disagree</li>
                           <li><strong>Gap filters:</strong> Show gap regions for specific pipelines</li>
                       </ul>`
            },
            'filter_pipeline': {
                title: 'Pipeline SNP Filter',
                body: `<p>Show only positions where this pipeline called a SNP.</p>
                       <p><strong>Multiple pipelines selected:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>OR mode:</strong> Position has SNP in ANY selected pipeline</li>
                           <li><strong>AND mode:</strong> Position has SNP in ALL selected pipelines</li>
                       </ul>
                       <p>Use the mode selector to switch between OR/AND logic.</p>`
            },
            'filter_consensus': {
                title: 'Consensus Filter',
                body: `<p>Show positions where <strong>ALL selected pipelines agree</strong> on having a SNP.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Example:</strong> With CFSAN and Snippy selected, shows positions where both call a SNP at the same position.</p>
                       <p><strong>Note:</strong> This is the intersection of selected pipelines' SNP positions.</p>`
            },
            'filter_discordant': {
                title: 'Discordant Filter',
                body: `<p>Show positions where <strong>pipelines disagree</strong> - at least one has a SNP and at least one doesn't.</p>
                       <p>If no pipeline filters are selected, uses all VCF pipelines.</p>
                       <p><strong>Use case:</strong> Find positions where variant callers give different results, useful for:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Identifying pipeline-specific artifacts</li>
                           <li>Finding borderline/low-confidence variants</li>
                           <li>Quality control and validation</li>
                       </ul>`
            },
            'filter_gaps': {
                title: 'Gap Filter',
                body: `<p>Show positions where this pipeline has a <strong>coverage gap</strong> (depth below threshold).</p>
                       <p>Gaps indicate regions where:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>Read coverage was insufficient for variant calling</li>
                           <li>The sample may be missing this genomic region</li>
                           <li>Sequencing quality was poor in this area</li>
                       </ul>
                       <p><strong>Note:</strong> SNPs called in gap regions of other pipelines may be less reliable.</p>`
            },
            'core_snps': {
                title: 'All SNPs (position-based)',
                body: `<p><strong>All</strong> = SNP positions present in <strong>ALL samples</strong> within this pipeline.</p>
                       <p>Position-based: counts where ALL samples have a SNP, regardless of which allele.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High % = consistent variant calling across samples</li>
                           <li>Low % = many sample-specific variants</li>
                       </ul>
                       <p><strong>Note:</strong> "All" ⊇ "Consensus" (All includes Consensus as a subset)</p>`
            },
            'consensus_snps': {
                title: 'Consensus SNPs',
                body: `<p><strong>Consensus SNPs</strong> = SNP positions where <strong>ALL samples within this pipeline</strong> have the <strong>SAME alt allele</strong>.</p>
                       <p>This is the intersection of SNP positions across all variant callers.</p>
                       <p><strong>Use:</strong></p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li>High consensus % = pipelines mostly agree</li>
                           <li>Low consensus % = pipelines find different variants (method-specific calls)</li>
                       </ul>
                       <p><strong>Note:</strong> The consensus count is the same for all pipelines since it's the intersection.</p>`
            },
            'rpw_usable_space': {
                title: 'Usable Space (Intersection)',
                body: `<p>The number of reference base pairs <strong>not covered by gaps in ALL samples</strong> in the Ground Truth pipeline.</p>
                       <div class="formula">Usable Space = Reference Length − |positions where ALL samples have GT gap|</div>
                       <p>Unlike the union-based Usable Space, this uses the <strong>intersection</strong> of GT gaps: a position is removed only if <em>every</em> sample has a gap there.</p>
                       <p><strong>Interpretation:</strong> This gives a more conservative (larger) usable space estimate, reflecting positions that are at least covered in one sample.</p>`
            },
            'rpw_sample_snps': {
                title: 'Per-Sample Usable SNPs (Intersection)',
                body: `<p>Number of <strong>informative GT SNPs</strong> for each sample after removing unreliable positions.</p>
                       <div class="formula">Usable = GT SNPs for sample − SNPs in that sample's GT gaps − Consensus SNPs outside gaps</div>
                       <p>Removed positions:</p>
                       <ul style="margin:5px 0;padding-left:20px;font-size:12px;">
                           <li><strong>In sample's gaps:</strong> SNPs where this specific sample has a GT coverage gap</li>
                           <li><strong>Consensus outside gaps:</strong> Positions where ALL samples have the same alt allele AND no sample has a gap — these are reference differences, not inter-sample variation</li>
                       </ul>
                       <p>The remaining positions represent true variation for this sample that can be used for phylogenetics.</p>`
            },
            'rpw_discriminating': {
                title: 'Avg Pairwise Discriminating SNPs',
                body: `<p>Average number of <strong>discriminating usable SNPs</strong> across all sample pairs.</p>
                       <div class="formula">For each pair (A, B): count positions in (Usable_A ∩ Usable_B) where A ≠ B</div>
                       <p>A position is discriminating if it is usable in both samples but one has a SNP and the other doesn't (or they have different alleles).</p>
                       <p><strong>Usable per sample</strong> = GT SNPs − in that sample's gap − consensus outside gaps.</p>
                       <p>This represents the average pairwise distance using the intersection-based methodology.</p>`
            }
        };

        function showKpiInfo(kpiType) {
            const info = kpiDescriptions[kpiType];
            if (!info) return;

            document.getElementById('info-modal-title').textContent = info.title;
            document.getElementById('info-modal-body').innerHTML = info.body;
            document.getElementById('info-modal').classList.add('active');
        }

        function closeInfoModal() {
            document.getElementById('info-modal').classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeInfoModal();
        });

        // Scroll to top button
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const btn = document.getElementById('scroll-top-btn');
            if (window.scrollY > 300) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        });
    </script>

    <script>
        // Worker-based architecture for non-blocking UI
        // All heavy WASM operations run in a separate thread

        // Worker API - promise-based interface to the worker
        class WorkerAPI {
            constructor() {
                this.worker = new Worker('./worker.js', { type: 'module' });
                this.pending = new Map();
                this.nextId = 0;
                this.ready = false;
                this.cachedData = {}; // Cache for frequently accessed data

                this.worker.onmessage = (e) => {
                    const { id, success, result, error } = e.data;
                    const resolver = this.pending.get(id);
                    if (resolver) {
                        this.pending.delete(id);
                        if (success) {
                            resolver.resolve(result);
                        } else {
                            resolver.reject(new Error(error));
                        }
                    }
                };
            }

            send(action, payload = {}) {
                return new Promise((resolve, reject) => {
                    const id = this.nextId++;
                    this.pending.set(id, { resolve, reject });
                    this.worker.postMessage({ id, action, payload });
                });
            }

            async init() {
                const result = await this.send('init');
                this.ready = result.success;
                return this.ready;
            }

            async loadBinary(data) {
                const result = await this.send('loadBinary', { data });
                this.cachedData = result; // Cache all the basic info
                return result;
            }

            async loadJson(json) {
                const result = await this.send('loadJson', { json });
                this.cachedData = result;
                return result;
            }

            async getPipelineInfo(pipelineIds) {
                return await this.send('getPipelineInfo', { pipelineIds });
            }

            async getSampleLabel(sampleId) {
                return (await this.send('getSampleLabel', { sampleId })).label;
            }

            async getPipelineLabel(pipelineId) {
                return (await this.send('getPipelineLabel', { pipelineId })).label;
            }

            async getPerSampleStats() {
                return (await this.send('getPerSampleStats')).stats;
            }

            async getCoverageStats() {
                return (await this.send('getCoverageStats')).stats;
            }

            async getFilteredPositions(samples, filterStr, filterMode, sampleMode) {
                return (await this.send('getFilteredPositions', {
                    samples, filterStr, filterMode, sampleMode
                })).positions;
            }

            async renderFiltered(samples, positions, offset, limit) {
                return (await this.send('renderFiltered', {
                    samples, positions, offset, limit
                })).html;
            }

            async calculateDistanceMatrix(pipeline, mode, minDepth, minConsensus, minQual) {
                return (await this.send('calculateDistanceMatrix', {
                    pipeline, mode, minDepth, minConsensus, minQual
                })).matrix;
            }

            async getKpiData() {
                return await this.send('getKpiData');
            }

            async getReproducibilityCommands(pipelineIds) {
                return (await this.send('getReproducibilityCommands', { pipelineIds })).commands;
            }

            async getConsensusStats() {
                return (await this.send('getConsensusStats')).stats;
            }

            async getPerSampleIntersectionWithGt() {
                return (await this.send('getPerSampleIntersectionWithGt')).intersection;
            }

            async getFilePaths() {
                return (await this.send('getFilePaths')).paths;
            }

            async getKpis() {
                return (await this.send('getKpis')).kpis;
            }

            async getMnpStats() {
                return (await this.send('getMnpStats')).stats;
            }

            async getPipelineConcordance() {
                return (await this.send('getPipelineConcordance')).concordance;
            }

            async getSnpsInGaps() {
                return (await this.send('getSnpsInGaps')).snpsInGaps;
            }

            async getSnp(sample, pipeline, pos) {
                return (await this.send('getSnp', { sample, pipeline, pos })).snp;
            }

            async getPairwiseUsableStats() {
                return (await this.send('getPairwiseUsableStats')).stats;
            }

            async getReviewerPairwiseStats() {
                return (await this.send('getReviewerPairwiseStats')).stats;
            }

            // Cached accessors (no worker call needed after load)
            get refName() { return this.cachedData.refName; }
            get refLength() { return this.cachedData.refLength; }
            get sampleIds() { return this.cachedData.sampleIds; }
            get pipelineIds() { return this.cachedData.pipelineIds; }
            get generatedAt() { return this.cachedData.generatedAt; }
            get description() { return this.cachedData.description; }
            get warnings() { return this.cachedData.warnings; }
            get vcfPipelines() { return this.cachedData.vcfPipelines; }
            get groundTruthPipeline() { return this.cachedData.groundTruthPipeline; }
            get pipelineDistanceMatrices() { return this.cachedData.pipelineDistanceMatrices; }
            get pipelineInfo() { return this.cachedData.pipelineInfo; }
            get sampleLabels() { return this.cachedData.sampleLabels; }

            // Helper methods for cached data
            getPipelineLabel(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.label || pipelineId;
            }
            getPipelineCommand(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.command || '';
            }
            isGroundTruth(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.isGroundTruth || false;
            }
            isFromBamPileup(pipelineId) {
                return this.cachedData.pipelineInfo?.[pipelineId]?.isFromBamPileup || false;
            }
            getSampleLabel(sampleId) {
                return this.cachedData.sampleLabels?.[sampleId] || sampleId;
            }
        }

        let workerApi = null;
        let samples = [];
        let positions = [];
        let currentPage = 0;
        let activeFilters = [];
        const CHAR_WIDTH = 7;
        const LABEL_WIDTH = 70;

        function getPageSize() {
            // Calculate how many nucleotides fit in the available width
            const availableWidth = window.innerWidth - LABEL_WIDTH - 20; // 20px padding
            return Math.max(50, Math.floor(availableWidth / CHAR_WIDTH));
        }

        window.gotoPosition = gotoPosition;
        window.nextPage = nextPage;
        window.prevPage = prevPage;
        window.toggleFilter = toggleFilter;
        window.onFilterConfigChange = onFilterConfigChange;
        window.updateQualityFilter = updateQualityFilter;
        window.resetQualityFilters = resetQualityFilters;
        window.calculateDistanceMatrix = calculateDistanceMatrix;
        window.setAllRowVisibility = setAllRowVisibility;
        window.filterVisibilityCheckboxes = filterVisibilityCheckboxes;
        window.toggleRowVisibility = toggleRowVisibility;
        window.redrawGenomeOverview = async () => {
            if (workerApi && workerApi.ready && samples.length > 0) {
                await drawGenomeOverview();
            }
        };

        let pipelines = [];
        let qualityFilters = { minQual: 0, minDepth: 0, minConsensus: 50 };

        function showLoader(text, progress = '') {
            document.getElementById('loader').classList.add('active');
            document.getElementById('loader-text').textContent = text;
            document.getElementById('loader-progress').textContent = progress;
        }

        function hideLoader() {
            document.getElementById('loader').classList.remove('active');
        }

        function goToLanding() {
            document.getElementById('viewer').classList.add('hidden');
            document.getElementById('drop-zone').classList.remove('hidden');
        }

        // Progressive loading helpers
        function setSectionLoading(containerId, isLoading, message = 'Loading...') {
            const container = document.getElementById(containerId);
            if (!container) return;
            if (isLoading) {
                container.innerHTML = `<div class="section-loading"><span class="mini-spinner"></span>${message}</div>`;
            }
        }

        function scheduleIdleTask(callback, timeout = 2000) {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(callback, { timeout });
            } else {
                setTimeout(callback, 10);
            }
        }

        // Progressive UI builder - shows UI immediately, then populates sections
        async function buildUIProgressively() {
            const t0 = performance.now();

            // Phase 1: Show viewer immediately with loading states
            document.getElementById('drop-zone').classList.add('hidden');
            document.getElementById('viewer').classList.remove('hidden');

            // Set loading placeholders for all sections
            setSectionLoading('pipelines-info', true, 'Loading pipelines...');
            setSectionLoading('kpis', true, 'Calculating statistics...');
            setSectionLoading('per-sample-stats', true, 'Building statistics...');
            setSectionLoading('coverage-stats-content', true, 'Loading coverage data...');
            setSectionLoading('matrix-result', true, 'Ready to calculate');
            setSectionLoading('alignment', true, 'Positions will load after statistics...');

            // Phase 2: Quick stuff first (instant)
            await nextFrame();
            populateDescription();
            displayWarnings();
            console.log(`Phase 2 (description): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 3: Pipeline info (fast)
            await nextFrame();
            populatePipelineInfo();
            populateMatrixPipelineSelector();
            console.log(`Phase 3 (pipelines): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 4: KPIs (medium)
            await nextFrame();
            await updateKPIs();
            createFilterButtons(pipelines);
            createVisibilityControls(pipelines);
            console.log(`Phase 4 (KPIs): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 5: Per-sample stats (can be slow)
            await nextFrame();
            await populatePerSampleStats();
            console.log(`Phase 5 (per-sample): ${(performance.now() - t0).toFixed(0)}ms`);

            // Hide loader - core UI is now visible
            hideLoader();

            // Phase 6: Heavy stuff in idle time
            scheduleIdleTask(async () => {
                await populateCoverageStats();
                console.log(`Phase 6 (coverage): ${(performance.now() - t0).toFixed(0)}ms`);
            });

            scheduleIdleTask(async () => {
                await populateReproducibilityCommands();
                console.log(`Phase 6b (reproducibility): ${(performance.now() - t0).toFixed(0)}ms`);
            });

            // Phase 7: Genome overview (heavy, but visible)
            await nextFrame();
            await drawGenomeOverview();
            console.log(`Phase 7 (genome): ${(performance.now() - t0).toFixed(0)}ms`);

            // Phase 8: Load positions in idle time (after UI is responsive)
            setSectionLoading('alignment', true, 'Loading positions...');
            document.getElementById('status').textContent = 'Loading positions...';
            scheduleIdleTask(async () => {
                await loadAllPositions();
                console.log(`Phase 8 (positions): ${(performance.now() - t0).toFixed(0)}ms`);
            });
            console.log(`Phase 8 (positions scheduled): ${(performance.now() - t0).toFixed(0)}ms`);

            // Clear matrix placeholder
            document.getElementById('matrix-result').innerHTML =
                '<p style="color:var(--text-secondary);font-size:11px;">Select options and click "Calculate" to compute distance matrix.</p>';

            console.log(`UI build complete: ${(performance.now() - t0).toFixed(0)}ms`);
        }

        function nextFrame() {
            return new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        }

        async function main() {
            workerApi = new WorkerAPI();
            showLoader('Initializing...', 'Loading WASM module');
            const success = await workerApi.init();
            if (!success) {
                alert('Failed to initialize WASM module');
                return;
            }
            hideLoader();
            console.log('Worker + WASM initialized');
            setupDropZone();
            setupFileInput();
        }

        function setupDropZone() {
            const dropZone = document.getElementById('drop-zone');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('dragover');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('dragover');
                });
            });

            dropZone.addEventListener('drop', (e) => {
                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.json') || file.name.endsWith('.json.gz') || file.name.endsWith('.bin') || file.name.endsWith('.bin.gz') || file.name.endsWith('.gz'))) {
                    loadFile(file);
                }
            });
        }

        function setupFileInput() {
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadFile(file);
                }
            });
        }

        // Streaming decompression with progress updates (returns text)
        async function decompressGzipWithProgress(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                // Native streaming decompression
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const decoder = new TextDecoder();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(decoder.decode(value, { stream: true }));
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    // Yield to UI every few MB
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }
                chunks.push(decoder.decode()); // Flush
                return chunks.join('');
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed, { to: 'string' });
        }

        // Streaming decompression for binary data (returns Uint8Array)
        async function decompressGzipBinary(arrayBuffer, onProgress) {
            if (typeof DecompressionStream !== 'undefined') {
                const stream = new Response(arrayBuffer).body
                    .pipeThrough(new DecompressionStream('gzip'));
                const reader = stream.getReader();
                const chunks = [];
                let totalBytes = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    totalBytes += value.length;
                    onProgress(totalBytes);
                    if (totalBytes % (2 * 1024 * 1024) < value.length) {
                        await new Promise(r => requestAnimationFrame(r));
                    }
                }

                // Combine all chunks into single Uint8Array
                const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    result.set(chunk, offset);
                    offset += chunk.length;
                }
                return result;
            }
            // Fallback to pako for older browsers
            const compressed = new Uint8Array(arrayBuffer);
            return pako.inflate(compressed);
        }

        // Detect if file is binary format based on filename
        function isBinaryFormat(filename) {
            return filename.endsWith('.bin') || filename.endsWith('.bin.gz');
        }

        async function loadDemo() {
            showLoader('Loading demo...', 'Fetching demo data');
            await new Promise(r => requestAnimationFrame(r));

            try {
                // Load binary format (faster than JSON)
                const response = await fetch('demo.bin.gz');
                if (!response.ok) throw new Error('Failed to fetch demo file');

                const compressedSize = parseInt(response.headers.get('content-length') || '0');
                showLoader('Downloading...', `${(compressedSize / 1024 / 1024).toFixed(1)} MB compressed`);
                await new Promise(r => requestAnimationFrame(r));
                const arrayBuffer = await response.arrayBuffer();

                showLoader('Decompressing...', '0 MB');
                const binaryData = await decompressGzipBinary(arrayBuffer, (bytes) => {
                    showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                });

                showLoader('Loading data...', `${(binaryData.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                await new Promise(r => requestAnimationFrame(r));

                // Load in worker - UI stays responsive!
                await workerApi.loadBinary(binaryData.buffer);

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                // Use cached data from worker
                samples = workerApi.sampleIds;
                pipelines = workerApi.pipelineIds;

                document.getElementById('header-info').textContent =
                    `${workerApi.refName} (${workerApi.refLength.toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer
                const timestamp = workerApi.generatedAt;
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                // Build UI progressively (loader hidden inside after core UI ready)
                await buildUIProgressively();

            } catch (error) {
                hideLoader();
                alert('Error loading demo: ' + error.message);
                console.error(error);
            }
        }
        // Load all positions on demand
        async function loadAllPositions() {
            showLoader('Loading positions...', 'This may take a moment');
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            await loadPositions();
            hideLoader();
        }
        window.loadAllPositions = loadAllPositions;

        // Expose to global scope for onclick
        window.loadDemo = loadDemo;

        async function loadFile(file) {
            showLoader('Loading file...', `${(file.size / 1024 / 1024).toFixed(1)} MB`);
            await new Promise(r => requestAnimationFrame(r)); // Force repaint

            try {
                const isGzip = file.name.endsWith('.gz');
                const isBinary = isBinaryFormat(file.name);

                if (isBinary) {
                    // Binary (bincode) format - much faster to parse
                    showLoader('Decompressing...', '0 MB');
                    await new Promise(r => requestAnimationFrame(r));
                    const arrayBuffer = await file.arrayBuffer();

                    let binaryData;
                    if (isGzip) {
                        binaryData = await decompressGzipBinary(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                    } else {
                        binaryData = new Uint8Array(arrayBuffer);
                    }

                    showLoader('Loading data...', `${(binaryData.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                    await new Promise(r => requestAnimationFrame(r));

                    // Load in worker - UI stays responsive!
                    await workerApi.loadBinary(binaryData.buffer);
                } else {
                    // JSON format
                    let text;
                    if (isGzip) {
                        showLoader('Decompressing...', '0 MB');
                        await new Promise(r => requestAnimationFrame(r));
                        const arrayBuffer = await file.arrayBuffer();

                        text = await decompressGzipWithProgress(arrayBuffer, (bytes) => {
                            showLoader('Decompressing...', `${(bytes / 1024 / 1024).toFixed(1)} MB`);
                        });
                    } else {
                        showLoader('Reading file...', '');
                        text = await file.text();
                    }

                    showLoader('Loading data...', `${(text.length / 1024 / 1024).toFixed(0)} MB (in background)`);
                    await new Promise(r => requestAnimationFrame(r));

                    // Load in worker - UI stays responsive!
                    await workerApi.loadJson(text);
                }

                showLoader('Preparing view...', '');
                await new Promise(r => requestAnimationFrame(r));

                // Use cached data from worker
                samples = workerApi.sampleIds;
                pipelines = workerApi.pipelineIds;

                document.getElementById('header-info').textContent =
                    `${workerApi.refName} (${workerApi.refLength.toLocaleString()} bp) | ${samples.length} samples | ${pipelines.length} pipelines`;

                // Set timestamp in footer (format: dd/mm/yyyy hh:mi:ss)
                const timestamp = workerApi.generatedAt;
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    const hh = String(date.getHours()).padStart(2, '0');
                    const mi = String(date.getMinutes()).padStart(2, '0');
                    const ss = String(date.getSeconds()).padStart(2, '0');
                    const formattedDate = `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
                    document.getElementById('report-timestamp').textContent =
                        `Report generated: ${formattedDate}`;
                }

                // Build UI progressively (loader hidden inside after core UI ready)
                await buildUIProgressively();

            } catch (err) {
                hideLoader();
                console.error('Failed to load report:', err);
                alert('Failed to load report: ' + err);
            }
        }

        function displayWarnings() {
            const warnings = workerApi.warnings || [];
            const container = document.getElementById('warnings');

            if (warnings.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            for (const warning of warnings) {
                // Skip MNP warnings - they're shown in the table with warning icon
                if (warning.includes('MNP')) {
                    continue;
                }
                html += `<div class="warning-item">${warning}</div>`;
            }
            container.innerHTML = html;
        }

        // Simple markdown renderer
        function renderMarkdown(text) {
            if (!text) return '';

            // Process line by line for better list handling
            const lines = text.split('\n');
            let html = '';
            let inList = false;
            let inParagraph = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                // Escape HTML
                line = line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // Check line type
                const isHeader = /^#{1,3} /.test(line);
                const isListItem = /^[-*] /.test(line) || /^\d+\. /.test(line);
                const isEmpty = line.trim() === '';

                // Close paragraph if needed
                if (inParagraph && (isHeader || isListItem || isEmpty)) {
                    html += '</p>';
                    inParagraph = false;
                }

                // Close list if needed
                if (inList && !isListItem) {
                    html += '</ul>';
                    inList = false;
                }

                if (isEmpty) {
                    continue;
                }

                // Headers
                if (/^### (.+)$/.test(line)) {
                    html += line.replace(/^### (.+)$/, '<h3>$1</h3>');
                } else if (/^## (.+)$/.test(line)) {
                    html += line.replace(/^## (.+)$/, '<h2>$1</h2>');
                } else if (/^# (.+)$/.test(line)) {
                    html += line.replace(/^# (.+)$/, '<h1>$1</h1>');
                }
                // List items
                else if (isListItem) {
                    if (!inList) {
                        html += '<ul>';
                        inList = true;
                    }
                    let content = line.replace(/^[-*] /, '').replace(/^\d+\. /, '');
                    // Apply inline formatting
                    content = content
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.+?)\*/g, '<em>$1</em>')
                        .replace(/_(.+?)_/g, '<em>$1</em>')
                        .replace(/`([^`]+)`/g, '<code>$1</code>');
                    html += '<li>' + content + '</li>';
                }
                // Regular text
                else {
                    if (!inParagraph) {
                        html += '<p>';
                        inParagraph = true;
                    } else {
                        html += ' ';
                    }
                    // Apply inline formatting
                    line = line
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.+?)\*/g, '<em>$1</em>')
                        .replace(/_(.+?)_/g, '<em>$1</em>')
                        .replace(/`([^`]+)`/g, '<code>$1</code>');
                    html += line;
                }
            }

            // Close any open tags
            if (inParagraph) html += '</p>';
            if (inList) html += '</ul>';

            return html;
        }

        function populateDescription() {
            const panel = document.getElementById('description-panel');
            const view = document.getElementById('description-view');

            const description = workerApi.description;

            if (description && description.trim()) {
                panel.style.display = 'block';
                panel.open = true;
                view.innerHTML = renderMarkdown(description);
            } else {
                // Hide panel if no description
                panel.style.display = 'none';
            }
        }

        function populatePipelineInfo() {
            const pipelineIds = workerApi.pipelineIds;
            const container = document.getElementById('pipelines-info');

            let html = '';
            for (const pipelineId of pipelineIds) {
                const label = workerApi.getPipelineLabel(pipelineId);
                const command = workerApi.getPipelineCommand(pipelineId);
                const isGroundTruth = workerApi.isGroundTruth(pipelineId);
                const isFromBamPileup = workerApi.isFromBamPileup(pipelineId);

                html += `<div class="pipeline-info-item">`;
                html += `<div class="pipeline-name">${label}`;
                if (isGroundTruth) {
                    html += `<span class="pipeline-badge">Ground Truth</span>`;
                    if (isFromBamPileup) {
                        html += `<span class="pipeline-badge" style="background:#ff9800;" title="SNPs derived from BAM pileup, no variant calling filters applied">BAM pileup</span>`;
                    }
                }
                html += `</div>`;
                if (command) {
                    html += `<div class="pipeline-command">${command}</div>`;
                }
                if (isGroundTruth && isFromBamPileup) {
                    html += `<div style="color:#ff9800;font-size:10px;margin-top:4px;">⚠️ SNPs from BAM pileup - no variant calling performed</div>`;
                }
                html += `</div>`;
            }

            if (html === '') {
                html = '<p style="color:var(--text-secondary);font-size:11px;">No pipeline information available.</p>';
            }

            container.innerHTML = html;
        }

        async function populatePerSampleStats() {
            const container = document.getElementById('per-sample-stats');
            const stats = await workerApi.getPerSampleStats();
            const sampleIds = workerApi.sampleIds;
            const pipelineIds = workerApi.pipelineIds;
            const gtPipeline = workerApi.groundTruthPipeline;
            const refLength = workerApi.refLength;
            const consensusStats = await workerApi.getConsensusStats();

            if (Object.keys(stats).length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No per-sample statistics available.</p>';
                return;
            }

            // Build table
            let html = '<table class="stats-table">';

            // Header row
            html += '<tr><th rowspan="2">Sample</th>';
            for (const pipelineId of pipelineIds) {
                const label = workerApi.getPipelineLabel(pipelineId);
                const isGT = pipelineId === gtPipeline;
                const colspan = isGT ? 2 : 4;
                html += `<th colspan="${colspan}" class="pipeline-header">${label}${isGT ? ' (GT)' : ''}</th>`;
            }
            // Add per-pipeline intersection with GT columns
            const perSampleIntersection = gtPipeline ? await workerApi.getPerSampleIntersectionWithGt() : null;
            const vcfPipelines = workerApi.vcfPipelines;
            const nonGtPipelines = vcfPipelines.filter(p => p !== gtPipeline);
            if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                const gtLabel = workerApi.getPipelineLabel(gtPipeline).split(' ')[0];
                for (const pipelineId of nonGtPipelines) {
                    const pLabel = workerApi.getPipelineLabel(pipelineId).split(' ')[0];
                    html += `<th class="pipeline-header" style="background:#1565c0;" title="SNP intersection: ${pLabel} ∩ ${gtLabel}">${pLabel} ∩ ${gtLabel}</th>`;
                }
            }
            // Add Consensus columns if we have GT
            if (gtPipeline && consensusStats?.per_sample) {
                const pipelineNames = nonGtPipelines.map(p => workerApi.getPipelineLabel(p).split(' ')[0]).join(' ∩ ');
                const gtLabel = workerApi.getPipelineLabel(gtPipeline).split(' ')[0];
                html += `<th colspan="2" class="pipeline-header" style="background:#4a4a4a;" title="Positions where VCF pipelines agree">${pipelineNames}</th>`;
                html += `<th class="pipeline-header" style="background:#6a1b9a;" title="Positions where ALL pipelines (incl. GT) agree">${gtLabel} ∩ ${pipelineNames}</th>`;
            }
            html += '</tr>';

            // Sub-header row (with info icons)
            const psInfoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')" style="margin-left:3px;">ⓘ</span>`;
            html += '<tr>';
            for (const pipelineId of pipelineIds) {
                const isGT = pipelineId === gtPipeline;
                html += `<th>SNPs ${psInfoIcon('ps_snps')}</th><th>Gaps ${psInfoIcon('ps_gaps')}</th>`;
                if (!isGT) {
                    html += `<th>vs GT ${psInfoIcon('ps_vs_gt')}</th>`;
                    html += `<th>in GT Gaps ${psInfoIcon('ps_in_gt_gaps')}</th>`;
                }
            }
            // Add intersection sub-headers
            if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                for (const pipelineId of nonGtPipelines) {
                    html += `<th>∩ ${psInfoIcon('ps_intersection')}</th>`;
                }
            }
            // Add Consensus sub-headers with explicit % labels
            if (gtPipeline && consensusStats?.per_sample) {
                html += `<th>SNPs<br><span style="font-size:9px;color:var(--text-secondary);">% of ref</span> ${psInfoIcon('ps_vcf_consensus')}</th>`;
                html += `<th>in GT<br><span style="font-size:9px;color:var(--text-secondary);">% of cons</span> ${psInfoIcon('ps_consensus_in_gt')}</th>`;
                html += `<th>All<br><span style="font-size:9px;color:var(--text-secondary);">% of ref</span> ${psInfoIcon('ps_all_consensus')}</th>`;
            }
            html += '</tr>';

            // Data rows
            for (const sampleId of sampleIds) {
                const sampleLabel = workerApi.getSampleLabel(sampleId) || sampleId;
                const sampleStats = stats[sampleId];
                if (!sampleStats) continue;

                html += `<tr><td>${sampleLabel}</td>`;

                for (const pipelineId of pipelineIds) {
                    const isGT = pipelineId === gtPipeline;
                    const pStats = sampleStats.pipelines[pipelineId];

                    if (pStats) {
                        // SNPs with percentage of reference
                        const snpPct = ((pStats.snps / refLength) * 100).toFixed(2);
                        html += `<td title="${pStats.snps.toLocaleString()} SNPs">${pStats.snps.toLocaleString()} (${snpPct}%)</td>`;

                        // Gaps with percentage of reference
                        const gapPct = ((pStats.gap_bp / refLength) * 100).toFixed(1);
                        html += `<td title="${pStats.gap_bp.toLocaleString()} bp gaps">${pStats.gap_bp.toLocaleString()} (${gapPct}%)</td>`;

                        if (!isGT) {
                            // Agreement with GT
                            const agreePct = pStats.agreement_with_gt_pct.toFixed(1);
                            const agreeClass = pStats.agreement_with_gt_pct >= 90 ? 'good' : pStats.agreement_with_gt_pct >= 70 ? 'warning' : 'bad';
                            html += `<td class="${agreeClass}" title="${pStats.agreement_with_gt.toLocaleString()} SNPs match GT positions">${pStats.agreement_with_gt.toLocaleString()} (${agreePct}%)</td>`;

                            // SNPs in GT gaps
                            const gapsPct = pStats.snps_in_gt_gaps_pct.toFixed(2);
                            const gapsClass = pStats.snps_in_gt_gaps_pct <= 1 ? 'good' : pStats.snps_in_gt_gaps_pct <= 5 ? 'warning' : 'bad';
                            html += `<td class="${gapsClass}" title="${pStats.snps_in_gt_gaps.toLocaleString()} SNPs in GT gaps">${pStats.snps_in_gt_gaps.toLocaleString()} (${gapsPct}%)</td>`;
                        }
                    } else {
                        html += '<td>-</td><td>-</td>';
                        if (!isGT) {
                            html += '<td>-</td><td>-</td>';
                        }
                    }
                }

                // Add per-pipeline intersection with GT columns
                if (gtPipeline && perSampleIntersection && perSampleIntersection[sampleId]) {
                    const sampleInt = perSampleIntersection[sampleId];
                    for (const pipelineId of nonGtPipelines) {
                        const iStats = sampleInt[pipelineId];
                        if (iStats) {
                            const intClass = iStats.pct_of_gt >= 90 ? 'good' : iStats.pct_of_gt >= 70 ? 'warning' : 'bad';
                            const gtLabel = workerApi.getPipelineLabel(gtPipeline).split(' ')[0];
                            const pLabel = workerApi.getPipelineLabel(pipelineId).split(' ')[0];
                            html += `<td class="${intClass}" title="${iStats.intersection.toLocaleString()} SNPs shared\n${pLabel}: ${iStats.pipeline_snps.toLocaleString()} SNPs\n${gtLabel}: ${iStats.gt_snps.toLocaleString()} SNPs\n${iStats.pct_of_pipeline.toFixed(1)}% of ${pLabel}, ${iStats.pct_of_gt.toFixed(1)}% of ${gtLabel}">${iStats.intersection.toLocaleString()} (${iStats.pct_of_gt.toFixed(1)}%)</td>`;
                        } else {
                            html += '<td>-</td>';
                        }
                    }
                } else if (gtPipeline && perSampleIntersection && Object.keys(perSampleIntersection).length > 0) {
                    for (const _ of nonGtPipelines) {
                        html += '<td>-</td>';
                    }
                }

                // Add Consensus columns
                if (gtPipeline && consensusStats?.per_sample) {
                    const cStats = consensusStats.per_sample[sampleId];
                    if (cStats && cStats.vcf_consensus) {
                        const vc = cStats.vcf_consensus;
                        const cSnpPct = ((vc.consensus_snps / refLength) * 100).toFixed(2);
                        html += `<td title="${vc.consensus_snps.toLocaleString()} VCF consensus SNPs">${vc.consensus_snps.toLocaleString()} (${cSnpPct}%)</td>`;

                        const inGtPct = vc.consensus_in_gt_pct.toFixed(1);
                        const inGtClass = vc.consensus_in_gt_pct >= 90 ? 'good' : vc.consensus_in_gt_pct >= 70 ? 'warning' : 'bad';
                        html += `<td class="${inGtClass}" title="${vc.consensus_in_gt.toLocaleString()} of ${vc.consensus_snps.toLocaleString()} VCF consensus SNPs are in GT">${vc.consensus_in_gt.toLocaleString()} (${inGtPct}%)</td>`;

                        // All consensus (GT ∩ all VCF)
                        const allPct = ((cStats.all_consensus / refLength) * 100).toFixed(2);
                        html += `<td style="color:#9c27b0;" title="Positions where ALL pipelines (incl. GT) agree">${cStats.all_consensus.toLocaleString()} (${allPct}%)</td>`;
                    } else {
                        html += '<td>-</td><td>-</td><td>-</td>';
                    }
                }

                html += '</tr>';
            }

            html += '</table>';

            // Add legend
            html += `<div style="margin-top:10px;font-size:10px;color:var(--text-secondary);">
                <strong>Legend:</strong>
                <span class="good">Green</span> = good,
                <span class="warning">Yellow</span> = moderate,
                <span class="bad">Red</span> = potential issue |
                <strong>vs GT:</strong> % of GT SNP positions also called by this pipeline |
                <strong>in GT Gaps:</strong> SNPs in regions with no GT coverage |
                <strong>Consensus:</strong> positions where ALL VCF pipelines agree
            </div>`;

            container.innerHTML = html;
        }

        async function populateReproducibilityCommands() {
            const container = document.getElementById('reproducibility-content');
            const filePaths = await workerApi.getFilePaths();
            const kpis = await workerApi.getKpis();
            const pipelineIds = workerApi.pipelineIds;
            const groundTruthPipeline = workerApi.groundTruthPipeline;

            if (Object.keys(filePaths).length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No file paths available in report.</p>';
                return;
            }

            let html = '<p style="font-size:10px;color:var(--text-secondary);margin-bottom:15px;">Copy these commands to verify the statistics shown in the dashboard.</p>';

            // Group commands by type
            html += '<div class="repro-section"><h4>SNP Counts (bcftools)</h4>';
            for (const pipeline of pipelineIds) {
                if (!kpis.snps[pipeline]) continue;
                const label = workerApi.getPipelineLabel(pipeline);
                // Get first sample's VCF path as example
                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[pipeline]?.vcf) {
                        const vcf = pipelines[pipeline].vcf;
                        const cmd = `bcftools view -H "${vcf}" | wc -l`;
                        html += `<div class="repro-cmd"><code>${cmd}</code><button onclick="copyToClipboard(this, \`${cmd.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                        html += `<div class="repro-note">Expected: ~${kpis.snps[pipeline].toLocaleString()} for ${label} (${sample})</div>`;
                        break;
                    }
                }
            }
            html += '</div>';

            // Gap calculation commands
            html += '<div class="repro-section"><h4>Gap Regions (samtools depth)</h4>';
            for (const pipeline of pipelineIds) {
                if (!kpis.gaps[pipeline]) continue;
                const label = workerApi.getPipelineLabel(pipeline);
                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[pipeline]?.bam) {
                        const bam = pipelines[pipeline].bam;
                        const cmd = `samtools depth -a "${bam}" | awk '$3==0 {sum++} END {print sum}'`;
                        html += `<div class="repro-cmd"><code>${cmd}</code><button onclick="copyToClipboard(this, \`${cmd.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                        html += `<div class="repro-note">Zero-coverage positions for ${label} (${sample})</div>`;
                        break;
                    }
                }
            }
            html += '</div>';

            // SNPs in GT gaps verification
            if (groundTruthPipeline) {
                html += '<div class="repro-section"><h4>SNPs in Ground Truth Gaps (bedtools)</h4>';
                html += '<div class="repro-note" style="margin-bottom:8px;">Export gaps as BED, then intersect with VCF:</div>';

                for (const [sample, pipelines] of Object.entries(filePaths)) {
                    if (pipelines[groundTruthPipeline]?.bam) {
                        const gtBam = pipelines[groundTruthPipeline].bam;
                        const cmd1 = `samtools depth -a "${gtBam}" | awk '$3==0 {print $1"\\t"$2-1"\\t"$2}' > gt_gaps.bed`;
                        html += `<div class="repro-cmd"><code>${cmd1}</code><button onclick="copyToClipboard(this, \`${cmd1.replace(/`/g, '\\`')}\`)">Copy</button></div>`;

                        for (const pipeline of pipelineIds) {
                            if (pipeline === groundTruthPipeline) continue;
                            if (pipelines[pipeline]?.vcf) {
                                const vcf = pipelines[pipeline].vcf;
                                const label = workerApi.getPipelineLabel(pipeline);
                                const cmd2 = `bedtools intersect -a "${vcf}" -b gt_gaps.bed | wc -l`;
                                html += `<div class="repro-cmd"><code>${cmd2}</code><button onclick="copyToClipboard(this, \`${cmd2.replace(/`/g, '\\`')}\`)">Copy</button></div>`;
                                html += `<div class="repro-note">${label} SNPs in GT gaps (${sample})</div>`;
                            }
                        }
                        break;
                    }
                }
                html += '</div>';
            }

            container.innerHTML = html;
        }

        function copyToClipboard(button, text) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => button.textContent = originalText, 1500);
            });
        }

        async function updateKPIs(filteredCount = null) {
            const kpis = await workerApi.getKpis();
            const refLength = workerApi.refLength;
            const gtPipelineId = workerApi.groundTruthPipeline;

            // Helper to sort pipeline entries with GT always first, then alphabetically
            const sortedPipelineEntries = (obj) => {
                return Object.entries(obj).sort(([a], [b]) => {
                    if (a === gtPipelineId) return -1;
                    if (b === gtPipelineId) return 1;
                    return a.localeCompare(b);
                });
            };

            // Helper to create info icon
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')">ⓘ</span>`;

            // Helper to create collapsible section
            const sectionStart = (title, open = false) => `<details class="kpi-section"${open ? ' open' : ''}><summary>${title}</summary><div class="kpi-section-content">`;
            const sectionEnd = () => `</div></details>`;

            let html = '';

            // === SECTION 1: Overview ===
            html += sectionStart('Overview', true);
            html += `
                <div class="kpi"><div class="label">Reference ${infoIcon('reference')}</div><div class="value">${refLength.toLocaleString()} bp</div></div>
            `;

            // Usable space: reference length minus average GT gaps per sample
            if (gtPipelineId && kpis.gaps[gtPipelineId] != null) {
                const avgGtGaps = Math.round(kpis.gaps[gtPipelineId] / kpis.samples);
                const usableBp = refLength - avgGtGaps;
                const usablePct = ((usableBp / refLength) * 100).toFixed(2);
                html += `<div class="kpi"><div class="label">Usable Space ${infoIcon('usable_space')}</div><div class="value">${usableBp.toLocaleString()} bp <span class="pct">(${usablePct}%)</span></div></div>`;

                // Usable SNPs: GT core positions minus consensus (discriminating SNPs)
                const gtCore = kpis.core_snps[gtPipelineId] || 0;
                const gtConsensus = kpis.consensus_snps[gtPipelineId] || 0;
                const gtUsableSnps = gtCore - gtConsensus;
                const gtUsablePct = gtCore > 0 ? ((gtUsableSnps / gtCore) * 100).toFixed(2) : '0.00';
                html += `<div class="kpi"><div class="label">Usable SNPs (GT) ${infoIcon('usable_snps')}</div><div class="value">${gtUsableSnps.toLocaleString()} <span class="pct">(${gtUsablePct}% of ${gtCore.toLocaleString()} core)</span></div></div>`;
            }

            html += `
                <div class="kpi"><div class="label">Samples ${infoIcon('samples')}</div><div class="value">${kpis.samples}</div></div>
                <div class="kpi"><div class="label">Pipelines ${infoIcon('pipelines')}</div><div class="value">${kpis.pipelines}</div></div>
            `;

            // Show filtered positions count when filters are active
            if (filteredCount !== null) {
                html += `<div class="kpi"><div class="label">Filtered Positions ${infoIcon('filtered')}</div><div class="value">${filteredCount.toLocaleString()}</div></div>`;
            }

            html += sectionEnd(); // close Overview

            // Pairwise averages (only if GT and >= 2 samples)
            if (gtPipelineId && kpis.samples >= 2) {
                const pw = await workerApi.getPairwiseUsableStats();
                if (pw && pw.num_pairs > 0) {
                    html += sectionStart(`Pairwise Averages <span style="font-weight:normal;font-size:10px;color:var(--text-muted);">(${pw.num_pairs} pairs)</span>`, true);
                    html += `<div class="kpi"><div class="label">Avg Usable Space ${infoIcon('pw_usable_space')}</div><div class="value">${Math.round(pw.avg_usable_space).toLocaleString()} bp <span class="pct">(${pw.avg_usable_space_pct.toFixed(2)}%)</span></div></div>`;
                    html += `<div class="kpi"><div class="label">Avg Discriminating SNPs (GT) ${infoIcon('pw_usable_snps')}</div><div class="value">${pw.avg_usable_snps.toFixed(2)}</div></div>`;
                    html += sectionEnd();
                }

                // Reviewer methodology: intersection-based gaps + per-sample usable SNPs
                const rpw = await workerApi.getReviewerPairwiseStats();
                if (rpw) {
                    html += sectionStart(`Pairwise (Intersection) <span style="font-weight:normal;font-size:10px;color:var(--text-muted);">(${rpw.num_pairs} pairs)</span>`, true);
                    html += `<div class="kpi"><div class="label">Usable Space ${infoIcon('rpw_usable_space')}</div><div class="value">${rpw.global_usable_space.toLocaleString()} bp <span class="pct">(${rpw.global_usable_space_pct.toFixed(2)}%)</span></div></div>`;

                    // Per-sample usable SNPs
                    const sampleIds = workerApi.sampleIds;
                    for (const sId of sampleIds) {
                        const sLabel = workerApi.getSampleLabel(sId);
                        const usable = rpw.per_sample_usable_snps[sId] || 0;
                        html += `<div class="kpi"><div class="label">${sLabel} Usable SNPs ${infoIcon('rpw_sample_snps')}</div><div class="value">${usable.toLocaleString()}</div></div>`;
                    }

                    html += `<div class="kpi"><div class="label">Avg Pairwise Discriminating ${infoIcon('rpw_discriminating')}</div><div class="value">${rpw.avg_pairwise_discriminating.toFixed(2)}</div></div>`;
                    html += sectionEnd();
                }
            }

            // === SECTION 2: Per-Pipeline Statistics (Pivot Table) ===
            html += sectionStart('Per-Pipeline Statistics');

            // Helper for subsection labels
            const subLabel = (title) => `<div class="kpi-sub-label">${title}</div>`;

            // Get MNP stats for table
            const mnpStats = await workerApi.getMnpStats();

            // Get GT counts for diff calculation
            const gtSnpCount = gtPipelineId ? (kpis.snps[gtPipelineId] || 0) : null;
            const gtGapCount = gtPipelineId ? (kpis.gaps[gtPipelineId] || 0) : null;

            // Build pivot table: rows = pipelines, columns = metrics
            html += `<table class="kpi-table">
                <thead>
                    <tr>
                        <th>Pipeline</th>
                        <th>SNPs ${infoIcon('snps')}</th>
                        <th>#All ${infoIcon('core_snps')}</th>
                        <th>#Consensus ${infoIcon('consensus_snps')}</th>
                        <th>Usable ${infoIcon('usable_snps')}</th>
                        <th>Gaps ${infoIcon('gaps')}</th>
                        <th>MNPs ${infoIcon('mnps')}</th>
                    </tr>
                </thead>
                <tbody>`;

            for (const [pipeline, snpCount] of sortedPipelineEntries(kpis.snps)) {
                const label = workerApi.getPipelineLabel(pipeline).split(' ')[0]; // Short label
                const gapCount = kpis.gaps[pipeline] || 0;
                const coreCount = kpis.core_snps ? (kpis.core_snps[pipeline] || 0) : 0;
                const consCount = kpis.consensus_snps ? (kpis.consensus_snps[pipeline] || 0) : 0;
                const mStats = mnpStats ? mnpStats[pipeline] : null;
                const mnpCount = mStats ? mStats.mnps_found : 0;
                const isFromBamPileup = workerApi.isFromBamPileup(pipeline);

                // Calculate percentages
                const totalBases = refLength * kpis.samples;
                const snpPct = ((snpCount / totalBases) * 100).toFixed(2);
                const gapPct = ((gapCount / totalBases) * 100).toFixed(2);
                const corePct = snpCount > 0 ? ((coreCount / snpCount) * 100).toFixed(2) : '0.00';
                const consPct = snpCount > 0 ? ((consCount / snpCount) * 100).toFixed(2) : '0.00';

                // Calculate diff vs GT for non-GT pipelines
                let snpDiff = '';
                let gapDiff = '';
                if (gtPipelineId && pipeline !== gtPipelineId) {
                    if (gtSnpCount !== null) {
                        const diff = snpCount - gtSnpCount;
                        const diffSign = diff >= 0 ? '+' : '';
                        const diffPct = gtSnpCount > 0 ? ((diff / gtSnpCount) * 100).toFixed(2) : '0.00';
                        const diffPctSign = diff >= 0 ? '+' : '';
                        snpDiff = `<span class="pct" style="color:${diff < 0 ? '#e57373' : '#81c784'}">${diffSign}${diff.toLocaleString()} (${diffPctSign}${diffPct}%)</span>`;
                    }
                    if (gtGapCount !== null) {
                        const diff = gapCount - gtGapCount;
                        const diffSign = diff >= 0 ? '+' : '';
                        const diffPct = gtGapCount > 0 ? ((diff / gtGapCount) * 100).toFixed(2) : '0.00';
                        const diffPctSign = diff >= 0 ? '+' : '';
                        gapDiff = `<span class="pct" style="color:${diff > 0 ? '#e57373' : '#81c784'}">${diffSign}${diff.toLocaleString()} (${diffPctSign}${diffPct}%)</span>`;
                    }
                }

                // Usable SNPs: core - in_gt_gaps - (consensus - consensus_in_gt_gaps)
                let usableCount, usablePctVal;
                if (gtPipelineId && pipeline === gtPipelineId) {
                    // GT itself: usable = core - consensus
                    usableCount = coreCount - consCount;
                    usablePctVal = coreCount > 0 ? ((usableCount / coreCount) * 100).toFixed(2) : '0.00';
                } else if (gtPipelineId) {
                    // VCF pipeline: remove SNPs in GT gaps + consensus not in GT gaps
                    const inGtGaps = kpis.snps_in_gt_gaps_core ? (kpis.snps_in_gt_gaps_core[pipeline] || 0) : 0;
                    const consInGtGaps = kpis.snps_in_gt_gaps_consensus ? (kpis.snps_in_gt_gaps_consensus[pipeline] || 0) : 0;
                    usableCount = coreCount - inGtGaps - (consCount - consInGtGaps);
                    usablePctVal = coreCount > 0 ? ((usableCount / coreCount) * 100).toFixed(2) : '0.00';
                } else {
                    // No GT: usable = core - consensus
                    usableCount = coreCount - consCount;
                    usablePctVal = coreCount > 0 ? ((usableCount / coreCount) * 100).toFixed(2) : '0.00';
                }

                // Warning icon for MNPs
                const mnpWarning = mnpCount > 0 ? `<span class="mnp-warning" onclick="event.stopPropagation();showKpiInfo('mnp')" title="Click for MNP info">⚠️</span>` : '';
                // Warning icon for BAM pileup (no variant calling)
                const bamPileupWarning = isFromBamPileup ? `<span class="mnp-warning" style="color:#ff9800;" onclick="event.stopPropagation();showKpiInfo('bam_pileup')" title="SNPs from BAM pileup - no variant calling">⚠️</span>` : '';

                html += `<tr>
                    <td>${label}</td>
                    <td>${snpCount.toLocaleString()}<span class="pct">(${snpPct}%)</span>${bamPileupWarning}${snpDiff}</td>
                    <td>${coreCount.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                    <td>${consCount.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                    <td>${usableCount.toLocaleString()}<span class="pct">(${usablePctVal}%)</span></td>
                    <td>${gapCount.toLocaleString()}<span class="pct">(${gapPct}%)</span>${gapDiff}</td>
                    <td>${mnpCount.toLocaleString()}${mnpWarning}</td>
                </tr>`;
            }

            html += `</tbody></table>`;
            html += sectionEnd(); // close Per-Pipeline Statistics

            // === SECTION 3: Cross-Pipeline Concordance ===
            const concordance = await workerApi.getPipelineConcordance();
            if (concordance && Object.keys(concordance).length > 0) {
                html += sectionStart('Cross-Pipeline Concordance');

                // Build table with all pairwise concordance stats
                const allPipelines = sortedPipelineEntries(kpis.snps).map(([p]) => p);
                const getShortLabel = (p) => workerApi.getPipelineLabel(p).split(' ')[0];

                html += `<div style="font-size:11px;color:var(--text-secondary);margin-bottom:5px;">SNP positions shared between pipelines. % = shared / min(SNPs<sub>A</sub>, SNPs<sub>B</sub>)</div>`;
                html += `<table class="kpi-table">
                    <thead>
                        <tr>
                            <th></th>
                            <th colspan="2" style="text-align:center;">Concordance (same position) ${infoIcon('concordance')}</th>
                            <th colspan="2" style="text-align:center;">Consensus (same allele) ${infoIcon('consensus')}</th>
                        </tr>
                        <tr>
                            <th>A ∩ B</th>
                            <th style="text-align:center;" title="At least 1 sample has SNP in both pipelines. % = shared / min(SNPs_A, SNPs_B)">Any</th>
                            <th style="text-align:center;" title="ALL samples have SNP in both pipelines (Core ∩ Core). % = shared / min(SNPs_A, SNPs_B)">All</th>
                            <th style="text-align:center;" title="At least 1 sample has same allele in both pipelines. % = shared / min(SNPs_A, SNPs_B)">Any</th>
                            <th style="text-align:center;" title="ALL samples have same allele in both pipelines. % = shared / min(SNPs_A, SNPs_B)">All</th>
                        </tr>
                    </thead>
                    <tbody>`;

                // Show all unique pairs
                for (let i = 0; i < allPipelines.length; i++) {
                    const pipelineA = allPipelines[i];
                    const labelA = getShortLabel(pipelineA);
                    const snpsA = kpis.snps[pipelineA] || 0;
                    for (let j = i + 1; j < allPipelines.length; j++) {
                        const pipelineB = allPipelines[j];
                        const labelB = getShortLabel(pipelineB);
                        const snpsB = kpis.snps[pipelineB] || 0;

                        // Get concordance stats (check both directions since we only store one)
                        let stats = concordance[pipelineA]?.[pipelineB] || concordance[pipelineB]?.[pipelineA];
                        if (stats) {
                            // Calculate percentages relative to minimum SNPs (max possible overlap)
                            const minSnps = Math.min(snpsA, snpsB);
                            const pctConcAny = minSnps > 0 ? (stats.concordance_any / minSnps * 100).toFixed(1) : '0.0';
                            const pctConcAll = minSnps > 0 ? (stats.concordance_all / minSnps * 100).toFixed(1) : '0.0';
                            const pctConsAny = minSnps > 0 ? (stats.consensus_any / minSnps * 100).toFixed(1) : '0.0';
                            const pctConsAll = minSnps > 0 ? (stats.consensus_all / minSnps * 100).toFixed(1) : '0.0';

                            html += `<tr>
                                <td>${labelA} ∩ ${labelB}</td>
                                <td style="text-align:center;">${stats.concordance_any.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConcAny}%)</span></td>
                                <td style="text-align:center;">${stats.concordance_all.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConcAll}%)</span></td>
                                <td style="text-align:center;">${stats.consensus_any.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConsAny}%)</span></td>
                                <td style="text-align:center;">${stats.consensus_all.toLocaleString()} <span style="color:#888;font-size:0.85em">(${pctConsAll}%)</span></td>
                            </tr>`;
                        }
                    }
                }

                html += `</tbody></table>`;
                html += sectionEnd(); // close Cross-Pipeline Concordance
            }

            // === SECTION 4: Ground Truth Comparison (only if GT exists) ===
            if (gtPipelineId) {
                html += sectionStart('Ground Truth Comparison');

                const gtLabel = workerApi.getPipelineLabel(gtPipelineId);
                const gtShortLabel = gtLabel.split(' ')[0];

                // SNPs in GT Gaps - consolidated table
                if (kpis.snps_in_gt_gaps_total && Object.keys(kpis.snps_in_gt_gaps_total).length > 0) {
                    html += subLabel(`SNPs in ${gtShortLabel} Gaps`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>Any ${infoIcon('snps_in_gt_gaps')}</th>
                                <th>All ${infoIcon('all_snps_in_gt_gaps')}</th>
                                <th>Consensus ${infoIcon('consensus_snps_in_gt_gaps')}</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    for (const [pipeline, totalCount] of sortedPipelineEntries(kpis.snps_in_gt_gaps_total)) {
                        const label = workerApi.getPipelineLabel(pipeline).split(' ')[0];
                        const coreCount = kpis.snps_in_gt_gaps_core ? (kpis.snps_in_gt_gaps_core[pipeline] || 0) : 0;
                        const consCount = kpis.snps_in_gt_gaps_consensus ? (kpis.snps_in_gt_gaps_consensus[pipeline] || 0) : 0;
                        const totalSnps = kpis.snps[pipeline] || 1;
                        const coreSnps = kpis.core_snps ? (kpis.core_snps[pipeline] || 1) : 1;
                        const consSnps = kpis.consensus_snps ? (kpis.consensus_snps[pipeline] || 1) : 1;
                        const totalPct = ((totalCount / totalSnps) * 100).toFixed(1);
                        const corePct = ((coreCount / coreSnps) * 100).toFixed(1);
                        const consPct = ((consCount / consSnps) * 100).toFixed(1);

                        html += `<tr>
                            <td>${label}</td>
                            <td>${totalCount.toLocaleString()}<span class="pct">(${totalPct}%)</span></td>
                            <td>${coreCount.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                            <td>${consCount.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }

                // GT SNPs Filtered - consolidated table
                if (kpis.gt_snps_missing && kpis.gt_total_snps > 0) {
                    html += subLabel(`${gtShortLabel} SNPs Filtered by Pipeline`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>Any (/${kpis.gt_total_snps.toLocaleString()}) ${infoIcon('gt_snps_missing')}</th>
                                <th>All (/${(kpis.core_gt_total || 0).toLocaleString()}) ${infoIcon('all_gt_missing')}</th>
                                <th>Consensus (/${(kpis.consensus_gt_total || 0).toLocaleString()}) ${infoIcon('consensus_gt_missing')}</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    for (const [pipeline, totalMissing] of sortedPipelineEntries(kpis.gt_snps_missing)) {
                        const label = workerApi.getPipelineLabel(pipeline).split(' ')[0];
                        const coreMissing = kpis.core_gt_missing ? (kpis.core_gt_missing[pipeline] || 0) : 0;
                        const consMissing = kpis.consensus_gt_missing ? (kpis.consensus_gt_missing[pipeline] || 0) : 0;
                        const totalPct = ((totalMissing / kpis.gt_total_snps) * 100).toFixed(1);
                        const corePct = kpis.core_gt_total > 0 ? ((coreMissing / kpis.core_gt_total) * 100).toFixed(1) : '0';
                        const consPct = kpis.consensus_gt_total > 0 ? ((consMissing / kpis.consensus_gt_total) * 100).toFixed(1) : '0';

                        html += `<tr>
                            <td>${label}</td>
                            <td>${totalMissing.toLocaleString()}<span class="pct">(${totalPct}%)</span></td>
                            <td>${coreMissing.toLocaleString()}<span class="pct">(${corePct}%)</span></td>
                            <td>${consMissing.toLocaleString()}<span class="pct">(${consPct}%)</span></td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }
                html += sectionEnd(); // close Ground Truth Comparison
            }

            // === SECTION 5: Cross-Pipeline Gap Analysis (all pairwise combinations) ===
            const snpsInGaps = await workerApi.getSnpsInGaps();

            if (snpsInGaps && Object.keys(snpsInGaps).length > 0) {
                html += sectionStart('Cross-Pipeline Gap Analysis');

                // For each pipeline that has gaps (gap source)
                for (const gapPipeline of Object.keys(snpsInGaps).sort()) {
                    const gapPipelineStats = snpsInGaps[gapPipeline];
                    if (!gapPipelineStats || Object.keys(gapPipelineStats).length === 0) continue;

                    const gapLabel = workerApi.getPipelineLabel(gapPipeline).split(' ')[0];

                    html += subLabel(`SNPs in ${gapLabel} Gaps ${infoIcon('snps_in_pipeline_gaps')}`);
                    html += `<table class="kpi-table">
                        <thead>
                            <tr>
                                <th>Pipeline</th>
                                <th>SNPs in ${gapLabel} Gaps</th>
                                <th>Total SNPs</th>
                                <th>%</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    // Sort by pipeline name
                    const sortedSnpPipelines = Object.entries(gapPipelineStats)
                        .sort((a, b) => a[0].localeCompare(b[0]));

                    for (const [snpPipeline, stats] of sortedSnpPipelines) {
                        const snpLabel = workerApi.getPipelineLabel(snpPipeline).split(' ')[0];
                        const pct = stats.percentage.toFixed(2);
                        const pctClass = stats.percentage <= 1 ? 'good' : stats.percentage <= 5 ? 'warning' : 'bad';

                        html += `<tr>
                            <td>${snpLabel}</td>
                            <td>${stats.snps_in_gaps.toLocaleString()}</td>
                            <td>${stats.total_snps.toLocaleString()}</td>
                            <td class="${pctClass}">${pct}%</td>
                        </tr>`;
                    }
                    html += `</tbody></table>`;
                }
                html += sectionEnd(); // close Cross-Pipeline Gap Analysis
            }

            document.getElementById('kpis').innerHTML = html;
        }

        function createFilterButtons(pipelines) {
            const container = document.getElementById('filters');
            const infoIcon = (type) => `<span class="info-icon" onclick="event.stopPropagation();showKpiInfo('${type}')" style="margin-left:3px;">ⓘ</span>`;

            container.innerHTML = '<span style="color:#808080;margin-right:5px;">SNP Filters:</span>';

            // Get pipelines with VCF data (only these can have SNP filters)
            const vcfPipelines = workerApi.vcfPipelines;

            // Pipeline SNP filters - only for pipelines with VCF (with info icon inside)
            for (const p of pipelines) {
                if (!vcfPipelines.includes(p)) continue;
                const label = workerApi.getPipelineLabel(p);
                container.innerHTML += `<button class="filter-btn" data-filter="${p}" onclick="toggleFilter('${p}')">${label} ${infoIcon('filter_pipeline')}</button>`;
            }

            // Special SNP filters with info icons inside
            container.innerHTML += `
                <button class="filter-btn" data-filter="consensus" onclick="toggleFilter('consensus')">Consensus ${infoIcon('filter_consensus')}</button>
                <button class="filter-btn" data-filter="discordant" onclick="toggleFilter('discordant')">Discordant ${infoIcon('filter_discordant')}</button>
            `;

            // Gap filters - show all pipelines (with info icon inside)
            container.innerHTML += '<span style="color:#808080;margin-left:15px;margin-right:5px;">Gap Filters:</span>';
            for (const p of pipelines) {
                const label = workerApi.getPipelineLabel(p);
                container.innerHTML += `<button class="filter-btn gap-filter" data-filter="gaps:${p}" onclick="toggleFilter('gaps:${p}')">${label} Gaps ${infoIcon('filter_gaps')}</button>`;
            }
        }

        // Track hidden rows
        let hiddenRows = new Set();

        function createVisibilityControls(pipelines) {
            const container = document.getElementById('visibility-controls');
            let html = '';

            // Get ground truth pipeline (if any) - it's hidden from individual rows
            const groundTruthPipeline = workerApi.groundTruthPipeline;

            // Per-sample controls
            for (const sample of samples) {
                const sampleLabel = workerApi.getSampleLabel(sample);
                html += `<div class="vis-group">
                    <div class="vis-group-title">${sampleLabel}</div>
                    <div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-main" checked onchange="toggleRowVisibility('${sampleLabel}', this.checked)">
                        <label for="vis-${sample}-main">Sample</label>
                    </div>`;

                for (const p of pipelines) {
                    // Skip ground truth pipeline - it's not shown as a separate row
                    if (groundTruthPipeline && p === groundTruthPipeline) {
                        continue;
                    }
                    const pipelineLabel = workerApi.getPipelineLabel(p);
                    const rowId = `${sampleLabel}|${pipelineLabel}`;
                    html += `<div class="vis-item">
                        <input type="checkbox" id="vis-${sample}-${p}" checked onchange="toggleRowVisibility('${rowId}', this.checked)">
                        <label for="vis-${sample}-${p}">${pipelineLabel}</label>
                    </div>`;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function toggleRowVisibility(rowLabel, visible) {
            if (visible) {
                hiddenRows.delete(rowLabel);
            } else {
                hiddenRows.add(rowLabel);
            }
            applyRowVisibility();
        }

        function setAllRowVisibility(visible) {
            // Get all visibility checkboxes
            const checkboxes = document.querySelectorAll('#visibility-controls input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const isVisible = document.getElementById('visibility-filter').value.toLowerCase();
                const label = cb.nextElementSibling?.textContent?.toLowerCase() || '';
                // Only affect visible (not filtered out) checkboxes
                if (!isVisible || label.includes(isVisible)) {
                    cb.checked = visible;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        }

        function filterVisibilityCheckboxes(filter) {
            const lowerFilter = filter.toLowerCase();
            document.querySelectorAll('#visibility-controls .vis-item').forEach(item => {
                const label = item.querySelector('label')?.textContent?.toLowerCase() || '';
                item.style.display = !filter || label.includes(lowerFilter) ? '' : 'none';
            });
            // Also filter group titles visibility (hide group if all items hidden)
            document.querySelectorAll('#visibility-controls .vis-group').forEach(group => {
                const visibleItems = group.querySelectorAll('.vis-item:not([style*="display: none"])');
                group.style.display = visibleItems.length > 0 ? '' : 'none';
            });
        }

        function applyRowVisibility() {
            document.querySelectorAll('.alignment-view .row').forEach(row => {
                const lbl = row.querySelector('.lbl');
                if (lbl) {
                    const labelText = lbl.textContent.trim();
                    // Check if this row should be hidden
                    let shouldHide = hiddenRows.has(labelText);

                    // Also check for pipeline rows (sub labels)
                    if (lbl.classList.contains('sub')) {
                        // Find parent sample by looking at previous non-sub row
                        let prevRow = row.previousElementSibling;
                        while (prevRow && prevRow.querySelector('.lbl.sub')) {
                            prevRow = prevRow.previousElementSibling;
                        }
                        if (prevRow) {
                            const parentLabel = prevRow.querySelector('.lbl')?.textContent.trim();
                            const combinedLabel = `${parentLabel}|${labelText}`;
                            shouldHide = hiddenRows.has(combinedLabel) || hiddenRows.has(labelText);
                        }
                    }

                    row.classList.toggle('hidden-row', shouldHide);
                }
            });
        }

        window.toggleRowVisibility = toggleRowVisibility;

        let showNucleotideLetters = true;

        function toggleNucleotideLetters(show) {
            showNucleotideLetters = show;
            document.querySelectorAll('.alignment-view .row .cell').forEach(cell => {
                if (show) {
                    cell.classList.remove('hide-letters');
                } else {
                    cell.classList.add('hide-letters');
                }
            });
        }
        window.toggleNucleotideLetters = toggleNucleotideLetters;

        async function updateQualityFilter() {
            const minQual = parseInt(document.getElementById('min-qual').value) || 0;
            const minDepth = parseInt(document.getElementById('min-depth').value) || 0;
            const minConsensus = parseInt(document.getElementById('min-consensus').value) || 50;

            qualityFilters.minQual = minQual;
            qualityFilters.minDepth = minDepth;
            qualityFilters.minConsensus = minConsensus;

            // Reload positions with quality filtering
            currentPage = 0;
            await loadPositions();
        }

        async function resetQualityFilters() {
            document.getElementById('min-qual').value = 0;
            document.getElementById('min-depth').value = 0;
            document.getElementById('min-consensus').value = 50;

            qualityFilters.minQual = 0;
            qualityFilters.minDepth = 0;
            qualityFilters.minConsensus = 50;

            currentPage = 0;
            await loadPositions();
        }

        function filterByQuality(allPositions) {
            // If no quality filters, return all positions
            if (qualityFilters.minQual === 0 && qualityFilters.minDepth === 0) {
                return allPositions;
            }

            // Quality filtering is disabled with worker architecture
            // Would require O(positions * samples * pipelines) worker calls
            console.warn('Quality filtering temporarily disabled with worker architecture');
            const statsEl = document.getElementById('quality-stats');
            if (statsEl) {
                statsEl.textContent = 'Quality filtering not available (worker mode)';
            }
            return allPositions;
        }

        async function toggleFilter(filter) {
            console.log('toggleFilter called with:', filter);
            const idx = activeFilters.indexOf(filter);
            if (idx >= 0) {
                activeFilters.splice(idx, 1);
                console.log('Filter removed:', filter);
            } else {
                activeFilters.push(filter);
                console.log('Filter added:', filter);
            }
            console.log('Active filters:', activeFilters);

            // Update button states with INLINE styles (no cache issues)
            document.querySelectorAll('.filter-btn').forEach(btn => {
                const f = btn.dataset.filter;
                const isActive = activeFilters.includes(f);
                btn.classList.toggle('active', isActive);

                // Force inline styles
                if (isActive) {
                    btn.style.background = '#0066ff';
                    btn.style.color = 'white';
                    btn.style.fontWeight = 'bold';
                    btn.style.boxShadow = '0 0 10px #0066ff';
                    if (!btn.textContent.startsWith('✓')) {
                        btn.textContent = '✓ ' + btn.textContent;
                    }
                    console.log('Button activated:', f);
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.fontWeight = '';
                    btn.style.boxShadow = '';
                    btn.textContent = btn.textContent.replace(/^✓ /, '');
                }
            });

            currentPage = 0;
            showLoader('Applying filters...', '');
            // Allow UI to update before heavy computation
            await new Promise(r => setTimeout(r, 10));
            await loadPositions();
            hideLoader();
        }

        async function loadPositions() {
            const filterStr = activeFilters.join(',');
            const filterMode = document.getElementById('filter-mode').value;
            const sampleMode = document.getElementById('sample-mode').value;

            // Log filter info
            const pipelineFilters = activeFilters.filter(f =>
                !f.startsWith('gaps:') && f !== 'consensus' && f !== 'discordant'
            );
            const vcfPipelines = workerApi.vcfPipelines;
            const hasConsensus = activeFilters.includes('consensus');
            const hasDiscordant = activeFilters.includes('discordant');

            if (hasConsensus || hasDiscordant) {
                const scopeInfo = pipelineFilters.length > 0
                    ? `Selected: [${pipelineFilters.join(', ')}]`
                    : `All VCF pipelines: [${vcfPipelines.join(', ')}]`;
                console.log(`🔍 ${hasConsensus ? 'Consensus' : 'Discordant'} scope: ${scopeInfo}`);
            }

            let allPositions = await workerApi.getFilteredPositions(
                samples,
                filterStr,
                filterMode,
                sampleMode
            );
            console.log(`📊 Filters: [${filterStr}] → ${allPositions.length} positions`);

            // Apply quality filters
            const beforeQualityFilter = allPositions.length;
            positions = filterByQuality(allPositions);

            const modeInfo = activeFilters.length > 1 ? ` [${filterMode.toUpperCase()}, ${sampleMode}]` : '';
            let qualInfo = '';
            if (qualityFilters.minQual > 0 || qualityFilters.minDepth > 0) {
                qualInfo = ` (${beforeQualityFilter - positions.length} filtered by quality)`;
            }
            document.getElementById('status').textContent = `${positions.length.toLocaleString()} positions match filters${modeInfo}${qualInfo}`;

            // Update KPIs with filtered count when filters are active
            const hasFilters = activeFilters.length > 0 || qualityFilters.minQual > 0 || qualityFilters.minDepth > 0;
            await updateKPIs(hasFilters ? positions.length : null);

            await renderPage();
        }

        async function onFilterConfigChange() {
            if (activeFilters.length > 0) {
                showLoader('Applying filters...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage = 0;
                await loadPositions();
                hideLoader();
            }
        }

        async function renderPage() {
            const offset = currentPage * getPageSize();
            const html = await workerApi.renderFiltered(
                samples,
                positions,
                offset,
                getPageSize()
            );

            document.getElementById('alignment').innerHTML = html;

            // Apply row visibility settings
            applyRowVisibility();

            // Update pagination
            const totalPages = Math.ceil(positions.length / getPageSize());
            document.getElementById('page-info').textContent =
                `Page ${currentPage + 1} of ${totalPages} (${positions.length.toLocaleString()} positions)`;

            document.getElementById('prev-btn').disabled = currentPage === 0;
            document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
        }

        async function nextPage() {
            const totalPages = Math.ceil(positions.length / getPageSize());
            if (currentPage < totalPages - 1) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage++;
                await renderPage();
                hideLoader();
            }
        }

        async function prevPage() {
            if (currentPage > 0) {
                showLoader('Loading page...', '');
                await new Promise(r => setTimeout(r, 10));
                currentPage--;
                await renderPage();
                hideLoader();
            }
        }

        async function gotoPosition() {
            const pos = parseInt(document.getElementById('goto-pos').value);
            if (!pos || pos < 1) return;

            showLoader('Finding position...', `Position ${pos}`);
            await new Promise(r => setTimeout(r, 10));

            // Find the page containing this position
            const idx = positions.findIndex(p => p >= pos);
            if (idx >= 0) {
                currentPage = Math.floor(idx / getPageSize());
                await renderPage();
                hideLoader();
            } else {
                hideLoader();
                alert('Position not found in current filter');
            }
        }

        // Store pipeline distance matrices
        let pipelineDistanceMatrices = {};

        function populateMatrixPipelineSelector() {
            const select = document.getElementById('matrix-pipeline');
            if (!select) return;

            // Load pipeline distance matrices
            try {
                pipelineDistanceMatrices = workerApi.pipelineDistanceMatrices;
                console.log('Pipeline distance matrices:', pipelineDistanceMatrices);
            } catch (e) {
                pipelineDistanceMatrices = {};
            }

            select.innerHTML = '';
            for (const p of pipelines) {
                const label = workerApi.getPipelineLabel(p);
                select.innerHTML += `<option value="${p}">${label}</option>`;
            }

            // Initialize source selector for first pipeline
            onMatrixPipelineChange();
        }

        window.onMatrixPipelineChange = function() {
            const pipelineSelect = document.getElementById('matrix-pipeline');
            const sourceSelect = document.getElementById('matrix-source');
            if (!pipelineSelect || !sourceSelect) return;

            const pipelineId = pipelineSelect.value;

            // Reset source options
            sourceSelect.innerHTML = '<option value="coreguard">CoreGuard (calculated)</option>';

            // Add pipeline original if available
            if (pipelineDistanceMatrices[pipelineId]) {
                sourceSelect.innerHTML += `<option value="pipeline">Pipeline original</option>`;
            }

            onMatrixSourceChange();
        }

        window.onMatrixSourceChange = function() {
            const sourceSelect = document.getElementById('matrix-source');
            const modeLabel = document.getElementById('matrix-mode-label');
            const calculateRow = document.getElementById('matrix-calculate-row');
            const matrixResult = document.getElementById('matrix-result');

            if (!sourceSelect) return;

            const source = sourceSelect.value;

            if (source === 'pipeline') {
                // Hide mode and calculate button for pipeline matrices
                if (modeLabel) modeLabel.style.display = 'none';
                if (calculateRow) calculateRow.style.display = 'none';
                // Show pipeline matrix immediately
                showPipelineMatrix();
            } else {
                // Show mode and calculate button for CoreGuard
                if (modeLabel) modeLabel.style.display = '';
                if (calculateRow) calculateRow.style.display = '';
                // Clear result to prompt calculation
                if (matrixResult) matrixResult.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">Click "Calculate" to compute distance matrix.</p>';
            }
        }

        function showPipelineMatrix() {
            const pipelineSelect = document.getElementById('matrix-pipeline');
            const matrixResult = document.getElementById('matrix-result');
            if (!pipelineSelect || !matrixResult) return;

            const pipelineId = pipelineSelect.value;
            const pipelineLabel = workerApi.getPipelineLabel(pipelineId);
            const matrixData = pipelineDistanceMatrices[pipelineId];

            if (!matrixData) {
                matrixResult.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">No pipeline distance matrix available.</p>';
                return;
            }

            const { samples: matrixSamples, matrix } = matrixData;

            // Get sample labels
            const labels = matrixSamples.map(s => workerApi.getSampleLabel(s));

            // Build table HTML
            let html = `<p style="color:var(--accent);font-size:11px;margin-bottom:8px;">
                <strong>Source:</strong> Pre-computed by ${pipelineLabel} pipeline
            </p>`;
            html += '<div class="table-wrapper"><table class="distance-matrix-table"><thead><tr><th></th>';
            for (const label of labels) {
                html += `<th>${label}</th>`;
            }
            html += '</tr></thead><tbody>';

            for (let i = 0; i < matrixSamples.length; i++) {
                html += `<tr><th>${labels[i]}</th>`;
                for (let j = 0; j < matrixSamples.length; j++) {
                    const dist = matrix[i][j];
                    let cellClass = 'diagonal';
                    if (i !== j) {
                        if (dist <= 5) cellClass = 'low-dist';
                        else if (dist <= 20) cellClass = 'medium-dist';
                        else cellClass = 'high-dist';
                    }
                    html += `<td class="${cellClass}">${dist}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table></div>';

            matrixResult.innerHTML = html;
        }

        async function populateCoverageStats() {
            const container = document.getElementById('coverage-stats-content');
            if (!container) return;

            // Get coverage stats from WASM module
            try {
                const stats = await workerApi.getCoverageStats();
                console.log('Coverage stats:', stats);

                if (!stats || Object.keys(stats).length === 0) {
                    container.innerHTML = '<p style="color:var(--text-secondary);font-size:11px;">Coverage statistics not available in this report.</p>';
                    return;
                }

                // Helper to format min-max (avg)
                const formatRange = (min, max, avg, suffix = '') => {
                    if (min == null || max == null || avg == null) return 'N/A';
                    return `${min.toFixed ? min.toFixed(0) : min}-${max.toFixed ? max.toFixed(0) : max} (${avg.toFixed(1)})${suffix}`;
                };

                const formatPercent = (min, max, avg) => {
                    if (min == null || max == null || avg == null) return 'N/A';
                    return `${(min*100).toFixed(0)}-${(max*100).toFixed(0)}% (${(avg*100).toFixed(1)}%)`;
                };

                let html = '<div class="table-wrapper"><table class="distance-matrix-table" style="font-size:10px;">';
                html += '<thead><tr><th>Sample</th>';
                for (const p of pipelines) {
                    const label = workerApi.getPipelineLabel(p);
                    html += `<th>${label}<br><small>SNPs</small></th>`;
                    html += `<th>${label}<br><small>Depth</small></th>`;
                    html += `<th>${label}<br><small>Qual</small></th>`;
                    html += `<th>${label}<br><small>Consensus</small></th>`;
                }
                html += '</tr></thead><tbody>';

                for (const sample of samples) {
                    const sampleLabel = workerApi.getSampleLabel(sample);
                    html += `<tr><th>${sampleLabel}</th>`;

                    for (const p of pipelines) {
                        const sampleStats = stats[sample]?.[p] || {};
                        const snpCount = sampleStats.snp_count || 0;

                        // Depth: min-max (avg)
                        const depthStr = formatRange(sampleStats.depth_min, sampleStats.depth_max, sampleStats.depth_avg, 'x');

                        // Qual: min-max (avg)
                        const qualStr = formatRange(sampleStats.qual_min, sampleStats.qual_max, sampleStats.qual_avg);

                        // Consensus: min-max% (avg%)
                        const consStr = formatPercent(sampleStats.consensus_min, sampleStats.consensus_max, sampleStats.consensus_avg);

                        // Color code based on average depth
                        let depthClass = '';
                        if (sampleStats.depth_avg) {
                            if (sampleStats.depth_avg < 10) depthClass = 'high-dist';
                            else if (sampleStats.depth_avg < 20) depthClass = 'medium-dist';
                            else depthClass = 'low-dist';
                        }

                        html += `<td>${snpCount.toLocaleString()}</td>`;
                        html += `<td class="${depthClass}">${depthStr}</td>`;
                        html += `<td>${qualStr}</td>`;
                        html += `<td>${consStr}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody></table></div>';

                html += '<p style="color:var(--text-secondary);font-size:10px;margin-top:8px;">';
                html += 'Values show min-max (avg). Depth color: <span style="color:var(--snp-consensus);">≥20x</span> | <span style="color:var(--snp-uncertain);">10-20x</span> | <span style="color:var(--snp-discord);">&lt;10x</span>';
                html += '</p>';

                container.innerHTML = html;
            } catch (err) {
                console.error('Error loading coverage stats:', err);
                container.innerHTML = '<p style="color:var(--gap-color);font-size:11px;">Error loading coverage statistics.</p>';
            }
        }

        async function calculateDistanceMatrix() {
            showLoader('Calculating distance matrix...', '');
            // Wait for browser to paint the loader before blocking WASM calculation
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

            const selectedPipeline = document.getElementById('matrix-pipeline')?.value || '';
            const selectedMode = document.getElementById('matrix-mode')?.value || 'vcf_ref';
            // Use global quality filters
            const minDepth = parseInt(document.getElementById('min-depth')?.value) || 0;
            const minConsensus = parseInt(document.getElementById('min-consensus')?.value) || 0;
            const minQual = parseFloat(document.getElementById('min-qual')?.value) || 0;

            console.log('Distance matrix params:', { selectedPipeline, selectedMode, minDepth, minConsensus, minQual });

            try {
                const result = await workerApi.calculateDistanceMatrix(
                    selectedPipeline, selectedMode, minDepth, minConsensus, minQual
                );
                console.log('Distance matrix result:', result);

                if (!result.samples || result.samples.length === 0) {
                    document.getElementById('matrix-result').innerHTML = `
                        <p style="color:var(--gap-color);">No distance matrix data available.
                        Make sure the report was generated with BAM files for polymorphic site data.</p>
                    `;
                    hideLoader();
                    return;
                }

                const n = result.samples.length;
                const labels = result.labels || result.samples;

                // Find max distance for color scaling
                let maxDist = 0;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== j && result.matrix[i][j] > maxDist) {
                            maxDist = result.matrix[i][j];
                        }
                    }
                }

                // Build table HTML
                const pipelineLabel = result.pipeline ? workerApi.getPipelineLabel(result.pipeline) : 'Unknown';
                const modeLabels = {
                    'vcf_ref': 'VCF + Reference',
                    'vcf_bam': 'VCF + BAM pileup',
                    'bam_only': 'BAM only'
                };
                const modeLabel = modeLabels[result.mode] || result.mode;
                let filtersInfo = `depth≥${result.min_depth}`;
                if (result.min_qual > 0) filtersInfo += `, qual≥${result.min_qual}`;
                let html = `<div style="margin:10px 0;color:var(--text-secondary);font-size:11px;">
                    <strong>${pipelineLabel}</strong> (${modeLabel}, ${filtersInfo}): ${result.polymorphic_count || 'N/A'} polymorphic sites analyzed.
                    Values show SNP distance (comparable positions in parentheses).
                </div>`;

                html += '<table class="distance-matrix-table"><thead><tr><th></th>';
                for (const label of labels) {
                    html += `<th>${label}</th>`;
                }
                html += '</tr></thead><tbody>';

                for (let i = 0; i < n; i++) {
                    html += `<tr><th>${labels[i]}</th>`;
                    for (let j = 0; j < n; j++) {
                        if (i === j) {
                            html += '<td class="diagonal">-</td>';
                        } else {
                            const dist = result.matrix[i][j];
                            const comp = result.comparable[i][j];

                            // Color based on distance
                            let cellClass = 'low-dist';
                            if (maxDist > 0) {
                                const ratio = dist / maxDist;
                                if (ratio > 0.6) cellClass = 'high-dist';
                                else if (ratio > 0.2) cellClass = 'medium-dist';
                            }

                            html += `<td class="${cellClass}">${dist}<span class="comparable">(${comp})</span></td>`;
                        }
                    }
                    html += '</tr>';
                }

                html += '</tbody></table>';

                // Update info badge
                document.getElementById('matrix-info').textContent = `(${n} samples)`;
                document.getElementById('matrix-result').innerHTML = html;

            } catch (err) {
                console.error('Distance matrix calculation failed:', err);
                document.getElementById('matrix-result').innerHTML = `
                    <p style="color:var(--gap-color);">Error calculating distance matrix: ${err}</p>
                `;
            }

            hideLoader();
        }

        async function drawGenomeOverview() {
            const canvas = document.getElementById('genome-canvas');
            const ctx = canvas.getContext('2d');
            const refLen = workerApi.refLength;

            // Get theme colors from CSS variables
            const styles = getComputedStyle(document.documentElement);
            const bgPrimary = styles.getPropertyValue('--bg-primary').trim() || '#1e1e1e';
            const bgSecondary = styles.getPropertyValue('--bg-secondary').trim() || '#252526';
            const bgTertiary = styles.getPropertyValue('--bg-tertiary').trim() || '#3c3c3c';
            const textSecondary = styles.getPropertyValue('--text-secondary').trim() || '#808080';

            // Calculate dimensions
            const trackHeight = 28;
            const trackSpacing = 10;
            const height = (pipelines.length + 1) * (trackHeight + trackSpacing);
            const width = canvas.parentElement.clientWidth - 8; // Full container width minus padding

            // Set canvas size properly (set dimensions before scaling)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Clear canvas
            ctx.fillStyle = bgPrimary;
            ctx.fillRect(0, 0, width, height);

            // Draw reference bar
            ctx.fillStyle = bgTertiary;
            ctx.fillRect(0, 0, width, trackHeight);

            // Draw pipeline tracks
            const kpis = await workerApi.getKpis();

            // SNP and Gap colors matching legend
            const snpColor = '#4ec9b0';  // Teal for SNPs
            const gapColor = 'rgba(244, 71, 71, 0.7)';  // Red for gaps

            for (let idx = 0; idx < pipelines.length; idx++) {
                const pipeline = pipelines[idx];
                const y = (idx + 1) * (trackHeight + trackSpacing);

                // Draw track background
                ctx.fillStyle = bgSecondary;
                ctx.fillRect(0, y, width, trackHeight);

                // Draw pipeline label
                ctx.fillStyle = textSecondary;
                ctx.font = '9px monospace';
                const label = workerApi.getPipelineLabel(pipeline);
                ctx.fillText(label.substring(0, 15), 5, y + trackHeight / 2 + 3);

                // Draw SNP density (simplified - using bins)
                const binCount = Math.min(width, 500);
                const binSize = refLen / binCount;
                const snpBins = new Uint32Array(binCount);
                const gapBins = new Uint32Array(binCount);

                // Collect data from all samples for this pipeline
                for (const sample of samples) {
                    // Get SNP positions for this sample/pipeline
                    const allPositions = await workerApi.getFilteredPositions(
                        [sample],
                        pipeline,
                        'and',
                        'any'
                    );
                    for (const pos of allPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            snpBins[bin]++;
                        }
                    }

                    // Get gap positions
                    const gapPositions = await workerApi.getFilteredPositions(
                        [sample],
                        `gaps:${pipeline}`,
                        'and',
                        'any'
                    );
                    for (const pos of gapPositions) {
                        const bin = Math.floor((pos - 1) / binSize);
                        if (bin >= 0 && bin < binCount) {
                            gapBins[bin]++;
                        }
                    }
                }

                // Find max for normalization
                const maxSnp = Math.max(...snpBins, 1);
                const maxGap = Math.max(...gapBins, 1);

                // Draw gaps (red, bottom half)
                ctx.fillStyle = gapColor;
                for (let i = 0; i < binCount; i++) {
                    if (gapBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (gapBins[i] / maxGap) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + trackHeight - h, width / binCount + 1, h);
                    }
                }

                // Draw SNPs (teal, top half)
                ctx.fillStyle = snpColor;
                for (let i = 0; i < binCount; i++) {
                    if (snpBins[i] > 0) {
                        const x = (i / binCount) * width;
                        const h = (snpBins[i] / maxSnp) * (trackHeight / 2 - 1);
                        ctx.fillRect(x, y + 1, width / binCount + 1, h);
                    }
                }
            }

            // Draw genome ruler
            ctx.fillStyle = textSecondary;
            ctx.font = '9px monospace';
            const tickInterval = Math.pow(10, Math.floor(Math.log10(refLen)) - 1) * 5;
            for (let pos = 0; pos <= refLen; pos += tickInterval) {
                const x = (pos / refLen) * width;
                ctx.fillRect(x, 0, 1, 5);
                if (pos > 0 && pos < refLen) {
                    const label = (pos / 1000000).toFixed(1) + 'M';
                    ctx.fillText(label, x - 10, 12);
                }
            }

            // Update genome info
            document.getElementById('genome-info').textContent = `(${(refLen / 1000000).toFixed(2)} Mbp)`;

            // Click handler to navigate
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const pos = Math.floor((x / rect.width) * refLen) + 1;
                document.getElementById('goto-pos').value = pos;
                gotoPosition();
            };
        }

        main();
    </script>
</body>
</html>
